{"/home/travis/build/npmtest/node-npmtest-eslint/test.js":"/* istanbul instrument in package npmtest_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/lib.npmtest_eslint.js":"/* istanbul instrument in package npmtest_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_eslint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_eslint.__dirname + '/lib.npmtest_eslint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/api.js":"/**\n * @fileoverview Expose out ESLint and CLI to require.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nmodule.exports = {\n    linter: require(\"./eslint\"),\n    CLIEngine: require(\"./cli-engine\"),\n    RuleTester: require(\"./testers/rule-tester\"),\n    SourceCode: require(\"./util/source-code\")\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/eslint.js":"/**\n * @fileoverview Main ESLint object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    EventEmitter = require(\"events\").EventEmitter,\n    escope = require(\"escope\"),\n    levn = require(\"levn\"),\n    blankScriptAST = require(\"../conf/blank-script.json\"),\n    DEFAULT_PARSER = require(\"../conf/eslint-recommended\").parser,\n    replacements = require(\"../conf/replacements.json\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    validator = require(\"./config/config-validator\"),\n    Environments = require(\"./config/environments\"),\n    CommentEventGenerator = require(\"./util/comment-event-generator\"),\n    NodeEventGenerator = require(\"./util/node-event-generator\"),\n    SourceCode = require(\"./util/source-code\"),\n    Traverser = require(\"./util/traverser\"),\n    RuleContext = require(\"./rule-context\"),\n    rules = require(\"./rules\"),\n    timing = require(\"./timing\"),\n\n    pkg = require(\"../package.json\");\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The result of a parsing operation from parseForESLint()\n * @typedef {Object} CustomParseResult\n * @property {ASTNode} ast The ESTree AST Program node.\n * @property {Object} services An object containing additional services related\n *      to the parser.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Parses a list of \"name:boolean_value\" or/and \"name\" options divided by comma or\n * whitespace.\n * @param {string} string The string to parse.\n * @param {Comment} comment The comment node which has the string.\n * @returns {Object} Result map object of names and boolean values\n */\nfunction parseBooleanConfig(string, comment) {\n    const items = {};\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n    string = string.replace(/\\s*([:,])\\s*/g, \"$1\");\n\n    string.split(/\\s|,+/).forEach(name => {\n        if (!name) {\n            return;\n        }\n        const pos = name.indexOf(\":\");\n        let value;\n\n        if (pos !== -1) {\n            value = name.substring(pos + 1, name.length);\n            name = name.substring(0, pos);\n        }\n\n        items[name] = {\n            value: (value === \"true\"),\n            comment\n        };\n\n    });\n    return items;\n}\n\n/**\n * Parses a JSON-like config.\n * @param {string} string The string to parse.\n * @param {Object} location Start line and column of comments for potential error message.\n * @param {Object[]} messages The messages queue for potential error message.\n * @returns {Object} Result map object\n */\nfunction parseJsonConfig(string, location, messages) {\n    let items = {};\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n    try {\n        items = levn.parse(\"Object\", string) || {};\n\n        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n        // Also, commaless notations have invalid severity:\n        //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n        // Should ignore that case as well.\n        if (ConfigOps.isEverySeverityValid(items)) {\n            return items;\n        }\n    } catch (ex) {\n\n        // ignore to parse the string by a fallback.\n    }\n\n    // Optionator cannot parse commaless notations.\n    // But we are supporting that. So this is a fallback for that.\n    items = {};\n    string = string.replace(/([a-zA-Z0-9\\-/]+):/g, \"\\\"$1\\\":\").replace(/(]|[0-9])\\s+(?=\")/, \"$1,\");\n    try {\n        items = JSON.parse(`{${string}}`);\n    } catch (ex) {\n\n        messages.push({\n            ruleId: null,\n            fatal: true,\n            severity: 2,\n            source: null,\n            message: `Failed to parse JSON from '${string}': ${ex.message}`,\n            line: location.start.line,\n            column: location.start.column + 1\n        });\n\n    }\n\n    return items;\n}\n\n/**\n * Parses a config of values separated by comma.\n * @param {string} string The string to parse.\n * @returns {Object} Result map of values and true values\n */\nfunction parseListConfig(string) {\n    const items = {};\n\n    // Collapse whitespace around ,\n    string = string.replace(/\\s*,\\s*/g, \",\");\n\n    string.split(/,+/).forEach(name => {\n        name = name.trim();\n        if (!name) {\n            return;\n        }\n        items[name] = true;\n    });\n    return items;\n}\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {ASTNode} program The top node of the AST.\n * @param {Scope} globalScope The global scope.\n * @param {Object} config The existing configuration data.\n * @returns {void}\n */\nfunction addDeclaredGlobals(program, globalScope, config) {\n    const declaredGlobals = {},\n        exportedGlobals = {},\n        explicitGlobals = {},\n        builtin = Environments.get(\"builtin\");\n\n    Object.assign(declaredGlobals, builtin);\n\n    Object.keys(config.env).forEach(name => {\n        if (config.env[name]) {\n            const env = Environments.get(name),\n                environmentGlobals = env && env.globals;\n\n            if (environmentGlobals) {\n                Object.assign(declaredGlobals, environmentGlobals);\n            }\n        }\n    });\n\n    Object.assign(exportedGlobals, config.exported);\n    Object.assign(declaredGlobals, config.globals);\n    Object.assign(explicitGlobals, config.astGlobals);\n\n    Object.keys(declaredGlobals).forEach(name => {\n        let variable = globalScope.set.get(name);\n\n        if (!variable) {\n            variable = new escope.Variable(name, globalScope);\n            variable.eslintExplicitGlobal = false;\n            globalScope.variables.push(variable);\n            globalScope.set.set(name, variable);\n        }\n        variable.writeable = declaredGlobals[name];\n    });\n\n    Object.keys(explicitGlobals).forEach(name => {\n        let variable = globalScope.set.get(name);\n\n        if (!variable) {\n            variable = new escope.Variable(name, globalScope);\n            variable.eslintExplicitGlobal = true;\n            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;\n            globalScope.variables.push(variable);\n            globalScope.set.set(name, variable);\n        }\n        variable.writeable = explicitGlobals[name].value;\n    });\n\n    // mark all exported variables as such\n    Object.keys(exportedGlobals).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * Add data to reporting configuration to disable reporting for list of rules\n * starting from start location\n * @param  {Object[]} reportingConfig Current reporting configuration\n * @param  {Object} start Position to start\n * @param  {string[]} rulesToDisable List of rules\n * @returns {void}\n */\nfunction disableReporting(reportingConfig, start, rulesToDisable) {\n\n    if (rulesToDisable.length) {\n        rulesToDisable.forEach(rule => {\n            reportingConfig.push({\n                start,\n                end: null,\n                rule\n            });\n        });\n    } else {\n        reportingConfig.push({\n            start,\n            end: null,\n            rule: null\n        });\n    }\n}\n\n/**\n * Add data to reporting configuration to enable reporting for list of rules\n * starting from start location\n * @param  {Object[]} reportingConfig Current reporting configuration\n * @param  {Object} start Position to start\n * @param  {string[]} rulesToEnable List of rules\n * @returns {void}\n */\nfunction enableReporting(reportingConfig, start, rulesToEnable) {\n    let i;\n\n    if (rulesToEnable.length) {\n        rulesToEnable.forEach(rule => {\n            for (i = reportingConfig.length - 1; i >= 0; i--) {\n                if (!reportingConfig[i].end && reportingConfig[i].rule === rule) {\n                    reportingConfig[i].end = start;\n                    break;\n                }\n            }\n        });\n    } else {\n\n        // find all previous disabled locations if they was started as list of rules\n        let prevStart;\n\n        for (i = reportingConfig.length - 1; i >= 0; i--) {\n            if (prevStart && prevStart !== reportingConfig[i].start) {\n                break;\n            }\n\n            if (!reportingConfig[i].end) {\n                reportingConfig[i].end = start;\n                prevStart = reportingConfig[i].start;\n            }\n        }\n    }\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {Object} config The existing configuration data.\n * @param {Object[]} reportingConfig The existing reporting configuration data.\n * @param {Object[]} messages The messages queue.\n * @returns {Object} Modified config object\n */\nfunction modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {\n\n    let commentConfig = {\n        exported: {},\n        astGlobals: {},\n        rules: {},\n        env: {}\n    };\n    const commentRules = {};\n\n    ast.comments.forEach(comment => {\n\n        let value = comment.value.trim();\n        const match = /^(eslint(-\\w+){0,3}|exported|globals?)(\\s|$)/.exec(value);\n\n        if (match) {\n            value = value.substring(match.index + match[1].length);\n\n            if (comment.type === \"Block\") {\n                switch (match[1]) {\n                    case \"exported\":\n                        Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));\n                        break;\n\n                    case \"globals\":\n                    case \"global\":\n                        Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));\n                        break;\n\n                    case \"eslint-env\":\n                        Object.assign(commentConfig.env, parseListConfig(value));\n                        break;\n\n                    case \"eslint-disable\":\n                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                        break;\n\n                    case \"eslint-enable\":\n                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                        break;\n\n                    case \"eslint\": {\n                        const items = parseJsonConfig(value, comment.loc, messages);\n\n                        Object.keys(items).forEach(name => {\n                            const ruleValue = items[name];\n\n                            validator.validateRuleOptions(name, ruleValue, `${filename} line ${comment.loc.start.line}`);\n                            commentRules[name] = ruleValue;\n                        });\n                        break;\n                    }\n\n                    // no default\n                }\n            } else {        // comment.type === \"Line\"\n                if (match[1] === \"eslint-disable-line\") {\n                    disableReporting(reportingConfig, { line: comment.loc.start.line, column: 0 }, Object.keys(parseListConfig(value)));\n                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));\n                } else if (match[1] === \"eslint-disable-next-line\") {\n                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                    enableReporting(reportingConfig, { line: comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));\n                }\n            }\n        }\n    });\n\n    // apply environment configs\n    Object.keys(commentConfig.env).forEach(name => {\n        const env = Environments.get(name);\n\n        if (env) {\n            commentConfig = ConfigOps.merge(commentConfig, env);\n        }\n    });\n    Object.assign(commentConfig.rules, commentRules);\n\n    return ConfigOps.merge(config, commentConfig);\n}\n\n/**\n * Check if message of rule with ruleId should be ignored in location\n * @param  {Object[]} reportingConfig  Collection of ignore records\n * @param  {string} ruleId   Id of rule\n * @param  {Object} location Location of message\n * @returns {boolean}          True if message should be ignored, false otherwise\n */\nfunction isDisabledByReportingConfig(reportingConfig, ruleId, location) {\n\n    for (let i = 0, c = reportingConfig.length; i < c; i++) {\n\n        const ignore = reportingConfig[i];\n\n        if ((!ignore.rule || ignore.rule === ruleId) &&\n            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&\n            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @param  {boolean} isModule Whether the source type is module or not\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(ecmaVersion, isModule) {\n\n    // Need at least ES6 for modules\n    if (isModule && (!ecmaVersion || ecmaVersion < 6)) {\n        ecmaVersion = 6;\n    }\n\n    // Calculate ECMAScript edition number from official year version starting with\n    // ES2015, which corresponds with ES6 (or a difference of 2009).\n    if (ecmaVersion >= 2015) {\n        ecmaVersion -= 2009;\n    }\n\n    return ecmaVersion;\n}\n\n/**\n * Process initial config to make it safe to extend by file comment config\n * @param  {Object} config Initial config\n * @returns {Object}        Processed config\n */\nfunction prepareConfig(config) {\n\n    config.globals = config.globals || config.global || {};\n    delete config.global;\n\n    const copiedRules = {};\n    let parserOptions = {};\n\n    if (typeof config.rules === \"object\") {\n        Object.keys(config.rules).forEach(k => {\n            const rule = config.rules[k];\n\n            if (rule === null) {\n                throw new Error(`Invalid config for rule '${k}'.`);\n            }\n            if (Array.isArray(rule)) {\n                copiedRules[k] = rule.slice();\n            } else {\n                copiedRules[k] = rule;\n            }\n        });\n    }\n\n    // merge in environment parserOptions\n    if (typeof config.env === \"object\") {\n        Object.keys(config.env).forEach(envName => {\n            const env = Environments.get(envName);\n\n            if (config.env[envName] && env && env.parserOptions) {\n                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);\n            }\n        });\n    }\n\n    const preparedConfig = {\n        rules: copiedRules,\n        parser: config.parser || DEFAULT_PARSER,\n        globals: ConfigOps.merge({}, config.globals),\n        env: ConfigOps.merge({}, config.env || {}),\n        settings: ConfigOps.merge({}, config.settings || {}),\n        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})\n    };\n    const isModule = preparedConfig.parserOptions.sourceType === \"module\";\n\n    if (isModule) {\n        if (!preparedConfig.parserOptions.ecmaFeatures) {\n            preparedConfig.parserOptions.ecmaFeatures = {};\n        }\n\n        // can't have global return inside of modules\n        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;\n    }\n\n    preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);\n\n    return preparedConfig;\n}\n\n/**\n * Provide a stub rule with a given message\n * @param  {string} message The message to be displayed for the rule\n * @returns {Function}      Stub rule function\n */\nfunction createStubRule(message) {\n\n    /**\n     * Creates a fake rule object\n     * @param {Object} context context object for each rule\n     * @returns {Object} collection of node to listen on\n     */\n    function createRuleModule(context) {\n        return {\n            Program(node) {\n                context.report(node, message);\n            }\n        };\n    }\n\n    if (message) {\n        return createRuleModule;\n    }\n    throw new Error(\"No message passed to stub rule\");\n\n}\n\n/**\n * Provide a rule replacement message\n * @param  {string} ruleId Name of the rule\n * @returns {string}       Message detailing rule replacement\n */\nfunction getRuleReplacementMessage(ruleId) {\n    if (ruleId in replacements.rules) {\n        const newRules = replacements.rules[ruleId];\n\n        return `Rule '${ruleId}' was removed and replaced by: ${newRules.join(\", \")}`;\n    }\n\n    return null;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//g;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text))) {\n        retv = Object.assign(retv || {}, parseListConfig(match[1]));\n    }\n\n    return retv;\n}\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\nmodule.exports = (function() {\n\n    const api = Object.create(new EventEmitter());\n    let messages = [],\n        currentConfig = null,\n        currentScopes = null,\n        scopeManager = null,\n        currentFilename = null,\n        traverser = null,\n        reportingConfig = [],\n        sourceCode = null;\n\n    /**\n     * Parses text into an AST. Moved out here because the try-catch prevents\n     * optimization of functions, so it's best to keep the try-catch as isolated\n     * as possible\n     * @param {string} text The text to parse.\n     * @param {Object} config The ESLint configuration object.\n     * @param {string} filePath The path to the file being parsed.\n     * @returns {ASTNode|CustomParseResult} The AST or parse result if successful,\n     *      or null if not.\n     * @private\n     */\n    function parse(text, config, filePath) {\n\n        let parser,\n            parserOptions = {\n                loc: true,\n                range: true,\n                raw: true,\n                tokens: true,\n                comment: true,\n                attachComment: true,\n                filePath\n            };\n\n        try {\n            parser = require(config.parser);\n        } catch (ex) {\n            messages.push({\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                source: null,\n                message: ex.message,\n                line: 0,\n                column: 0\n            });\n\n            return null;\n        }\n\n        // merge in any additional parser options\n        if (config.parserOptions) {\n            parserOptions = Object.assign({}, config.parserOptions, parserOptions);\n        }\n\n        /*\n         * Check for parsing errors first. If there's a parsing error, nothing\n         * else can happen. However, a parsing error does not throw an error\n         * from this method - it's just considered a fatal error message, a\n         * problem that ESLint identified just like any other.\n         */\n        try {\n            if (typeof parser.parseForESLint === \"function\") {\n                return parser.parseForESLint(text, parserOptions);\n            }\n            return parser.parse(text, parserOptions);\n\n        } catch (ex) {\n\n            // If the message includes a leading line number, strip it:\n            const message = ex.message.replace(/^line \\d+:/i, \"\").trim();\n            const source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;\n\n            messages.push({\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                source,\n                message: `Parsing error: ${message}`,\n\n                line: ex.lineNumber,\n                column: ex.column\n            });\n\n            return null;\n        }\n    }\n\n    /**\n     * Get the severity level of a rule (0 - none, 1 - warning, 2 - error)\n     * Returns 0 if the rule config is not valid (an Array or a number)\n     * @param {Array|number} ruleConfig rule configuration\n     * @returns {number} 0, 1, or 2, indicating rule severity\n     */\n    function getRuleSeverity(ruleConfig) {\n        if (typeof ruleConfig === \"number\") {\n            return ruleConfig;\n        } else if (Array.isArray(ruleConfig)) {\n            return ruleConfig[0];\n        }\n        return 0;\n\n    }\n\n    /**\n     * Get the options for a rule (not including severity), if any\n     * @param {Array|number} ruleConfig rule configuration\n     * @returns {Array} of rule options, empty Array if none\n     */\n    function getRuleOptions(ruleConfig) {\n        if (Array.isArray(ruleConfig)) {\n            return ruleConfig.slice(1);\n        }\n        return [];\n\n    }\n\n    // set unlimited listeners (see https://github.com/eslint/eslint/issues/524)\n    api.setMaxListeners(0);\n\n    /**\n     * Resets the internal state of the object.\n     * @returns {void}\n     */\n    api.reset = function() {\n        this.removeAllListeners();\n        messages = [];\n        currentConfig = null;\n        currentScopes = null;\n        scopeManager = null;\n        traverser = null;\n        reportingConfig = [];\n        sourceCode = null;\n    };\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globalsto the code.\n     */\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.\n     *      Mostly useful for testing purposes.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {\n        const text = (typeof textOrSourceCode === \"string\") ? textOrSourceCode : null;\n        let ast,\n            parseResult,\n            shebang,\n            allowInlineConfig;\n\n        // evaluate arguments\n        if (typeof filenameOrOptions === \"object\") {\n            currentFilename = filenameOrOptions.filename;\n            allowInlineConfig = filenameOrOptions.allowInlineConfig;\n            saveState = filenameOrOptions.saveState;\n        } else {\n            currentFilename = filenameOrOptions;\n        }\n\n        if (!saveState) {\n            this.reset();\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = findEslintEnv(text || textOrSourceCode.text);\n\n        config = Object.assign({}, config);\n\n        if (envInFile) {\n            if (config.env) {\n                config.env = Object.assign({}, config.env, envInFile);\n            } else {\n                config.env = envInFile;\n            }\n        }\n\n        // process initial config to make it safe to extend\n        config = prepareConfig(config);\n\n        // only do this for text\n        if (text !== null) {\n\n            // there's no input, just exit here\n            if (text.trim().length === 0) {\n                sourceCode = new SourceCode(text, blankScriptAST);\n                return messages;\n            }\n\n            parseResult = parse(\n                stripUnicodeBOM(text).replace(/^#!([^\\r\\n]+)/, (match, captured) => {\n                    shebang = captured;\n                    return `//${captured}`;\n                }),\n                config,\n                currentFilename\n            );\n\n            // if this result is from a parseForESLint() method, normalize\n            if (parseResult && parseResult.ast) {\n                ast = parseResult.ast;\n            } else {\n                ast = parseResult;\n                parseResult = null;\n            }\n\n            if (ast) {\n                sourceCode = new SourceCode(text, ast);\n            }\n\n        } else {\n            sourceCode = textOrSourceCode;\n            ast = sourceCode.ast;\n        }\n\n        // if espree failed to parse the file, there's no sense in setting up rules\n        if (ast) {\n\n            // parse global comments and modify config\n            if (allowInlineConfig !== false) {\n                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);\n            }\n\n            // ensure that severities are normalized in the config\n            ConfigOps.normalize(config);\n\n            // enable appropriate rules\n            Object.keys(config.rules).filter(key => getRuleSeverity(config.rules[key]) > 0).forEach(key => {\n                let ruleCreator;\n\n                ruleCreator = rules.get(key);\n\n                if (!ruleCreator) {\n                    const replacementMsg = getRuleReplacementMessage(key);\n\n                    if (replacementMsg) {\n                        ruleCreator = createStubRule(replacementMsg);\n                    } else {\n                        ruleCreator = createStubRule(`Definition for rule '${key}' was not found`);\n                    }\n                    rules.define(key, ruleCreator);\n                }\n\n                const severity = getRuleSeverity(config.rules[key]);\n                const options = getRuleOptions(config.rules[key]);\n\n                try {\n                    const ruleContext = new RuleContext(\n                        key, api, severity, options,\n                        config.settings, config.parserOptions, config.parser,\n                        ruleCreator.meta,\n                        (parseResult && parseResult.services ? parseResult.services : {})\n                    );\n\n                    const rule = ruleCreator.create ? ruleCreator.create(ruleContext)\n                        : ruleCreator(ruleContext);\n\n                    // add all the selectors from the rule as listeners\n                    Object.keys(rule).forEach(selector => {\n                        api.on(selector, timing.enabled\n                            ? timing.time(key, rule[selector])\n                            : rule[selector]\n                        );\n                    });\n                } catch (ex) {\n                    ex.message = `Error while loading rule '${key}': ${ex.message}`;\n                    throw ex;\n                }\n            });\n\n            // save config so rules can access as necessary\n            currentConfig = config;\n            traverser = new Traverser();\n\n            const ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};\n            const ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;\n\n            // gather scope data that may be needed by the rules\n            scopeManager = escope.analyze(ast, {\n                ignoreEval: true,\n                nodejsScope: ecmaFeatures.globalReturn,\n                impliedStrict: ecmaFeatures.impliedStrict,\n                ecmaVersion,\n                sourceType: currentConfig.parserOptions.sourceType || \"script\",\n                fallback: Traverser.getKeys\n            });\n\n            currentScopes = scopeManager.scopes;\n\n            // augment global scope with declared global variables\n            addDeclaredGlobals(ast, currentScopes[0], currentConfig);\n\n            // remove shebang comments\n            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {\n                ast.comments.splice(0, 1);\n\n                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {\n                    ast.body[0].leadingComments.splice(0, 1);\n                }\n            }\n\n            let eventGenerator = new NodeEventGenerator(api);\n\n            eventGenerator = new CodePathAnalyzer(eventGenerator);\n            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);\n\n            /*\n             * Each node has a type property. Whenever a particular type of\n             * node is found, an event is fired. This allows any listeners to\n             * automatically be informed that this type of node has been found\n             * and react accordingly.\n             */\n            traverser.traverse(ast, {\n                enter(node, parent) {\n                    node.parent = parent;\n                    eventGenerator.enterNode(node);\n                },\n                leave(node) {\n                    eventGenerator.leaveNode(node);\n                }\n            });\n        }\n\n        // sort by line and column\n        messages.sort((a, b) => {\n            const lineDiff = a.line - b.line;\n\n            if (lineDiff === 0) {\n                return a.column - b.column;\n            }\n            return lineDiff;\n\n        });\n\n        return messages;\n    };\n\n    /**\n     * Reports a message from one of the rules.\n     * @param {string} ruleId The ID of the rule causing the message.\n     * @param {number} severity The severity level of the rule as configured.\n     * @param {ASTNode} node The AST node that the message relates to.\n     * @param {Object=} location An object containing the error line and column\n     *      numbers. If location is not provided the node's start location will\n     *      be used.\n     * @param {string} message The actual message.\n     * @param {Object} opts Optional template data which produces a formatted message\n     *     with symbols being replaced by this object's values.\n     * @param {Object} fix A fix command description.\n     * @param {Object} meta Metadata of the rule\n     * @returns {void}\n     */\n    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {\n        if (node) {\n            assert.strictEqual(typeof node, \"object\", \"Node must be an object\");\n        }\n\n        if (typeof location === \"string\") {\n            assert.ok(node, \"Node must be provided when reporting error if location is not provided\");\n\n            meta = fix;\n            fix = opts;\n            opts = message;\n            message = location;\n            location = node.loc.start;\n        }\n\n        // Store end location.\n        const endLocation = location.end;\n\n        location = location.start || location;\n\n        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {\n            return;\n        }\n\n        if (opts) {\n            message = message.replace(/\\{\\{\\s*([^{}]+?)\\s*\\}\\}/g, (fullMatch, term) => {\n                if (term in opts) {\n                    return opts[term];\n                }\n\n                // Preserve old behavior: If parameter name not provided, don't replace it.\n                return fullMatch;\n            });\n        }\n\n        const problem = {\n            ruleId,\n            severity,\n            message,\n            line: location.line,\n            column: location.column + 1,   // switch to 1-base instead of 0-base\n            nodeType: node && node.type,\n            source: sourceCode.lines[location.line - 1] || \"\"\n        };\n\n        // Define endLine and endColumn if exists.\n        if (endLocation) {\n            problem.endLine = endLocation.line;\n            problem.endColumn = endLocation.column + 1;   // switch to 1-base instead of 0-base\n        }\n\n        // ensure there's range and text properties, otherwise it's not a valid fix\n        if (fix && Array.isArray(fix.range) && (typeof fix.text === \"string\")) {\n\n            // If rule uses fix, has metadata, but has no metadata.fixable, we should throw\n            if (meta && !meta.fixable) {\n                throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n            }\n\n            problem.fix = fix;\n        }\n\n        messages.push(problem);\n    };\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    api.getSourceCode = function() {\n        return sourceCode;\n    };\n\n    // methods that exist on SourceCode object\n    const externalMethods = {\n        getSource: \"getText\",\n        getSourceLines: \"getLines\",\n        getAllComments: \"getAllComments\",\n        getNodeByRangeIndex: \"getNodeByRangeIndex\",\n        getComments: \"getComments\",\n        getJSDocComment: \"getJSDocComment\",\n        getFirstToken: \"getFirstToken\",\n        getFirstTokens: \"getFirstTokens\",\n        getLastToken: \"getLastToken\",\n        getLastTokens: \"getLastTokens\",\n        getTokenAfter: \"getTokenAfter\",\n        getTokenBefore: \"getTokenBefore\",\n        getTokenByRangeStart: \"getTokenByRangeStart\",\n        getTokens: \"getTokens\",\n        getTokensAfter: \"getTokensAfter\",\n        getTokensBefore: \"getTokensBefore\",\n        getTokensBetween: \"getTokensBetween\"\n    };\n\n    // copy over methods\n    Object.keys(externalMethods).forEach(methodName => {\n        const exMethodName = externalMethods[methodName];\n\n        // All functions expected to have less arguments than 5.\n        api[methodName] = function(a, b, c, d, e) {\n            if (sourceCode) {\n                return sourceCode[exMethodName](a, b, c, d, e);\n            }\n            return null;\n        };\n    });\n\n    /**\n     * Gets nodes that are ancestors of current node.\n     * @returns {ASTNode[]} Array of objects representing ancestors.\n     */\n    api.getAncestors = function() {\n        return traverser.parents();\n    };\n\n    /**\n     * Gets the scope for the current node.\n     * @returns {Object} An object representing the current node's scope.\n     */\n    api.getScope = function() {\n        const parents = traverser.parents();\n\n        // Don't do this for Program nodes - they have no parents\n        if (parents.length) {\n\n            // if current node introduces a scope, add it to the list\n            const current = traverser.current();\n\n            if (currentConfig.parserOptions.ecmaVersion >= 6) {\n                if ([\"BlockStatement\", \"SwitchStatement\", \"CatchClause\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(current.type) >= 0) {\n                    parents.push(current);\n                }\n            } else {\n                if ([\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(current.type) >= 0) {\n                    parents.push(current);\n                }\n            }\n\n            // Ascend the current node's parents\n            for (let i = parents.length - 1; i >= 0; --i) {\n\n                // Get the innermost scope\n                const scope = scopeManager.acquire(parents[i], true);\n\n                if (scope) {\n                    if (scope.type === \"function-expression-name\") {\n                        return scope.childScopes[0];\n                    }\n                    return scope;\n\n                }\n\n            }\n\n        }\n\n        return currentScopes[0];\n    };\n\n    /**\n     * Record that a particular variable has been used in code\n     * @param {string} name The name of the variable to mark as used\n     * @returns {boolean} True if the variable was found and marked as used,\n     *      false if not.\n     */\n    api.markVariableAsUsed = function(name) {\n        const hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,\n            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === \"module\";\n        let scope = this.getScope(),\n            i,\n            len;\n\n        // Special Node.js scope means we need to start one level deeper\n        if (scope.type === \"global\" && specialScope) {\n            scope = scope.childScopes[0];\n        }\n\n        do {\n            const variables = scope.variables;\n\n            for (i = 0, len = variables.length; i < len; i++) {\n                if (variables[i].name === name) {\n                    variables[i].eslintUsed = true;\n                    return true;\n                }\n            }\n        } while ((scope = scope.upper));\n\n        return false;\n    };\n\n    /**\n     * Gets the filename for the currently parsed source.\n     * @returns {string} The filename associated with the source being parsed.\n     *     Defaults to \"<input>\" if no filename info is present.\n     */\n    api.getFilename = function() {\n        if (typeof currentFilename === \"string\") {\n            return currentFilename;\n        }\n        return \"<input>\";\n\n    };\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    const defineRule = api.defineRule = function(ruleId, ruleModule) {\n        rules.define(ruleId, ruleModule);\n    };\n\n    /**\n     * Defines many new linting rules.\n     * @param {Object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    api.defineRules = function(rulesToDefine) {\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    };\n\n    /**\n     * Gets the default eslint configuration.\n     * @returns {Object} Object mapping rule IDs to their default configurations\n     */\n    api.defaults = function() {\n        return require(\"../conf/eslint-recommended\");\n    };\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map} All loaded rules\n     */\n    api.getRules = function() {\n        return rules.getAllLoadedRules();\n    };\n\n    api.version = pkg.version;\n\n    /**\n     * Gets variables that are declared by a specified node.\n     *\n     * The variables are its `defs[].node` or `defs[].parent` is same as the specified node.\n     * Specifically, below:\n     *\n     * - `VariableDeclaration` - variables of its all declarators.\n     * - `VariableDeclarator` - variables.\n     * - `FunctionDeclaration`/`FunctionExpression` - its function name and parameters.\n     * - `ArrowFunctionExpression` - its parameters.\n     * - `ClassDeclaration`/`ClassExpression` - its class name.\n     * - `CatchClause` - variables of its exception.\n     * - `ImportDeclaration` - variables of  its all specifiers.\n     * - `ImportSpecifier`/`ImportDefaultSpecifier`/`ImportNamespaceSpecifier` - a variable.\n     * - others - always an empty array.\n     *\n     * @param {ASTNode} node A node to get.\n     * @returns {escope.Variable[]} Variables that are declared by the node.\n     */\n    api.getDeclaredVariables = function(node) {\n        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];\n    };\n\n    return api;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/conf/eslint-recommended.js":"/**\n * @fileoverview Configuration applied when a user configuration extends from\n * eslint:recommended.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/* eslint sort-keys: [\"error\", \"asc\"], quote-props: [\"error\", \"consistent\"] */\n/* eslint-disable sort-keys */\n\nmodule.exports = {\n    parser: \"espree\",\n    ecmaFeatures: {},\n\n    rules: {\n\n        /* eslint-enable sort-keys */\n        \"accessor-pairs\": \"off\",\n        \"array-bracket-spacing\": \"off\",\n        \"array-callback-return\": \"off\",\n        \"arrow-body-style\": \"off\",\n        \"arrow-parens\": \"off\",\n        \"arrow-spacing\": \"off\",\n        \"block-scoped-var\": \"off\",\n        \"block-spacing\": \"off\",\n        \"brace-style\": \"off\",\n        \"callback-return\": \"off\",\n        \"camelcase\": \"off\",\n        \"capitalized-comments\": \"off\",\n        \"class-methods-use-this\": \"off\",\n        \"comma-dangle\": \"off\",\n        \"comma-spacing\": \"off\",\n        \"comma-style\": \"off\",\n        \"complexity\": \"off\",\n        \"computed-property-spacing\": \"off\",\n        \"consistent-return\": \"off\",\n        \"consistent-this\": \"off\",\n        \"constructor-super\": \"error\",\n        \"curly\": \"off\",\n        \"default-case\": \"off\",\n        \"dot-location\": \"off\",\n        \"dot-notation\": \"off\",\n        \"eol-last\": \"off\",\n        \"eqeqeq\": \"off\",\n        \"func-call-spacing\": \"off\",\n        \"func-name-matching\": \"off\",\n        \"func-names\": \"off\",\n        \"func-style\": \"off\",\n        \"generator-star-spacing\": \"off\",\n        \"global-require\": \"off\",\n        \"guard-for-in\": \"off\",\n        \"handle-callback-err\": \"off\",\n        \"id-blacklist\": \"off\",\n        \"id-length\": \"off\",\n        \"id-match\": \"off\",\n        \"indent\": \"off\",\n        \"init-declarations\": \"off\",\n        \"jsx-quotes\": \"off\",\n        \"key-spacing\": \"off\",\n        \"keyword-spacing\": \"off\",\n        \"line-comment-position\": \"off\",\n        \"linebreak-style\": \"off\",\n        \"lines-around-comment\": \"off\",\n        \"lines-around-directive\": \"off\",\n        \"max-depth\": \"off\",\n        \"max-len\": \"off\",\n        \"max-lines\": \"off\",\n        \"max-nested-callbacks\": \"off\",\n        \"max-params\": \"off\",\n        \"max-statements\": \"off\",\n        \"max-statements-per-line\": \"off\",\n        \"multiline-ternary\": \"off\",\n        \"new-cap\": \"off\",\n        \"new-parens\": \"off\",\n        \"newline-after-var\": \"off\",\n        \"newline-before-return\": \"off\",\n        \"newline-per-chained-call\": \"off\",\n        \"no-alert\": \"off\",\n        \"no-array-constructor\": \"off\",\n        \"no-await-in-loop\": \"off\",\n        \"no-bitwise\": \"off\",\n        \"no-caller\": \"off\",\n        \"no-case-declarations\": \"error\",\n        \"no-catch-shadow\": \"off\",\n        \"no-class-assign\": \"error\",\n        \"no-compare-neg-zero\": \"off\",\n        \"no-cond-assign\": \"error\",\n        \"no-confusing-arrow\": \"off\",\n        \"no-console\": \"error\",\n        \"no-const-assign\": \"error\",\n        \"no-constant-condition\": \"error\",\n        \"no-continue\": \"off\",\n        \"no-control-regex\": \"error\",\n        \"no-debugger\": \"error\",\n        \"no-delete-var\": \"error\",\n        \"no-div-regex\": \"off\",\n        \"no-dupe-args\": \"error\",\n        \"no-dupe-class-members\": \"error\",\n        \"no-dupe-keys\": \"error\",\n        \"no-duplicate-case\": \"error\",\n        \"no-duplicate-imports\": \"off\",\n        \"no-else-return\": \"off\",\n        \"no-empty\": \"error\",\n        \"no-empty-character-class\": \"error\",\n        \"no-empty-function\": \"off\",\n        \"no-empty-pattern\": \"error\",\n        \"no-eq-null\": \"off\",\n        \"no-eval\": \"off\",\n        \"no-ex-assign\": \"error\",\n        \"no-extend-native\": \"off\",\n        \"no-extra-bind\": \"off\",\n        \"no-extra-boolean-cast\": \"error\",\n        \"no-extra-label\": \"off\",\n        \"no-extra-parens\": \"off\",\n        \"no-extra-semi\": \"error\",\n        \"no-fallthrough\": \"error\",\n        \"no-floating-decimal\": \"off\",\n        \"no-func-assign\": \"error\",\n        \"no-global-assign\": \"error\",\n        \"no-implicit-coercion\": \"off\",\n        \"no-implicit-globals\": \"off\",\n        \"no-implied-eval\": \"off\",\n        \"no-inline-comments\": \"off\",\n        \"no-inner-declarations\": \"error\",\n        \"no-invalid-regexp\": \"error\",\n        \"no-invalid-this\": \"off\",\n        \"no-irregular-whitespace\": \"error\",\n        \"no-iterator\": \"off\",\n        \"no-label-var\": \"off\",\n        \"no-labels\": \"off\",\n        \"no-lone-blocks\": \"off\",\n        \"no-lonely-if\": \"off\",\n        \"no-loop-func\": \"off\",\n        \"no-magic-numbers\": \"off\",\n        \"no-mixed-operators\": \"off\",\n        \"no-mixed-requires\": \"off\",\n        \"no-mixed-spaces-and-tabs\": \"error\",\n        \"no-multi-assign\": \"off\",\n        \"no-multi-spaces\": \"off\",\n        \"no-multi-str\": \"off\",\n        \"no-multiple-empty-lines\": \"off\",\n        \"no-native-reassign\": \"off\",\n        \"no-negated-condition\": \"off\",\n        \"no-negated-in-lhs\": \"off\",\n        \"no-nested-ternary\": \"off\",\n        \"no-new\": \"off\",\n        \"no-new-func\": \"off\",\n        \"no-new-object\": \"off\",\n        \"no-new-require\": \"off\",\n        \"no-new-symbol\": \"error\",\n        \"no-new-wrappers\": \"off\",\n        \"no-obj-calls\": \"error\",\n        \"no-octal\": \"error\",\n        \"no-octal-escape\": \"off\",\n        \"no-param-reassign\": \"off\",\n        \"no-path-concat\": \"off\",\n        \"no-plusplus\": \"off\",\n        \"no-process-env\": \"off\",\n        \"no-process-exit\": \"off\",\n        \"no-proto\": \"off\",\n        \"no-prototype-builtins\": \"off\",\n        \"no-redeclare\": \"error\",\n        \"no-regex-spaces\": \"error\",\n        \"no-restricted-globals\": \"off\",\n        \"no-restricted-imports\": \"off\",\n        \"no-restricted-modules\": \"off\",\n        \"no-restricted-properties\": \"off\",\n        \"no-restricted-syntax\": \"off\",\n        \"no-return-assign\": \"off\",\n        \"no-return-await\": \"off\",\n        \"no-script-url\": \"off\",\n        \"no-self-assign\": \"error\",\n        \"no-self-compare\": \"off\",\n        \"no-sequences\": \"off\",\n        \"no-shadow\": \"off\",\n        \"no-shadow-restricted-names\": \"off\",\n        \"no-spaced-func\": \"off\",\n        \"no-sparse-arrays\": \"error\",\n        \"no-sync\": \"off\",\n        \"no-tabs\": \"off\",\n        \"no-template-curly-in-string\": \"off\",\n        \"no-ternary\": \"off\",\n        \"no-this-before-super\": \"error\",\n        \"no-throw-literal\": \"off\",\n        \"no-trailing-spaces\": \"off\",\n        \"no-undef\": \"error\",\n        \"no-undef-init\": \"off\",\n        \"no-undefined\": \"off\",\n        \"no-underscore-dangle\": \"off\",\n        \"no-unexpected-multiline\": \"error\",\n        \"no-unmodified-loop-condition\": \"off\",\n        \"no-unneeded-ternary\": \"off\",\n        \"no-unreachable\": \"error\",\n        \"no-unsafe-finally\": \"error\",\n        \"no-unsafe-negation\": \"error\",\n        \"no-unused-expressions\": \"off\",\n        \"no-unused-labels\": \"error\",\n        \"no-unused-vars\": \"error\",\n        \"no-use-before-define\": \"off\",\n        \"no-useless-call\": \"off\",\n        \"no-useless-computed-key\": \"off\",\n        \"no-useless-concat\": \"off\",\n        \"no-useless-constructor\": \"off\",\n        \"no-useless-escape\": \"off\",\n        \"no-useless-rename\": \"off\",\n        \"no-useless-return\": \"off\",\n        \"no-var\": \"off\",\n        \"no-void\": \"off\",\n        \"no-warning-comments\": \"off\",\n        \"no-whitespace-before-property\": \"off\",\n        \"no-with\": \"off\",\n        \"nonblock-statement-body-position\": \"off\",\n        \"object-curly-newline\": \"off\",\n        \"object-curly-spacing\": [\"off\", \"never\"],\n        \"object-property-newline\": \"off\",\n        \"object-shorthand\": \"off\",\n        \"one-var\": \"off\",\n        \"one-var-declaration-per-line\": \"off\",\n        \"operator-assignment\": \"off\",\n        \"operator-linebreak\": \"off\",\n        \"padded-blocks\": \"off\",\n        \"prefer-arrow-callback\": \"off\",\n        \"prefer-const\": \"off\",\n        \"prefer-destructuring\": \"off\",\n        \"prefer-numeric-literals\": \"off\",\n        \"prefer-promise-reject-errors\": \"off\",\n        \"prefer-reflect\": \"off\",\n        \"prefer-rest-params\": \"off\",\n        \"prefer-spread\": \"off\",\n        \"prefer-template\": \"off\",\n        \"quote-props\": \"off\",\n        \"quotes\": \"off\",\n        \"radix\": \"off\",\n        \"require-await\": \"off\",\n        \"require-jsdoc\": \"off\",\n        \"require-yield\": \"error\",\n        \"rest-spread-spacing\": \"off\",\n        \"semi\": \"off\",\n        \"semi-spacing\": \"off\",\n        \"sort-imports\": \"off\",\n        \"sort-keys\": \"off\",\n        \"sort-vars\": \"off\",\n        \"space-before-blocks\": \"off\",\n        \"space-before-function-paren\": \"off\",\n        \"space-in-parens\": \"off\",\n        \"space-infix-ops\": \"off\",\n        \"space-unary-ops\": \"off\",\n        \"spaced-comment\": \"off\",\n        \"strict\": \"off\",\n        \"symbol-description\": \"off\",\n        \"template-curly-spacing\": \"off\",\n        \"template-tag-spacing\": \"off\",\n        \"unicode-bom\": \"off\",\n        \"use-isnan\": \"error\",\n        \"valid-jsdoc\": \"off\",\n        \"valid-typeof\": \"error\",\n        \"vars-on-top\": \"off\",\n        \"wrap-iife\": \"off\",\n        \"wrap-regex\": \"off\",\n        \"yield-star-spacing\": \"off\",\n        \"yoda\": \"off\"\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/code-path-analyzer.js":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n *\n * @param {ASTNode} node - A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n *\n * @param {ASTNode} node - An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node);\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node);\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node);\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LogicalExpression\":\n            if (parent.right === node) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"LogicalExpression\":\n            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                astUtils.getLabel(node));\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, astUtils.getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n        case \"LogicalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    /**\n     * @param {EventGenerator} eventGenerator - An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        // Updates the code path.\n        // And emits onCodePathStart/onCodePathSegmentStart events.\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path.\n        // And emits onCodePathStart/onCodePathSegmentStart events.\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     *\n     * @param {CodePathSegment} fromSegment - A segment of prev.\n     * @param {CodePathSegment} toSegment - A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/code-path.js":"/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    /**\n     * @param {string} id - An identifier.\n     * @param {CodePath|null} upper - The code path of the upper function scope.\n     * @param {Function} onLooped - A callback function to notify looping.\n     */\n    constructor(id, upper, onLooped) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) });\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     *\n     * @param {CodePath} codePath - A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments.\n     * This array is a mix of `returnedSegments` and `thrownSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments which is with `return` statements.\n     * This array contains the last path segment if it's reachable.\n     * Since the reachable last path returns `undefined`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments which is with `throw` statements.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Current code path segments.\n     * @type {CodePathSegment[]}\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments(function(segment, controller) {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` object has two methods.\n     *\n     * - `controller.skip()` - Skip the following segments in this branch.\n     * - `controller.break()` - Skip all following segments.\n     *\n     * @param {Object} [options] - Omittable.\n     * @param {CodePathSegment} [options.first] - The first segment to traverse.\n     * @param {CodePathSegment} [options.last] - The last segment to traverse.\n     * @param {Function} callback - A callback function.\n     * @returns {void}\n     */\n    traverseSegments(options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = null;\n        }\n\n        options = options || {};\n        const startSegment = options.first || this.internal.initialSegment;\n        const lastSegment = options.last;\n\n        let item = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n        const visited = Object.create(null);\n        const stack = [[startSegment, 0]];\n        let skippedSegment = null;\n        let broken = false;\n        const controller = {\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment - A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited[prevSegment.id] ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        while (stack.length > 0) {\n            item = stack[stack.length - 1];\n            segment = item[0];\n            index = item[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited[segment.id]) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the flag of skipping if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n                    skippedSegment = null;\n                }\n                visited[segment.id] = true;\n\n                // Call the callback when the first time.\n                if (!skippedSegment) {\n                    callback.call(this, segment, controller); // eslint-disable-line callback-return\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n                item[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n                item[0] = segment.nextSegments[index];\n                item[1] = 0;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/code-path-state.js":"/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n *\n * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments - Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n *\n * @param {any[]} xs - An array to remove the specific element.\n * @param {any} x - An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n *\n * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n *\n * @param {CodePathState} state - The instance.\n * @param {CodePathSegment[]} fromSegments - Segments which are source.\n * @param {CodePathSegment[]} toSegments - Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, fromSegments, toSegments) {\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n *\n * @param {LoopContext} context - A loop context to modify.\n * @param {ChoiceContext} choiceContext - A choice context of this loop.\n * @param {CodePathSegment[]} head - The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    /**\n     * @param {IdGenerator} idGenerator - An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped - A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[ 0 ];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     *\n     * @param {boolean} forkLeavingPath - A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     *\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression,\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     *\n     * @param {string} kind - A kind string.\n     *   If the new context is LogicalExpression's, this is `\"&&\"` or `\"||\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult - A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     *\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     *\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            const prevForkContext =\n                context.kind === \"&&\" ? context.trueForkContext\n                /* kind === \"||\" */ : context.falseForkContext;\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            if (context.kind === \"&&\") {\n\n                // The path does short-circuit if false.\n                context.falseForkContext.add(forkContext.head);\n            } else {\n\n                // The path does short-circuit if true.\n                context.trueForkContext.add(forkContext.head);\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     *\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     *\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     *\n     * @param {boolean} hasCase - `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label - The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     *\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     *\n     * @param {boolean} isEmpty - `true` if the body is empty.\n     * @param {boolean} isDefault - `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     *\n     * @param {boolean} hasFinalizer - `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        // If both paths of the `try` block and the `catch` block are\n        // unreachable, the next path becomes unreachable as well.\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n        let j;\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(CodePathSegment.newNext(\n                this.idGenerator.next(),\n                prevSegsOfLeavingSegment));\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     *\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     *\n     * @param {string} type - The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label - A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n        let choiceContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                choiceContext = this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments);\n                break;\n\n            case \"DoWhileStatement\": {\n                choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments);\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments);\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     *\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     *\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head);\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments);\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head);\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     *\n     * @param {boolean} breakable - The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label - The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     *\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/code-path-segment.js":"/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Replaces unused segments with the previous segments of each unused segment.\n *\n * @param {CodePathSegment[]} segments - An array of segments to replace.\n * @returns {CodePathSegment[]} The replaced array.\n */\nfunction flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        // Ignores duplicated.\n        if (done[segment.id]) {\n            continue;\n        }\n\n        // Use previous segments if unused.\n        if (!segment.internal.used) {\n            for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                const prevSegment = segment.allPrevSegments[j];\n\n                if (!done[prevSegment.id]) {\n                    done[prevSegment.id] = true;\n                    retv.push(prevSegment);\n                }\n            }\n        } else {\n            done[segment.id] = true;\n            retv.push(segment);\n        }\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    /**\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable - A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n            this.internal.exitNodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     *\n     * @param {CodePathSegment} segment - A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     *\n     * @param {string} id - An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);\n\n        // In `if (a) return a; foo();` case, the unreachable segment preceded by\n        // the return statement is not used but must not be remove.\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     *\n     * @param {CodePathSegment} segment - A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     *\n     * @param {CodePathSegment} segment - A segment.\n     * @param {CodePathSegment} prevSegment - A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n}\n\nmodule.exports = CodePathSegment;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/debug-helpers.js":"/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     *\n     * @param {...any} args - objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     *\n     * @param {ASTNode} node - A node to dump.\n     * @param {CodePathState} state - A state to dump.\n     * @param {boolean} leaving - A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                segInternal.exitNodes.push(node);\n            } else {\n                segInternal.nodes.push(node);\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     *\n     * @param {CodePath} codePath - A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {\n                text += [].concat(\n                    segment.internal.nodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type} (${node.name})`;\n                            case \"Literal\": return `${node.type} (${node.value})`;\n                            default: return node.type;\n                        }\n                    }),\n                    segment.internal.exitNodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type}:exit (${node.name})`;\n                            case \"Literal\": return `${node.type}:exit (${node.value})`;\n                            default: return `${node.type}:exit`;\n                        }\n                    })\n                ).join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     *\n     * @param {CodePath} codePath - A code path to make DOT.\n     * @param {Object} traceMap - Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/fork-context.js":"/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n *\n * @param {ForkContext} context - An instance.\n * @param {number} begin - The first index of the previous segments.\n * @param {number} end - The last index of the previous segments.\n * @param {Function} create - A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    if (begin < 0) {\n        begin = list.length + begin;\n    }\n    if (end < 0) {\n        end = list.length + end;\n    }\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = begin; j <= end; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n *\n * @param {ForkContext} context - An instance.\n * @param {CodePathSegment[]} segments - Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    while (segments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = segments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [segments[i], segments[i + length]]\n            ));\n        }\n        segments = merged;\n    }\n    return segments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    /**\n     * @param {IdGenerator} idGenerator - An identifier generator for segments.\n     * @param {ForkContext|null} upper - An upper fork context.\n     * @param {number} count - A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     *\n     * @param {ForkContext} context - A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all secments in this context.\n     *\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     *\n     * @param {IdGenerator} idGenerator - An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     *\n     * @param {ForkContext} parentContext - The parent fork context.\n     * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count);\n    }\n}\n\nmodule.exports = ForkContext;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/code-path-analysis/id-generator.js":"/**\n * @fileoverview A class of identifiers generator for code path segments.\n *\n * Each rule uses the identifier of code path segments to store additional\n * information of the code path.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A generator for unique ids.\n */\nclass IdGenerator {\n\n    /**\n     * @param {string} prefix - Optional. A prefix of generated ids.\n     */\n    constructor(prefix) {\n        this.prefix = String(prefix);\n        this.n = 0;\n    }\n\n    /**\n     * Generates id.\n     *\n     * @returns {string} A generated id.\n     */\n    next() {\n        this.n = 1 + this.n | 0;\n\n        /* istanbul ignore if */\n        if (this.n < 0) {\n            this.n = 1;\n        }\n\n        return this.prefix + this.n;\n    }\n}\n\nmodule.exports = IdGenerator;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/ast-utils.js":"/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;\nconst arrayOrTypedArrayPattern = /Array$/;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;\nconst breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;\nconst thisTagPattern = /^[\\s*]*@this/m;\n\n\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\nconst LINEBREAK_MATCHER = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference - A reference to check.\n * @param {int} index - The index of the reference in the references.\n * @param {Reference[]} references - The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n *\n * @param {string} s - The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node - A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node - A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    while (node) {\n        if (anyFunctionPattern.test(node.type)) {\n            return node;\n        }\n        node = node.parent;\n    }\n    return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n *\n * @param {ASTNode|null} node - A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n *\n * @param {ASTNode|null} node - A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n    return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n    while (node && !isFunction(node)) {\n        if (isLoop(node)) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        module.exports.isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    while (node) {\n        if (node.type === \"Identifier\") {\n            return arrayMethodPattern.test(node.name);\n        }\n        if (node.type === \"MemberExpression\" && !node.computed) {\n            node = node.property;\n            continue;\n        }\n\n        break;\n    }\n\n    return false;\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f - The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n    return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node - A node to check.\n * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getComments(node).leading.some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n    return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n *\n * @param {ASTNode} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Creates a version of the LINEBREAK_MATCHER regex with the global flag.\n * Global regexes are mutable, so this needs to be a function instead of a constant.\n * @returns {RegExp} A global regular expression that matches line terminators\n */\nfunction createGlobalLinebreakMatcher() {\n    return new RegExp(LINEBREAK_MATCHER.source, \"g\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    COMMENTS_IGNORE_PATTERN,\n    LINEBREAKS,\n    LINEBREAK_MATCHER,\n    STATEMENT_LIST_PARENTS,\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop,\n    isArrayFromMethod,\n    isParenthesised,\n    createGlobalLinebreakMatcher,\n\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isKeywordToken,\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     *\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets the label if the parent node of a given node is a LabeledStatement.\n     *\n     * @param {ASTNode} node - A node to get.\n     * @returns {string|null} The label or `null`.\n     */\n    getLabel(node) {\n        if (node.parent.type === \"LabeledStatement\") {\n            return node.parent.label.name;\n        }\n        return null;\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references - An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {LineComment|BlockComment} node The node to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     *\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     *\n     * @param {escope.Scope} initScope - A scope to start find.\n     * @param {string} name - A variable name to find.\n     * @returns {escope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase (it's a constructor).\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     *\n     * @param {ASTNode} node - A function node to check.\n     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode) {\n        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n\n        while (node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    node = parent;\n                    break;\n\n                // If the upper function is IIFE, checks the destination of the return value.\n                // e.g.\n                //   obj.foo = (function() {\n                //     // setup...\n                //     return function foo() { ... };\n                //   })();\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    node = func.parent;\n                    break;\n                }\n\n                // e.g.\n                //   var obj = { foo() { ... } };\n                //   var obj = { foo: function() { ... } };\n                //   class A { constructor() { ... } }\n                //   class A { foo() { ... } }\n                //   class A { get foo() { ... } }\n                //   class A { set foo() { ... } }\n                //   class A { static foo() { ... } }\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.value !== node;\n\n                // e.g.\n                //   obj.foo = function foo() { ... };\n                //   Foo = function() { ... };\n                //   [obj.foo = function foo() { ... }] = a;\n                //   [Foo = function() { ... }] = a;\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.right === node) {\n                        if (parent.left.type === \"MemberExpression\") {\n                            return false;\n                        }\n                        if (isAnonymous &&\n                            parent.left.type === \"Identifier\" &&\n                            startsWithUpperCase(parent.left.name)\n                        ) {\n                            return false;\n                        }\n                    }\n                    return true;\n\n                // e.g.\n                //   var Foo = function() { ... };\n                case \"VariableDeclarator\":\n                    return !(\n                        isAnonymous &&\n                        parent.init === node &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                // e.g.\n                //   var foo = function foo() { ... }.bind(obj);\n                //   (function foo() { ... }).call(obj);\n                //   (function foo() { ... }).apply(obj, []);\n                case \"MemberExpression\":\n                    return (\n                        parent.object !== node ||\n                        parent.property.type !== \"Identifier\" ||\n                        !bindOrCallOrApplyPattern.test(parent.property.name) ||\n                        !isCallee(parent) ||\n                        parent.parent.arguments.length === 0 ||\n                        isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                // e.g.\n                //   Reflect.apply(function() {}, obj, []);\n                //   Array.from([], function() {}, obj);\n                //   list.forEach(function() {}, obj);\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== node ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    case \"**\":\n                        return 15;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 16;\n\n            case \"UpdateExpression\":\n                return 17;\n\n            case \"CallExpression\":\n\n                // IIFE is allowed to have parens in any position (#655)\n                if (node.callee.type === \"FunctionExpression\") {\n                    return -1;\n                }\n                return 18;\n\n            case \"NewExpression\":\n                return 19;\n\n            // no default\n        }\n        return 20;\n    },\n\n    /**\n     * Checks whether the given node is an empty block node or not.\n     *\n     * @param {ASTNode|null} node - The node to check.\n     * @returns {boolean} `true` if the node is an empty block.\n     */\n    isEmptyBlock(node) {\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    /**\n     * Checks whether the given node is an empty function node or not.\n     *\n     * @param {ASTNode|null} node - The node to check.\n     * @returns {boolean} `true` if the node is an empty function.\n     */\n    isEmptyFunction(node) {\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    /**\n     * Gets the property name of a given node.\n     * The node can be a MemberExpression, a Property, or a MethodDefinition.\n     *\n     * If the name is dynamic, this returns `null`.\n     *\n     * For examples:\n     *\n     *     a.b           // => \"b\"\n     *     a[\"b\"]        // => \"b\"\n     *     a['b']        // => \"b\"\n     *     a[`b`]        // => \"b\"\n     *     a[100]        // => \"100\"\n     *     a[b]          // => null\n     *     a[\"a\" + \"b\"]  // => null\n     *     a[tag`b`]     // => null\n     *     a[`${b}`]     // => null\n     *\n     *     let a = {b: 1}            // => \"b\"\n     *     let a = {[\"b\"]: 1}        // => \"b\"\n     *     let a = {['b']: 1}        // => \"b\"\n     *     let a = {[`b`]: 1}        // => \"b\"\n     *     let a = {[100]: 1}        // => \"100\"\n     *     let a = {[b]: 1}          // => null\n     *     let a = {[\"a\" + \"b\"]: 1}  // => null\n     *     let a = {[tag`b`]: 1}     // => null\n     *     let a = {[`${b}`]: 1}     // => null\n     *\n     * @param {ASTNode} node - The node to get.\n     * @returns {string|null} The property name if static. Otherwise, null.\n     */\n    getStaticPropertyName(node) {\n        let prop;\n\n        switch (node && node.type) {\n            case \"Property\":\n            case \"MethodDefinition\":\n                prop = node.key;\n                break;\n\n            case \"MemberExpression\":\n                prop = node.property;\n                break;\n\n            // no default\n        }\n\n        switch (prop && prop.type) {\n            case \"Literal\":\n                return String(prop.value);\n\n            case \"TemplateLiteral\":\n                if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n                    return prop.quasis[0].value.cooked;\n                }\n                break;\n\n            case \"Identifier\":\n                if (!node.computed) {\n                    return prop.name;\n                }\n                break;\n\n            // no default\n        }\n\n        return null;\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node - The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            // Do not check arrow functions with implicit return.\n            // `() => \"use strict\";` returns the string `\"use strict\"`.\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 5       // true\n     * 5.      // false\n     * 5.0     // false\n     * 05      // false\n     * 0x5     // false\n     * 0b101   // false\n     * 0o5     // false\n     * 5e0     // false\n     * '5'     // false\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" && /^(0|[1-9]\\d*)$/.test(node.raw);\n    },\n\n    /**\n     * Gets the name and kind of the given function node.\n     *\n     * - `function foo() {}`  .................... `function 'foo'`\n     * - `(function foo() {})`  .................. `function 'foo'`\n     * - `(function() {})`  ...................... `function`\n     * - `function* foo() {}`  ................... `generator function 'foo'`\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\n     * - `(function*() {})`  ..................... `generator function`\n     * - `() => {}`  ............................. `arrow function`\n     * - `async () => {}`  ....................... `async arrow function`\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n     * - `({ [foo]: function() {} })`  ........... `method`\n     * - `({ foo() {} })`  ....................... `method 'foo'`\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n     * - `({ [foo]: async function() {} })`  ..... `async method`\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n     * - `class A { constructor() {} }`  ......... `constructor`\n     * - `class A { foo() {} }`  ................. `method 'foo'`\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n     * - `class A { [foo]() {} }`  ............... `method`\n     * - `class A { *[foo]() {} }`  .............. `generator method`\n     * - `class A { async [foo]() {} }`  ......... `async method`\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n     *\n     * @param {ASTNode} node - The function node to get.\n     * @returns {string} The name and kind of the function node.\n     */\n    getFunctionNameWithKind(node) {\n        const parent = node.parent;\n        const tokens = [];\n\n        if (parent.type === \"MethodDefinition\" && parent.static) {\n            tokens.push(\"static\");\n        }\n        if (node.async) {\n            tokens.push(\"async\");\n        }\n        if (node.generator) {\n            tokens.push(\"generator\");\n        }\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            tokens.push(\"arrow\", \"function\");\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            if (parent.kind === \"constructor\") {\n                return \"constructor\";\n            } else if (parent.kind === \"get\") {\n                tokens.push(\"getter\");\n            } else if (parent.kind === \"set\") {\n                tokens.push(\"setter\");\n            } else {\n                tokens.push(\"method\");\n            }\n        } else {\n            tokens.push(\"function\");\n        }\n\n        if (node.id) {\n            tokens.push(`'${node.id.name}'`);\n        } else {\n            const name = module.exports.getStaticPropertyName(parent);\n\n            if (name) {\n                tokens.push(`'${name}'`);\n            }\n        }\n\n        return tokens.join(\" \");\n    },\n\n    /**\n     * Gets the location of the given function node for reporting.\n     *\n     * - `function foo() {}`\n     *    ^^^^^^^^^^^^\n     * - `(function foo() {})`\n     *     ^^^^^^^^^^^^\n     * - `(function() {})`\n     *     ^^^^^^^^\n     * - `function* foo() {}`\n     *    ^^^^^^^^^^^^^\n     * - `(function* foo() {})`\n     *     ^^^^^^^^^^^^^\n     * - `(function*() {})`\n     *     ^^^^^^^^^\n     * - `() => {}`\n     *       ^^\n     * - `async () => {}`\n     *             ^^\n     * - `({ foo: function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ foo: function() {} })`\n     *       ^^^^^^^^^^^^^\n     * - `({ ['foo']: function() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function() {} })`\n     *       ^^^^^^^^^^^^^^^\n     * - `({ foo() {} })`\n     *       ^^^\n     * - `({ foo: function* foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ foo: function*() {} })`\n     *       ^^^^^^^^^^^^^^\n     * - `({ ['foo']: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^\n     * - `({ *foo() {} })`\n     *       ^^^^\n     * - `({ foo: async function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ foo: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^\n     * - `({ ['foo']: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^\n     * - `({ async foo() {} })`\n     *       ^^^^^^^^^\n     * - `({ get foo() {} })`\n     *       ^^^^^^^\n     * - `({ set foo(a) {} })`\n     *       ^^^^^^^\n     * - `class A { constructor() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { foo() {} }`\n     *              ^^^\n     * - `class A { *foo() {} }`\n     *              ^^^^\n     * - `class A { async foo() {} }`\n     *              ^^^^^^^^^\n     * - `class A { ['foo']() {} }`\n     *              ^^^^^^^\n     * - `class A { *['foo']() {} }`\n     *              ^^^^^^^^\n     * - `class A { async ['foo']() {} }`\n     *              ^^^^^^^^^^^^^\n     * - `class A { [foo]() {} }`\n     *              ^^^^^\n     * - `class A { *[foo]() {} }`\n     *              ^^^^^^\n     * - `class A { async [foo]() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { get foo() {} }`\n     *              ^^^^^^^\n     * - `class A { set foo(a) {} }`\n     *              ^^^^^^^\n     * - `class A { static foo() {} }`\n     *              ^^^^^^^^^^\n     * - `class A { static *foo() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { static async foo() {} }`\n     *              ^^^^^^^^^^^^^^^^\n     * - `class A { static get foo() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static set foo(a) {} }`\n     *              ^^^^^^^^^^^^^^\n     *\n     * @param {ASTNode} node - The function node to get.\n     * @param {SourceCode} sourceCode - The source code object to get tokens.\n     * @returns {string} The location of the function node for reporting.\n     */\n    getFunctionHeadLoc(node, sourceCode) {\n        const parent = node.parent;\n        let start = null;\n        let end = null;\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n            start = arrowToken.loc.start;\n            end = arrowToken.loc.end;\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            start = parent.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        } else {\n            start = node.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        }\n\n        return {\n            start: Object.assign({}, start),\n            end: Object.assign({}, end)\n        };\n    },\n\n    /**\n    * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n    * surrounding the node.\n    * @param {SourceCode} sourceCode The source code object\n    * @param {ASTNode} node An expression node\n    * @returns {string} The text representing the node, with all surrounding parentheses included\n    */\n    getParenthesisedText(sourceCode, node) {\n        let leftToken = sourceCode.getFirstToken(node);\n        let rightToken = sourceCode.getLastToken(node);\n\n        while (\n            sourceCode.getTokenBefore(leftToken) &&\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\n            sourceCode.getTokenAfter(rightToken) &&\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\n            sourceCode.getTokenAfter(rightToken).value === \")\"\n        ) {\n            leftToken = sourceCode.getTokenBefore(leftToken);\n            rightToken = sourceCode.getTokenAfter(rightToken);\n        }\n\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    /*\n     * Determine if a node has a possiblity to be an Error object\n     * @param  {ASTNode} node  ASTNode to check\n     * @returns {boolean} True if there is a chance it contains an Error obj\n     */\n    couldBeError(node) {\n        switch (node.type) {\n            case \"Identifier\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"YieldExpression\":\n            case \"AwaitExpression\":\n                return true; // possibly an error object.\n\n            case \"AssignmentExpression\":\n                return module.exports.couldBeError(node.right);\n\n            case \"SequenceExpression\": {\n                const exprs = node.expressions;\n\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n            }\n\n            case \"LogicalExpression\":\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n            case \"ConditionalExpression\":\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n            default:\n                return false;\n        }\n    },\n\n    /**\n     * Determines whether the given node is a `null` literal.\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a `null` literal\n     */\n    isNullLiteral(node) {\n\n        /*\n         * Checking `node.value === null` does not guarantee that a literal is a null literal.\n         * When parsing values that cannot be represented in the current environment (e.g. unicode\n         * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n         * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n         * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n         */\n        return node.type === \"Literal\" && node.value === null && !node.regex;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/config-ops.js":"/**\n * @fileoverview Config file operations. This file must be usable in the browser,\n * so no Node-specific code can be here.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Environments = require(\"./environments\");\n\nconst debug = require(\"debug\")(\"eslint:config-ops\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst RULE_SEVERITY_STRINGS = [\"off\", \"warn\", \"error\"],\n    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {\n        map[value] = index;\n        return map;\n    }, {}),\n    VALID_SEVERITIES = [0, 1, 2, \"off\", \"warn\", \"error\"];\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * Creates an empty configuration object suitable for merging as a base.\n     * @returns {Object} A configuration object.\n     */\n    createEmptyConfig() {\n        return {\n            globals: {},\n            env: {},\n            rules: {},\n            parserOptions: {}\n        };\n    },\n\n    /**\n     * Creates an environment config based on the specified environments.\n     * @param {Object<string,boolean>} env The environment settings.\n     * @returns {Object} A configuration object with the appropriate rules and globals\n     *      set.\n     */\n    createEnvironmentConfig(env) {\n\n        const envConfig = this.createEmptyConfig();\n\n        if (env) {\n\n            envConfig.env = env;\n\n            Object.keys(env).filter(name => env[name]).forEach(name => {\n                const environment = Environments.get(name);\n\n                if (environment) {\n                    debug(`Creating config for environment ${name}`);\n                    if (environment.globals) {\n                        Object.assign(envConfig.globals, environment.globals);\n                    }\n\n                    if (environment.parserOptions) {\n                        Object.assign(envConfig.parserOptions, environment.parserOptions);\n                    }\n                }\n            });\n        }\n\n        return envConfig;\n    },\n\n    /**\n     * Given a config with environment settings, applies the globals and\n     * ecmaFeatures to the configuration and returns the result.\n     * @param {Object} config The configuration information.\n     * @returns {Object} The updated configuration information.\n     */\n    applyEnvironments(config) {\n        if (config.env && typeof config.env === \"object\") {\n            debug(\"Apply environment settings to config\");\n            return this.merge(this.createEnvironmentConfig(config.env), config);\n        }\n\n        return config;\n    },\n\n    /**\n     * Merges two config objects. This will not only add missing keys, but will also modify values to match.\n     * @param {Object} target config object\n     * @param {Object} src config object. Overrides in this config object will take priority over base.\n     * @param {boolean} [combine] Whether to combine arrays or not\n     * @param {boolean} [isRule] Whether its a rule\n     * @returns {Object} merged config object.\n     */\n    merge: function deepmerge(target, src, combine, isRule) {\n\n        /*\n         The MIT License (MIT)\n\n         Copyright (c) 2012 Nicholas Fisher\n\n         Permission is hereby granted, free of charge, to any person obtaining a copy\n         of this software and associated documentation files (the \"Software\"), to deal\n         in the Software without restriction, including without limitation the rights\n         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         copies of the Software, and to permit persons to whom the Software is\n         furnished to do so, subject to the following conditions:\n\n         The above copyright notice and this permission notice shall be included in\n         all copies or substantial portions of the Software.\n\n         THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n         THE SOFTWARE.\n         */\n\n        /*\n         * This code is taken from deepmerge repo\n         * (https://github.com/KyleAMathews/deepmerge)\n         * and modified to meet our needs.\n         */\n        const array = Array.isArray(src) || Array.isArray(target);\n        let dst = array && [] || {};\n\n        combine = !!combine;\n        isRule = !!isRule;\n        if (array) {\n            target = target || [];\n\n            // src could be a string, so check for array\n            if (isRule && Array.isArray(src) && src.length > 1) {\n                dst = dst.concat(src);\n            } else {\n                dst = dst.concat(target);\n            }\n            if (typeof src !== \"object\" && !Array.isArray(src)) {\n                src = [src];\n            }\n            Object.keys(src).forEach((e, i) => {\n                e = src[i];\n                if (typeof dst[i] === \"undefined\") {\n                    dst[i] = e;\n                } else if (typeof e === \"object\") {\n                    if (isRule) {\n                        dst[i] = e;\n                    } else {\n                        dst[i] = deepmerge(target[i], e, combine, isRule);\n                    }\n                } else {\n                    if (!combine) {\n                        dst[i] = e;\n                    } else {\n                        if (dst.indexOf(e) === -1) {\n                            dst.push(e);\n                        }\n                    }\n                }\n            });\n        } else {\n            if (target && typeof target === \"object\") {\n                Object.keys(target).forEach(key => {\n                    dst[key] = target[key];\n                });\n            }\n            Object.keys(src).forEach(key => {\n                if (Array.isArray(src[key]) || Array.isArray(target[key])) {\n                    dst[key] = deepmerge(target[key], src[key], key === \"plugins\", isRule);\n                } else if (typeof src[key] !== \"object\" || !src[key] || key === \"exported\" || key === \"astGlobals\") {\n                    dst[key] = src[key];\n                } else {\n                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === \"rules\");\n                }\n            });\n        }\n\n        return dst;\n    },\n\n    /**\n     * Converts new-style severity settings (off, warn, error) into old-style\n     * severity settings (0, 1, 2) for all rules. Assumption is that severity\n     * values have already been validated as correct.\n     * @param {Object} config The config object to normalize.\n     * @returns {void}\n     */\n    normalize(config) {\n\n        if (config.rules) {\n            Object.keys(config.rules).forEach(ruleId => {\n                const ruleConfig = config.rules[ruleId];\n\n                if (typeof ruleConfig === \"string\") {\n                    config.rules[ruleId] = RULE_SEVERITY[ruleConfig.toLowerCase()] || 0;\n                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"string\") {\n                    ruleConfig[0] = RULE_SEVERITY[ruleConfig[0].toLowerCase()] || 0;\n                }\n            });\n        }\n    },\n\n    /**\n     * Converts old-style severity settings (0, 1, 2) into new-style\n     * severity settings (off, warn, error) for all rules. Assumption is that severity\n     * values have already been validated as correct.\n     * @param {Object} config The config object to normalize.\n     * @returns {void}\n     */\n    normalizeToStrings(config) {\n\n        if (config.rules) {\n            Object.keys(config.rules).forEach(ruleId => {\n                const ruleConfig = config.rules[ruleId];\n\n                if (typeof ruleConfig === \"number\") {\n                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];\n                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"number\") {\n                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];\n                }\n            });\n        }\n    },\n\n    /**\n     * Determines if the severity for the given rule configuration represents an error.\n     * @param {int|string|Array} ruleConfig The configuration for an individual rule.\n     * @returns {boolean} True if the rule represents an error, false if not.\n     */\n    isErrorSeverity(ruleConfig) {\n\n        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (typeof severity === \"string\") {\n            severity = RULE_SEVERITY[severity.toLowerCase()] || 0;\n        }\n\n        return (typeof severity === \"number\" && severity === 2);\n    },\n\n    /**\n     * Checks whether a given config has valid severity or not.\n     * @param {number|string|Array} ruleConfig - The configuration for an individual rule.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isValidSeverity(ruleConfig) {\n        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (typeof severity === \"string\") {\n            severity = severity.toLowerCase();\n        }\n        return VALID_SEVERITIES.indexOf(severity) !== -1;\n    },\n\n    /**\n     * Checks whether every rule of a given config has valid severity or not.\n     * @param {Object} config - The configuration for rules.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isEverySeverityValid(config) {\n        return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/environments.js":"/**\n * @fileoverview Environments manager\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst envs = require(\"../../conf/environments\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nlet environments = new Map();\n\n/**\n * Loads the default environments.\n * @returns {void}\n * @private\n */\nfunction load() {\n    Object.keys(envs).forEach(envName => {\n        environments.set(envName, envs[envName]);\n    });\n}\n\n// always load default environments upfront\nload();\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    load,\n\n    /**\n     * Gets the environment with the given name.\n     * @param {string} name The name of the environment to retrieve.\n     * @returns {Object?} The environment object or null if not found.\n     */\n    get(name) {\n        return environments.get(name) || null;\n    },\n\n    /**\n     * Defines an environment.\n     * @param {string} name The name of the environment.\n     * @param {Object} env The environment settings.\n     * @returns {void}\n     */\n    define(name, env) {\n        environments.set(name, env);\n    },\n\n    /**\n     * Imports all environments from a plugin.\n     * @param {Object} plugin The plugin object.\n     * @param {string} pluginName The name of the plugin.\n     * @returns {void}\n     */\n    importPlugin(plugin, pluginName) {\n        if (plugin.environments) {\n            Object.keys(plugin.environments).forEach(envName => {\n                this.define(`${pluginName}/${envName}`, plugin.environments[envName]);\n            });\n        }\n    },\n\n    /**\n     * Resets all environments. Only use for tests!\n     * @returns {void}\n     */\n    testReset() {\n        environments = new Map();\n        load();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/conf/environments.js":"/**\n * @fileoverview Defines environment settings and globals.\n * @author Elan Shanker\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    builtin: globals.es5,\n    browser: {\n        globals: globals.browser\n    },\n    node: {\n        globals: globals.node,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    commonjs: {\n        globals: globals.commonjs,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    \"shared-node-browser\": {\n        globals: globals[\"shared-node-browser\"]\n    },\n    worker: {\n        globals: globals.worker\n    },\n    amd: {\n        globals: globals.amd\n    },\n    mocha: {\n        globals: globals.mocha\n    },\n    jasmine: {\n        globals: globals.jasmine\n    },\n    jest: {\n        globals: globals.jest\n    },\n    phantomjs: {\n        globals: globals.phantomjs\n    },\n    jquery: {\n        globals: globals.jquery\n    },\n    qunit: {\n        globals: globals.qunit\n    },\n    prototypejs: {\n        globals: globals.prototypejs\n    },\n    shelljs: {\n        globals: globals.shelljs\n    },\n    meteor: {\n        globals: globals.meteor\n    },\n    mongo: {\n        globals: globals.mongo\n    },\n    protractor: {\n        globals: globals.protractor\n    },\n    applescript: {\n        globals: globals.applescript\n    },\n    nashorn: {\n        globals: globals.nashorn\n    },\n    serviceworker: {\n        globals: globals.serviceworker\n    },\n    atomtest: {\n        globals: globals.atomtest\n    },\n    embertest: {\n        globals: globals.embertest\n    },\n    webextensions: {\n        globals: globals.webextensions\n    },\n    es6: {\n        globals: globals.es6,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    greasemonkey: {\n        globals: globals.greasemonkey\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/config-validator.js":"/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst rules = require(\"../rules\"),\n    Environments = require(\"./environments\"),\n    schemaValidator = require(\"is-my-json-valid\"),\n    util = require(\"util\");\n\nconst validators = {\n    rules: Object.create(null)\n};\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Gets a complete options schema for a rule.\n * @param {string} id The rule's unique name.\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(id) {\n    const rule = rules.get(id),\n        schema = rule && rule.schema || rule && rule.meta && rule.meta.schema;\n\n    // Given a tuple of schemas, insert warning level at the beginning\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n        return {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 0\n        };\n\n    }\n\n    // Given a full schema, leave it alone\n    return schema || null;\n}\n\n/**\n* Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n* @param {options} options The given options for the rule.\n* @returns {number|string} The rule's severity value\n*/\nfunction validateRuleSeverity(options) {\n    const severity = Array.isArray(options) ? options[0] : options;\n\n    if (severity !== 0 && severity !== 1 && severity !== 2 && !(typeof severity === \"string\" && /^(?:off|warn|error)$/i.test(severity))) {\n        throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/g, \"\\\"\").replace(/\\n/g, \"\")}').\\n`);\n    }\n\n    return severity;\n}\n\n/**\n* Validates the non-severity options passed to a rule, based on its schema.\n* @param {string} id The rule's unique name\n* @param {array} localOptions The options for the rule, excluding severity\n* @returns {void}\n*/\nfunction validateRuleSchema(id, localOptions) {\n    const schema = getRuleOptionsSchema(id);\n\n    if (!validators.rules[id] && schema) {\n        validators.rules[id] = schemaValidator(schema, { verbose: true });\n    }\n\n    const validateRule = validators.rules[id];\n\n    if (validateRule) {\n        validateRule(localOptions);\n        if (validateRule.errors) {\n            throw new Error(validateRule.errors.map(error => `\\tValue \"${error.value}\" ${error.message}.\\n`).join(\"\"));\n        }\n    }\n}\n\n/**\n * Validates a rule's options against its schema.\n * @param {string} id The rule's unique name.\n * @param {array|number} options The given options for the rule.\n * @param {string} source The name of the configuration source.\n * @returns {void}\n */\nfunction validateRuleOptions(id, options, source) {\n    try {\n        const severity = validateRuleSeverity(options);\n\n        if (severity !== 0 && !(typeof severity === \"string\" && severity.toLowerCase() === \"off\")) {\n            validateRuleSchema(id, Array.isArray(options) ? options.slice(1) : []);\n        }\n    } catch (err) {\n        throw new Error(`${source}:\\n\\tConfiguration for rule \"${id}\" is invalid:\\n${err.message}`);\n    }\n}\n\n/**\n * Validates an environment object\n * @param {Object} environment The environment config object to validate.\n * @param {string} source The location to report with any errors.\n * @returns {void}\n */\nfunction validateEnvironment(environment, source) {\n\n    // not having an environment is ok\n    if (!environment) {\n        return;\n    }\n\n    if (Array.isArray(environment)) {\n        throw new Error(\"Environment must not be an array\");\n    }\n\n    if (typeof environment === \"object\") {\n        Object.keys(environment).forEach(env => {\n            if (!Environments.get(env)) {\n                const message = [\n                    source, \":\\n\",\n                    \"\\tEnvironment key \\\"\", env, \"\\\" is unknown\\n\"\n                ];\n\n                throw new Error(message.join(\"\"));\n            }\n        });\n    } else {\n        throw new Error(\"Environment must be an object\");\n    }\n}\n\n/**\n * Validates an entire config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The location to report with any errors.\n * @returns {void}\n */\nfunction validate(config, source) {\n\n    if (typeof config.rules === \"object\") {\n        Object.keys(config.rules).forEach(id => {\n            validateRuleOptions(id, config.rules[id], source);\n        });\n    }\n\n    validateEnvironment(config.env, source);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    getRuleOptionsSchema,\n    validate,\n    validateRuleOptions\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules.js":"/**\n * @fileoverview Defines a storage for rules.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst loadRules = require(\"./load-rules\");\n\n//------------------------------------------------------------------------------\n// Privates\n//------------------------------------------------------------------------------\n\nlet rules = Object.create(null);\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Registers a rule module for rule id in storage.\n * @param {string} ruleId Rule id (file name).\n * @param {Function} ruleModule Rule handler.\n * @returns {void}\n */\nfunction define(ruleId, ruleModule) {\n    rules[ruleId] = ruleModule;\n}\n\n/**\n * Loads and registers all rules from passed rules directory.\n * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.\n * @param {string} cwd Current working directory\n * @returns {void}\n */\nfunction load(rulesDir, cwd) {\n    const newRules = loadRules(rulesDir, cwd);\n\n    Object.keys(newRules).forEach(ruleId => {\n        define(ruleId, newRules[ruleId]);\n    });\n}\n\n/**\n * Registers all given rules of a plugin.\n * @param {Object} plugin The plugin object to import.\n * @param {string} pluginName The name of the plugin without prefix (`eslint-plugin-`).\n * @returns {void}\n */\nfunction importPlugin(plugin, pluginName) {\n    if (plugin.rules) {\n        Object.keys(plugin.rules).forEach(ruleId => {\n            const qualifiedRuleId = `${pluginName}/${ruleId}`,\n                rule = plugin.rules[ruleId];\n\n            define(qualifiedRuleId, rule);\n        });\n    }\n}\n\n/**\n * Access rule handler by id (file name).\n * @param {string} ruleId Rule id (file name).\n * @returns {Function} Rule handler.\n */\nfunction getHandler(ruleId) {\n    if (typeof rules[ruleId] === \"string\") {\n        return require(rules[ruleId]);\n    }\n    return rules[ruleId];\n\n}\n\n/**\n * Get an object with all currently loaded rules\n * @returns {Map} All loaded rules\n */\nfunction getAllLoadedRules() {\n    const allRules = new Map();\n\n    Object.keys(rules).forEach(name => {\n        const rule = getHandler(name);\n\n        allRules.set(name, rule);\n    });\n    return allRules;\n}\n\n/**\n * Reset rules storage.\n * Should be used only in tests.\n * @returns {void}\n */\nfunction testClear() {\n    rules = Object.create(null);\n}\n\nmodule.exports = {\n    define,\n    load,\n    importPlugin,\n    get: getHandler,\n    getAllLoadedRules,\n    testClear,\n\n    /**\n     * Resets rules to its starting state. Use for tests only.\n     * @returns {void}\n     */\n    testReset() {\n        testClear();\n        load();\n    }\n};\n\n//------------------------------------------------------------------------------\n// Initialization\n//------------------------------------------------------------------------------\n\n// loads built-in rules\nload();\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/load-rules.js":"/**\n * @fileoverview Module for loading rules from files and directories.\n * @author Michael Ficarra\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Load all rule modules from specified directory.\n * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.\n * @param {string} cwd Current working directory\n * @returns {Object} Loaded rule modules by rule ids (file names).\n */\nmodule.exports = function(rulesDir, cwd) {\n    if (!rulesDir) {\n        rulesDir = path.join(__dirname, \"rules\");\n    } else {\n        rulesDir = path.resolve(cwd, rulesDir);\n    }\n\n    const rules = Object.create(null);\n\n    fs.readdirSync(rulesDir).forEach(file => {\n        if (path.extname(file) !== \".js\") {\n            return;\n        }\n        rules[file.slice(0, -3)] = path.join(rulesDir, file);\n    });\n    return rules;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/comment-event-generator.js":"/**\n * @fileoverview The event generator for comments.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check collection of comments to prevent double event for comment as\n * leading and trailing, then emit event if passing\n * @param {ASTNode[]} comments - Collection of comment nodes\n * @param {EventEmitter} emitter - The event emitter which is the destination of events.\n * @param {Object[]} locs - List of locations of previous comment nodes\n * @param {string} eventName - Event name postfix\n * @returns {void}\n */\nfunction emitComments(comments, emitter, locs, eventName) {\n    if (comments.length > 0) {\n        comments.forEach(node => {\n            const index = locs.indexOf(node.loc);\n\n            if (index >= 0) {\n                locs.splice(index, 1);\n            } else {\n                locs.push(node.loc);\n                emitter.emit(node.type + eventName, node);\n            }\n        });\n    }\n}\n\n/**\n * Shortcut to check and emit enter of comment nodes\n * @param {CommentEventGenerator} generator - A generator to emit.\n * @param {ASTNode[]} comments - Collection of comment nodes\n * @returns {void}\n */\nfunction emitCommentsEnter(generator, comments) {\n    emitComments(\n        comments,\n        generator.emitter,\n        generator.commentLocsEnter,\n        \"Comment\");\n}\n\n/**\n * Shortcut to check and emit exit of comment nodes\n * @param {CommentEventGenerator} generator - A generator to emit.\n * @param {ASTNode[]} comments Collection of comment nodes\n * @returns {void}\n */\nfunction emitCommentsExit(generator, comments) {\n    emitComments(\n        comments,\n        generator.emitter,\n        generator.commentLocsExit,\n        \"Comment:exit\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for comments.\n * This is the decorator pattern.\n * This generates events of comments before/after events which are generated the original generator.\n *\n * Comment event generator class\n */\nclass CommentEventGenerator {\n\n    /**\n     * @param {EventGenerator} originalEventGenerator - An event generator which is the decoration target.\n     * @param {SourceCode} sourceCode - A source code which has comments.\n     */\n    constructor(originalEventGenerator, sourceCode) {\n        this.original = originalEventGenerator;\n        this.emitter = originalEventGenerator.emitter;\n        this.sourceCode = sourceCode;\n        this.commentLocsEnter = [];\n        this.commentLocsExit = [];\n    }\n\n    /**\n     * Emits an event of entering comments.\n     * @param {ASTNode} node - A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        const comments = this.sourceCode.getComments(node);\n\n        emitCommentsEnter(this, comments.leading);\n        this.original.enterNode(node);\n        emitCommentsEnter(this, comments.trailing);\n    }\n\n    /**\n     * Emits an event of leaving comments.\n     * @param {ASTNode} node - A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        const comments = this.sourceCode.getComments(node);\n\n        emitCommentsExit(this, comments.trailing);\n        this.original.leaveNode(node);\n        emitCommentsExit(this, comments.leading);\n    }\n}\n\nmodule.exports = CommentEventGenerator;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/node-event-generator.js":"/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n* Gets the possible types of a selector\n* @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n* @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n*/\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(typesForComponent => typesForComponent)) {\n                return lodash.union.apply(null, typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return lodash.intersection.apply(null, typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/, \"\"));\n    } catch (err) {\n        if (typeof err.offset === \"number\") {\n            throw new Error(`Syntax error in selector \"${rawSelector}\" at position ${err.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nconst parseSelector = lodash.memoize(rawSelector => {\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    return {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n});\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: EventEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    /**\n    * @param {EventEmitter} emitter - An event emitter which is the destination of events. This emitter must already\n    * have registered listeners for all of the events that it needs to listen for.\n    * @returns {NodeEventGenerator} new instance\n    */\n    constructor(emitter) {\n        this.emitter = emitter;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        const eventNames = typeof emitter.eventNames === \"function\"\n\n            // Use the built-in eventNames() function if available (Node 6+)\n            ? emitter.eventNames()\n\n            /*\n             * Otherwise, use the private _events property.\n             * Using a private property isn't ideal here, but this seems to\n             * be the best way to get a list of event names without overriding\n             * addEventListener, which would hurt performance. This property\n             * is widely used and unlikely to be removed in a future version\n             * (see https://github.com/nodejs/node/issues/1817). Also, future\n             * node versions will have eventNames() anyway.\n             */\n            : Object.keys(emitter._events); // eslint-disable-line no-underscore-dangle\n\n        eventNames.forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                selector.listenerTypes.forEach(nodeType => {\n                    const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n            } else {\n                (selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(selector);\n            }\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node - A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node - A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/source-code.js":"/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst TokenStore = require(\"../token-store\"),\n    Traverser = require(\"./traverser\"),\n    astUtils = require(\"../ast-utils\"),\n    lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Finds a JSDoc comment node in an array of comment nodes.\n * @param {ASTNode[]} comments The array of comment nodes to search.\n * @param {int} line Line number to look around\n * @returns {ASTNode} The node if found, null if not.\n * @private\n */\nfunction findJSDocComment(comments, line) {\n\n    if (comments) {\n        for (let i = comments.length - 1; i >= 0; i--) {\n            if (comments[i].type === \"Block\" && comments[i].value.charAt(0) === \"*\") {\n\n                if (line - comments[i].loc.end.line <= 1) {\n                    return comments[i];\n                }\n                break;\n\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * Check to see if its a ES6 export declaration\n * @param {ASTNode} astNode - any node\n * @returns {boolean} whether the given node represents a export declaration\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time\n * @param {Token[]} tokens The list of tokens\n * @param {Token[]} comments The list of comments\n * @returns {Token[]} A sorted list of tokens and comments\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Represents parsed source code.\n * @param {string} text - The source code text.\n * @param {ASTNode} ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n * @constructor\n */\nfunction SourceCode(text, ast) {\n    validate(ast);\n\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type boolean\n     */\n    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type string\n     */\n    this.text = (this.hasBOM ? text.slice(1) : text);\n\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n    this.ast = ast;\n\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n    this.lines = [];\n    this.lineStartIndices = [0];\n\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n\n    /*\n     * Previously, this was implemented using a regex that\n     * matched a sequence of non-linebreak characters followed by a\n     * linebreak, then adding the lengths of the matches. However,\n     * this caused a catastrophic backtracking issue when the end\n     * of a file contained a large number of non-newline characters.\n     * To avoid this, the current implementation just matches newlines\n     * and uses match.index to get the correct line start indices.\n     */\n    while ((match = lineEndingPattern.exec(this.text))) {\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n        this.lineStartIndices.push(match.index + match[0].length);\n    }\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n    // create token store methods\n    const tokenStore = new TokenStore(ast.tokens, ast.comments);\n\n    for (const methodName of TokenStore.PUBLIC_METHODS) {\n        this[methodName] = tokenStore[methodName].bind(tokenStore);\n    }\n\n    // don't allow modification of this object\n    Object.freeze(this);\n    Object.freeze(this.lines);\n}\n\n/**\n * Split the source code into multiple lines based on the line delimiters\n * @param {string} text Source code as a string\n * @returns {string[]} Array of source code lines\n * @public\n */\nSourceCode.splitLines = function(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n};\n\nSourceCode.prototype = {\n    constructor: SourceCode,\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n\n\n    },\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     */\n    getLines() {\n        return this.lines;\n    },\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     */\n    getAllComments() {\n        return this.ast.comments;\n    },\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} The list of comments indexed by their position.\n     * @public\n     */\n    getComments(node) {\n\n        let leadingComments = node.leadingComments || [];\n        const trailingComments = node.trailingComments || [];\n\n        /*\n         * espree adds a \"comments\" array on Program nodes rather than\n         * leadingComments/trailingComments. Comments are only left in the\n         * Program node comments array if there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                leadingComments = node.comments;\n            }\n        }\n\n        return {\n            leading: leadingComments,\n            trailing: trailingComments\n        };\n    },\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {ASTNode} The BlockComment node containing the JSDoc for the\n     *      given node or null if not found.\n     * @public\n     */\n    getJSDocComment(node) {\n\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                if (looksLikeExport(parent)) {\n                    return findJSDocComment(parent.leadingComments, parent.loc.start.line);\n                }\n                return findJSDocComment(node.leadingComments, node.loc.start.line);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (parent && !parent.leadingComments && !/Function/.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n                        parent = parent.parent;\n                    }\n\n                    return parent && (parent.type !== \"FunctionDeclaration\") ? findJSDocComment(parent.leadingComments, parent.loc.start.line) : null;\n                } else if (node.leadingComments) {\n                    return findJSDocComment(node.leadingComments, node.loc.start.line);\n                }\n\n            // falls through\n\n            default:\n                return null;\n        }\n    },\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     */\n    getNodeByRangeIndex(index) {\n        let result = null,\n            resultParent = null;\n        const traverser = new Traverser();\n\n        traverser.traverse(this.ast, {\n            enter(node, parent) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                    resultParent = parent;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result ? Object.assign({ parent: resultParent }, result) : null;\n    },\n\n    /**\n     * Determines if two tokens have at least one whitespace character\n     * between them. This completely disregards comments in making the\n     * determination, so comments count as zero-length substrings.\n     * @param {Token} first The token to check after.\n     * @param {Token} second The token to check before.\n     * @returns {boolean} True if there is only space between tokens, false\n     *  if there is anything other than whitespace between tokens.\n     */\n    isSpaceBetweenTokens(first, second) {\n        const text = this.text.slice(first.range[1], second.range[0]);\n\n        return /\\s/.test(text.replace(/\\/\\*.*?\\*\\//g, \"\"));\n    },\n\n    /**\n    * Converts a source text index into a (line, column) pair.\n    * @param {number} index The index of a character in a file\n    * @returns {Object} A {line, column} location object with a 0-indexed column\n    */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n         * be inserted into lineIndices to keep the list sorted.\n         */\n        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n\n    },\n\n    /**\n    * Converts a (line, column) pair into a range index.\n    * @param {Object} loc A line/column location\n    * @param {number} loc.line The line number of the location (1-indexed)\n    * @param {number} loc.column The column number of the location (0-indexed)\n    * @returns {number} The range index of the location in the file.\n    */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n};\n\n\nmodule.exports = SourceCode;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/index.js":"/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PUBLIC_METHODS = Object.freeze([\n    \"getTokenByRangeStart\",\n\n    \"getFirstToken\",\n    \"getLastToken\",\n    \"getTokenBefore\",\n    \"getTokenAfter\",\n    \"getFirstTokenBetween\",\n    \"getLastTokenBetween\",\n\n    \"getFirstTokens\",\n    \"getLastTokens\",\n    \"getTokensBefore\",\n    \"getTokensAfter\",\n    \"getFirstTokensBetween\",\n    \"getLastTokensBetween\",\n\n    \"getTokens\",\n    \"getTokensBetween\",\n\n    \"getTokenOrCommentBefore\",\n    \"getTokenOrCommentAfter\"\n]);\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart = 0;\n    let range = null;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {CursorFactory} factory - The cursor factory to initialize cursor.\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.skip=0] - The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {CursorFactory} factory - The cursor factory to initialize cursor.\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {Function|Object} opts - The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number} [beforeCount=0] - The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] - The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     *\n     * ※ `comments` needs to be cloned for backward compatibility.\n     * After this initialization, ESLint removes a shebang's comment from `comments`.\n     * However, so far we had been concatenating 'tokens' and 'comments' before,\n     * so the shebang's comment had remained in the concatenated array.\n     * As a result, both the result of `getTokenOrCommentAfter` and `getTokenOrCommentBefore`\n     * methods had included the shebang's comment.\n     * And some rules depends on this behavior.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     */\n    constructor(tokens, comments) {\n        this.tokens = tokens;\n        this.comments = comments.slice(0);\n        this.indexMap = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset - Index of the start of the token's range.\n     * @param {Object} [options=0] - The option object.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left - Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right - Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} Tokens between left and right.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left - Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right - Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {int} [beforeCount=0] - The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] - The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n};\n\nmodule.exports.PUBLIC_METHODS = PUBLIC_METHODS;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/cursors.js":"/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n\n    /**\n     * Initializes this cursor.\n     * @param {Function} TokenCursor - The class of the cursor which iterates tokens only.\n     * @param {Function} TokenCommentCursor - The class of the cursor which iterates the mix of tokens and comments.\n     */\n    constructor(TokenCursor, TokenCommentCursor) {\n        this.TokenCursor = TokenCursor;\n        this.TokenCommentCursor = TokenCommentCursor;\n    }\n\n    /**\n     * Creates a base cursor instance that can be decorated by createCursor.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {boolean} includeComments - The flag to iterate comments as well.\n     * @returns {Cursor} The created base cursor.\n     */\n    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n\n        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n\n    /**\n     * Creates a cursor that iterates tokens with normalized options.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {boolean} includeComments - The flag to iterate comments as well.\n     * @param {Function|null} filter - The predicate function to choose tokens.\n     * @param {number} skip - The count of tokens the cursor skips.\n     * @param {number} count - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n     * @returns {Cursor} The created cursor.\n     */\n    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n        if (filter) {\n            cursor = new FilterCursor(cursor, filter);\n        }\n        if (skip >= 1) {\n            cursor = new SkipCursor(cursor, skip);\n        }\n        if (count >= 0) {\n            cursor = new LimitCursor(cursor, count);\n        }\n\n        return cursor;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/backward-token-comment-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens and comments in reverse.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments in reverse.\n */\nmodule.exports = class BackwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.commentIndex = utils.search(comments, endLoc) - 1;\n        this.border = startLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex >= 0) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex >= 0) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[1] > comment.range[1])) {\n            this.current = token;\n            this.tokenIndex -= 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex -= 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/cursor.js":"/**\n * @fileoverview Define the abstract class about cursors which iterate tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which iterate tokens.\n *\n * This class has 2 abstract methods.\n *\n * - `current: Token | Comment | null` ... The current token.\n * - `moveNext(): boolean` ... Moves this cursor to the next token. If the next token didn't exist, it returns `false`.\n *\n * This is similar to ES2015 Iterators.\n * However, Iterators were slow (at 2017-01), so I created this class as similar to C# IEnumerable.\n *\n * There are the following known sub classes.\n *\n * - ForwardTokenCursor .......... The cursor which iterates tokens only.\n * - BackwardTokenCursor ......... The cursor which iterates tokens only in reverse.\n * - ForwardTokenCommentCursor ... The cursor which iterates tokens and comments.\n * - BackwardTokenCommentCursor .. The cursor which iterates tokens and comments in reverse.\n * - DecorativeCursor\n *     - FilterCursor ............ The cursor which ignores the specified tokens.\n *     - SkipCursor .............. The cursor which ignores the first few tokens.\n *     - LimitCursor ............. The cursor which limits the count of tokens.\n *\n */\nmodule.exports = class Cursor {\n\n    /**\n     * Initializes this cursor.\n     */\n    constructor() {\n        this.current = null;\n    }\n\n    /**\n     * Gets the first token.\n     * This consumes this cursor.\n     * @returns {Token|Comment} The first token or null.\n     */\n    getOneToken() {\n        return this.moveNext() ? this.current : null;\n    }\n\n    /**\n     * Gets the first tokens.\n     * This consumes this cursor.\n     * @returns {(Token|Comment)[]} All tokens.\n     */\n    getAllTokens() {\n        const tokens = [];\n\n        while (this.moveNext()) {\n            tokens.push(this.current);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Moves this cursor to the next token.\n     * @returns {boolean} `true` if the next token exists.\n     * @abstract\n     */\n    /* istanbul ignore next */\n    moveNext() { // eslint-disable-line class-methods-use-this\n        throw new Error(\"Not implemented.\");\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/utils.js":"/**\n * @fileoverview Define utilify functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n *\n * @param {Node|Token|Comment} token - The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n    return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Binary-searches the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n *\n * @param {(Token|Comment)[]} tokens - It searches the token in this list.\n * @param {number} location - The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    return lodash.sortedIndexBy(\n        tokens,\n        { range: [location] },\n        getStartLocation\n    );\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n *\n * @param {(Token|Comment)[]} tokens - The tokens to find an index.\n * @param {Object} indexMap - The map from locations to indices.\n * @param {number} startLoc - The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        // For the map of \"comment's location -> token's index\", it points the next token of a comment.\n        // In that case, +1 is unnecessary.\n        if (token && token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n *\n * @param {(Token|Comment)[]} tokens - The tokens to find an index.\n * @param {Object} indexMap - The map from locations to indices.\n * @param {number} endLoc - The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        // For the map of \"comment's location -> token's index\", it points the next token of a comment.\n        // In that case, -1 is necessary.\n        if (token && token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/backward-token-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens only in reverse.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only in reverse.\n */\nmodule.exports = class BackwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index >= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index -= 1;\n            return true;\n        }\n        return false;\n    }\n\n    //\n    // Shorthand for performance.\n    //\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index >= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/filter-cursor.js":"/**\n * @fileoverview Define the cursor which ignores specified tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores specified tokens.\n */\nmodule.exports = class FilterCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {Function} predicate - The predicate function to decide tokens this cursor iterates.\n     */\n    constructor(cursor, predicate) {\n        super(cursor);\n        this.predicate = predicate;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const predicate = this.predicate;\n\n        while (super.moveNext()) {\n            if (predicate(this.current)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/decorative-cursor.js":"/**\n * @fileoverview Define the abstract class about cursors which manipulate another cursor.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which manipulate another cursor.\n */\nmodule.exports = class DecorativeCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     */\n    constructor(cursor) {\n        super();\n        this.cursor = cursor;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const retv = this.cursor.moveNext();\n\n        this.current = this.cursor.current;\n\n        return retv;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/forward-token-comment-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens and comments.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments.\n */\nmodule.exports = class ForwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.commentIndex = utils.search(comments, startLoc);\n        this.border = endLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex < this.tokens.length) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex < this.comments.length) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[0] < comment.range[0])) {\n            this.current = token;\n            this.tokenIndex += 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex += 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/forward-token-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens only.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only.\n */\nmodule.exports = class ForwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index <= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index += 1;\n            return true;\n        }\n        return false;\n    }\n\n    //\n    // Shorthand for performance.\n    //\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index <= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n\n    /** @inheritdoc */\n    getAllTokens() {\n        return this.tokens.slice(this.index, this.indexEnd + 1);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/limit-cursor.js":"/**\n * @fileoverview Define the cursor which limits the number of tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which limits the number of tokens.\n */\nmodule.exports = class LimitCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {number} count - The count of tokens this cursor iterates.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.count > 0) {\n            this.count -= 1;\n            return super.moveNext();\n        }\n        return false;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/skip-cursor.js":"/**\n * @fileoverview Define the cursor which ignores the first few tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores the first few tokens.\n */\nmodule.exports = class SkipCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {number} count - The count of tokens this cursor skips.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        while (this.count > 0) {\n            this.count -= 1;\n            if (!super.moveNext()) {\n                return false;\n            }\n        }\n        return super.moveNext();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/token-store/padded-token-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens only, with inflated range.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only, with inflated range.\n * This is for the backward compatibility of padding options.\n */\nmodule.exports = class PaddedTokenCursor extends ForwardTokenCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {number} beforeCount - The number of tokens this cursor iterates before start.\n     * @param {number} afterCount - The number of tokens this cursor iterates after end.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n        super(tokens, comments, indexMap, startLoc, endLoc);\n        this.index = Math.max(0, this.index - beforeCount);\n        this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/traverser.js":"/**\n * @fileoverview Wrapper around estraverse\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst estraverse = require(\"estraverse\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst KEY_BLACKLIST = new Set([\n    \"parent\",\n    \"leadingComments\",\n    \"trailingComments\"\n]);\n\n/**\n * Wrapper around an estraverse controller that ensures the correct keys\n * are visited.\n * @constructor\n */\nclass Traverser extends estraverse.Controller {\n    traverse(node, visitor) {\n        visitor.fallback = Traverser.getKeys;\n        return super.traverse(node, visitor);\n    }\n\n    /**\n     * Calculates the keys to use for traversal.\n     * @param {ASTNode} node The node to read keys from.\n     * @returns {string[]} An array of keys to visit on the node.\n     * @private\n     */\n    static getKeys(node) {\n        return Object.keys(node).filter(key => !KEY_BLACKLIST.has(key));\n    }\n}\n\nmodule.exports = Traverser;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rule-context.js":"/**\n * @fileoverview RuleContext utility for rules\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst ruleFixer = require(\"./util/rule-fixer\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PASSTHROUGHS = [\n    \"getAncestors\",\n    \"getDeclaredVariables\",\n    \"getFilename\",\n    \"getScope\",\n    \"markVariableAsUsed\",\n\n    // DEPRECATED\n    \"getAllComments\",\n    \"getComments\",\n    \"getFirstToken\",\n    \"getFirstTokens\",\n    \"getJSDocComment\",\n    \"getLastToken\",\n    \"getLastTokens\",\n    \"getNodeByRangeIndex\",\n    \"getSource\",\n    \"getSourceLines\",\n    \"getTokenAfter\",\n    \"getTokenBefore\",\n    \"getTokenByRangeStart\",\n    \"getTokens\",\n    \"getTokensAfter\",\n    \"getTokensBefore\",\n    \"getTokensBetween\"\n];\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {string} nodeType The type of node.\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} fix The function to call that creates a fix command.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Rule context class\n * Acts as an abstraction layer between rules and the main eslint object.\n */\nclass RuleContext {\n\n    /**\n     * @param {string} ruleId The ID of the rule using this object.\n     * @param {eslint} eslint The eslint object.\n     * @param {number} severity The configured severity level of the rule.\n     * @param {Array} options The configuration information to be added to the rule.\n     * @param {Object} settings The configuration settings passed from the config file.\n     * @param {Object} parserOptions The parserOptions settings passed from the config file.\n     * @param {Object} parserPath The parser setting passed from the config file.\n     * @param {Object} meta The metadata of the rule\n     * @param {Object} parserServices The parser services for the rule.\n     */\n    constructor(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices) {\n\n        // public.\n        this.id = ruleId;\n        this.options = options;\n        this.settings = settings;\n        this.parserOptions = parserOptions;\n        this.parserPath = parserPath;\n        this.meta = meta;\n\n        // create a separate copy and freeze it (it's not nice to freeze other people's objects)\n        this.parserServices = Object.freeze(Object.assign({}, parserServices));\n\n        // private.\n        this.eslint = eslint;\n        this.severity = severity;\n\n        Object.freeze(this);\n    }\n\n    /**\n     * Passthrough to eslint.getSourceCode().\n     * @returns {SourceCode} The SourceCode object for the code.\n     */\n    getSourceCode() {\n        return this.eslint.getSourceCode();\n    }\n\n    /**\n     * Passthrough to eslint.report() that automatically assigns the rule ID and severity.\n     * @param {ASTNode|MessageDescriptor} nodeOrDescriptor The AST node related to the message or a message\n     *      descriptor.\n     * @param {Object=} location The location of the error.\n     * @param {string} message The message to display to the user.\n     * @param {Object} opts Optional template data which produces a formatted message\n     *     with symbols being replaced by this object's values.\n     * @returns {void}\n     */\n    report(nodeOrDescriptor, location, message, opts) {\n\n        // check to see if it's a new style call\n        if (arguments.length === 1) {\n            const descriptor = nodeOrDescriptor;\n            let fix = null;\n\n            // if there's a fix specified, get it\n            if (typeof descriptor.fix === \"function\") {\n                fix = descriptor.fix(ruleFixer);\n            }\n\n            this.eslint.report(\n                this.id,\n                this.severity,\n                descriptor.node,\n                descriptor.loc || descriptor.node.loc.start,\n                descriptor.message,\n                descriptor.data,\n                fix,\n                this.meta\n            );\n\n            return;\n        }\n\n        // old style call\n        this.eslint.report(\n            this.id,\n            this.severity,\n            nodeOrDescriptor,\n            location,\n            message,\n            opts,\n            this.meta\n        );\n    }\n}\n\n// Copy over passthrough methods. All functions will have 5 or fewer parameters.\nPASSTHROUGHS.forEach(function(name) {\n    this[name] = function(a, b, c, d, e) {\n        return this.eslint[name](a, b, c, d, e);\n    };\n}, RuleContext.prototype);\n\nmodule.exports = RuleContext;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/rule-fixer.js":"/**\n * @fileoverview An object that creates fix commands for rules.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates a fix command that inserts text at the specified index in the source text.\n * @param {int} index The 0-based index at which to insert the new text.\n * @param {string} text The text to insert.\n * @returns {Object} The fix command.\n * @private\n */\nfunction insertTextAt(index, text) {\n    return {\n        range: [index, index],\n        text\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates code fixing commands for rules.\n */\n\nconst ruleFixer = Object.freeze({\n\n    /**\n     * Creates a fix command that inserts text after the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfter(nodeOrToken, text) {\n        return this.insertTextAfterRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text after the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfterRange(range, text) {\n        return insertTextAt(range[1], text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBefore(nodeOrToken, text) {\n        return this.insertTextBeforeRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBeforeRange(range, text) {\n        return insertTextAt(range[0], text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceText(nodeOrToken, text) {\n        return this.replaceTextRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        return {\n            range,\n            text\n        };\n    },\n\n    /**\n     * Creates a fix command that removes the node or token from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.removeRange(nodeOrToken.range);\n    },\n\n    /**\n     * Creates a fix command that removes the specified range of text from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to remove, first item is start of range, second\n     *      is end of range.\n     * @returns {Object} The fix command.\n     */\n    removeRange(range) {\n        return {\n            range,\n            text: \"\"\n        };\n    }\n\n});\n\n\nmodule.exports = ruleFixer;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/timing.js":"/**\n * @fileoverview Tracks performance of individual rules.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next */\n/**\n * Align the string to left\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignLeft(str, len, ch) {\n    return str + new Array(len - str.length + 1).join(ch || \" \");\n}\n\n/* istanbul ignore next */\n/**\n * Align the string to right\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignRight(str, len, ch) {\n    return new Array(len - str.length + 1).join(ch || \" \") + str;\n}\n\n//------------------------------------------------------------------------------\n// Module definition\n//------------------------------------------------------------------------------\n\nconst enabled = !!process.env.TIMING;\n\nconst HEADERS = [\"Rule\", \"Time (ms)\", \"Relative\"];\nconst ALIGN = [alignLeft, alignRight, alignRight];\n\n/* istanbul ignore next */\n/**\n * display the data\n * @param {Object} data Data object to be displayed\n * @returns {string} modified string\n * @private\n */\nfunction display(data) {\n    let total = 0;\n    const rows = Object.keys(data)\n        .map(key => {\n            const time = data[key];\n\n            total += time;\n            return [key, time];\n        })\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 10);\n\n    rows.forEach(row => {\n        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);\n        row[1] = row[1].toFixed(3);\n    });\n\n    rows.unshift(HEADERS);\n\n    const widths = [];\n\n    rows.forEach(row => {\n        const len = row.length;\n\n        for (let i = 0; i < len; i++) {\n            const n = row[i].length;\n\n            if (!widths[i] || n > widths[i]) {\n                widths[i] = n;\n            }\n        }\n    });\n\n    const table = rows.map(row =>\n        row\n            .map((cell, index) => ALIGN[index](cell, widths[index]))\n            .join(\" | \")\n    );\n\n    table.splice(1, 0, widths.map((w, index) => {\n        if (index !== 0 && index !== widths.length - 1) {\n            w++;\n        }\n\n        return ALIGN[index](\":\", w + 1, \"-\");\n    }).join(\"|\"));\n\n    console.log(table.join(\"\\n\"));      // eslint-disable-line no-console\n}\n\n/* istanbul ignore next */\nmodule.exports = (function() {\n\n    const data = Object.create(null);\n\n    /**\n     * Time the run\n     * @param {*} key key from the data object\n     * @param {Function} fn function to be called\n     * @returns {Function} function to be executed\n     * @private\n     */\n    function time(key, fn) {\n        if (typeof data[key] === \"undefined\") {\n            data[key] = 0;\n        }\n\n        return function() {\n            let t = process.hrtime();\n\n            fn.apply(null, Array.prototype.slice.call(arguments));\n            t = process.hrtime(t);\n            data[key] += t[0] * 1e3 + t[1] / 1e6;\n        };\n    }\n\n    if (enabled) {\n        process.on(\"exit\", () => {\n            display(data);\n        });\n    }\n\n    return {\n        time,\n        enabled\n    };\n\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/cli-engine.js":"/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    rules = require(\"./rules\"),\n    eslint = require(\"./eslint\"),\n    defaultOptions = require(\"../conf/cli-options\"),\n    IgnoredPaths = require(\"./ignored-paths\"),\n    Config = require(\"./config\"),\n    Plugins = require(\"./config/plugins\"),\n    fileEntryCache = require(\"file-entry-cache\"),\n    globUtil = require(\"./util/glob-util\"),\n    SourceCodeFixer = require(\"./util/source-code-fixer\"),\n    validator = require(\"./config/config-validator\"),\n    stringify = require(\"json-stable-stringify\"),\n    hash = require(\"./util/hash\"),\n\n    pkg = require(\"../package.json\");\n\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} allowInlineConfig Enable or disable inline configuration comments.\n * @property {boolean|Object} baseConfig Base config object. True enables recommend rules and environments.\n * @property {boolean} cache Enable result caching.\n * @property {string} cacheLocation The cache file to use instead of .eslintcache.\n * @property {string} configFile The configuration file to use.\n * @property {string} cwd The value to use for the current working directory.\n * @property {string[]} envs An array of environments to load.\n * @property {string[]} extensions An array of file extensions to check.\n * @property {boolean} fix Execute in autofix mode.\n * @property {string[]} globals An array of global variables to declare.\n * @property {boolean} ignore False disables use of .eslintignore.\n * @property {string} ignorePath The ignore file to use instead of .eslintignore.\n * @property {string} ignorePattern A glob pattern of files to ignore.\n * @property {boolean} useEslintrc False disables looking for .eslintrc\n * @property {string} parser The name of the parser to use.\n * @property {Object} parserOptions An object of parserOption settings to use.\n * @property {string[]} plugins An array of plugins to load.\n * @property {Object<string,*>} rules An object of rules to use.\n * @property {string[]} rulePaths An array of directories to load custom rules from.\n */\n\n/**\n * A linting warning or error.\n * @typedef {Object} LintMessage\n * @property {string} message The message to display to the user.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number or errors for the result.\n * @property {number} warningCount Number or warnings for the result.\n * @property {string=} [source] The source code of the file that was linted.\n * @property {string=} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {Object[]} messages - Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    return messages.reduce((stat, message) => {\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n        } else {\n            stat.warningCount++;\n        }\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0\n    });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {Object[]} results - Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    return results.reduce((stat, result) => {\n        stat.errorCount += result.errorCount;\n        stat.warningCount += result.warningCount;\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0\n    });\n}\n\n/**\n * Performs multiple autofix passes over the text until as many fixes as possible\n * have been applied.\n * @param {string} text The source text to apply fixes to.\n * @param {Object} config The ESLint config object to use.\n * @param {Object} options The ESLint options object to use.\n * @param {string} options.filename The filename from which the text was read.\n * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n *      should be allowed.\n * @returns {Object} The result of the fix operation as returned from the\n *      SourceCodeFixer.\n * @private\n */\nfunction multipassFix(text, config, options) {\n    const MAX_PASSES = 10;\n    let messages = [],\n        fixedResult,\n        fixed = false,\n        passNumber = 0;\n\n    /**\n     * This loop continues until one of the following is true:\n     *\n     * 1. No more fixes have been applied.\n     * 2. Ten passes have been made.\n     *\n     * That means anytime a fix is successfully applied, there will be another pass.\n     * Essentially, guaranteeing a minimum of two passes.\n     */\n    do {\n        passNumber++;\n\n        debug(`Linting code for ${options.filename} (pass ${passNumber})`);\n        messages = eslint.verify(text, config, options);\n\n        debug(`Generating fixed text for ${options.filename} (pass ${passNumber})`);\n        fixedResult = SourceCodeFixer.applyFixes(eslint.getSourceCode(), messages);\n\n        // stop if there are any syntax errors.\n        // 'fixedResult.output' is a empty string.\n        if (messages.length === 1 && messages[0].fatal) {\n            break;\n        }\n\n        // keep track if any fixes were ever applied - important for return value\n        fixed = fixed || fixedResult.fixed;\n\n        // update to use the fixed output instead of the original text\n        text = fixedResult.output;\n\n    } while (\n        fixedResult.fixed &&\n        passNumber < MAX_PASSES\n    );\n\n\n    /*\n     * If the last result had fixes, we need to lint again to be sure we have\n     * the most up-to-date information.\n     */\n    if (fixedResult.fixed) {\n        fixedResult.messages = eslint.verify(text, config, options);\n    }\n\n\n    // ensure the last result properly reflects if fixes were done\n    fixedResult.fixed = fixed;\n    fixedResult.output = text;\n\n    return fixedResult;\n\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {string} text The source code to check.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {string} filename An optional string representing the texts filename.\n * @param {boolean} fix Indicates if fixes should be processed.\n * @param {boolean} allowInlineConfig Allow/ignore comments that change config.\n * @returns {LintResult} The results for linting on this text.\n * @private\n */\nfunction processText(text, configHelper, filename, fix, allowInlineConfig) {\n\n    // clear all existing settings for a new file\n    eslint.reset();\n\n    let filePath,\n        messages,\n        fileExtension,\n        processor,\n        fixedResult;\n\n    if (filename) {\n        filePath = path.resolve(filename);\n        fileExtension = path.extname(filename);\n    }\n\n    filename = filename || \"<text>\";\n    debug(`Linting ${filename}`);\n    const config = configHelper.getConfig(filePath);\n\n    if (config.plugins) {\n        Plugins.loadAll(config.plugins);\n    }\n\n    const loadedPlugins = Plugins.getAll();\n\n    for (const plugin in loadedPlugins) {\n        if (loadedPlugins[plugin].processors && Object.keys(loadedPlugins[plugin].processors).indexOf(fileExtension) >= 0) {\n            processor = loadedPlugins[plugin].processors[fileExtension];\n            break;\n        }\n    }\n\n    if (processor) {\n        debug(\"Using processor\");\n        const parsedBlocks = processor.preprocess(text, filename);\n        const unprocessedMessages = [];\n\n        parsedBlocks.forEach(block => {\n            unprocessedMessages.push(eslint.verify(block, config, {\n                filename,\n                allowInlineConfig\n            }));\n        });\n\n        // TODO(nzakas): Figure out how fixes might work for processors\n\n        messages = processor.postprocess(unprocessedMessages, filename);\n\n    } else {\n\n        if (fix) {\n            fixedResult = multipassFix(text, config, {\n                filename,\n                allowInlineConfig\n            });\n            messages = fixedResult.messages;\n        } else {\n            messages = eslint.verify(text, config, {\n                filename,\n                allowInlineConfig\n            });\n        }\n    }\n\n    const stats = calculateStatsPerFile(messages);\n\n    const result = {\n        filePath: filename,\n        messages,\n        errorCount: stats.errorCount,\n        warningCount: stats.warningCount\n    };\n\n    if (fixedResult && fixedResult.fixed) {\n        result.output = fixedResult.output;\n    }\n\n    if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n        result.source = text;\n    }\n\n    return result;\n}\n\n/**\n * Processes an individual file using ESLint. Files used here are known to\n * exist, so no need to check that here.\n * @param {string} filename The filename of the file being checked.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {Object} options The CLIEngine options object.\n * @returns {LintResult} The results for linting on this file.\n * @private\n */\nfunction processFile(filename, configHelper, options) {\n\n    const text = fs.readFileSync(path.resolve(filename), \"utf8\"),\n        result = processText(text, configHelper, filename, options.fix, options.allowInlineConfig);\n\n    return result;\n\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath - File path of checked code\n * @param {string} baseDir  - Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isHidden = /^\\./.test(path.basename(filePath));\n    const isInNodeModules = baseDir && /^node_modules/.test(path.relative(baseDir, filePath));\n    const isInBowerComponents = baseDir && /^bower_components/.test(path.relative(baseDir, filePath));\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n    } else if (isInBowerComponents) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!bower_components/*'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                fatal: false,\n                severity: 1,\n                message\n            }\n        ],\n        errorCount: 0,\n        warningCount: 1\n    };\n}\n\n\n/**\n * Checks if the given message is an error message.\n * @param {Object} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n *\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    cacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, cacheFile);\n    const looksLikeADirectory = cacheFile[cacheFile.length - 1 ] === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch (ex) {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates a new instance of the core CLI engine.\n * @param {CLIEngineOptions} options The options for this instance.\n * @constructor\n */\nfunction CLIEngine(options) {\n\n    options = Object.assign(\n        Object.create(null),\n        defaultOptions,\n        { cwd: process.cwd() },\n        options\n    );\n\n    /**\n     * Stored options for this instance\n     * @type {Object}\n     */\n    this.options = options;\n\n    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);\n\n    /**\n     * Cache used to avoid operating on files that haven't changed since the\n     * last successful execution (e.g., file passed linting with no errors and\n     * no warnings).\n     * @type {Object}\n     */\n    this._fileCache = fileEntryCache.create(cacheFile);\n\n    // load in additional rules\n    if (this.options.rulePaths) {\n        const cwd = this.options.cwd;\n\n        this.options.rulePaths.forEach(rulesdir => {\n            debug(`Loading rules from ${rulesdir}`);\n            rules.load(rulesdir, cwd);\n        });\n    }\n\n    Object.keys(this.options.rules || {}).forEach(name => {\n        validator.validateRuleOptions(name, this.options.rules[name], \"CLI\");\n    });\n}\n\n/**\n * Returns the formatter representing the given format or null if no formatter\n * with the given name can be found.\n * @param {string} [format] The name of the format to load or the path to a\n *      custom formatter.\n * @returns {Function} The formatter function or null if not found.\n */\nCLIEngine.getFormatter = function(format) {\n\n    let formatterPath;\n\n    // default is stylish\n    format = format || \"stylish\";\n\n    // only strings are valid formatters\n    if (typeof format === \"string\") {\n\n        // replace \\ with / for Windows compatibility\n        format = format.replace(/\\\\/g, \"/\");\n\n        // if there's a slash, then it's a file\n        if (format.indexOf(\"/\") > -1) {\n            const cwd = this.options ? this.options.cwd : process.cwd();\n\n            formatterPath = path.resolve(cwd, format);\n        } else {\n            formatterPath = `./formatters/${format}`;\n        }\n\n        try {\n            return require(formatterPath);\n        } catch (ex) {\n            ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n            throw ex;\n        }\n\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns results that only contains errors.\n * @param {LintResult[]} results The results to filter.\n * @returns {LintResult[]} The filtered results.\n */\nCLIEngine.getErrorResults = function(results) {\n    const filtered = [];\n\n    results.forEach(result => {\n        const filteredMessages = result.messages.filter(isErrorMessage);\n\n        if (filteredMessages.length > 0) {\n            filtered.push(\n                Object.assign(result, {\n                    messages: filteredMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0\n                })\n            );\n        }\n    });\n\n    return filtered;\n};\n\n/**\n * Outputs fixes from the given results to files.\n * @param {Object} report The report object created by CLIEngine.\n * @returns {void}\n */\nCLIEngine.outputFixes = function(report) {\n    report.results.filter(result => result.hasOwnProperty(\"output\")).forEach(result => {\n        fs.writeFileSync(result.filePath, result.output);\n    });\n};\n\nCLIEngine.prototype = {\n\n    constructor: CLIEngine,\n\n    /**\n     * Add a plugin by passing it's configuration\n     * @param {string} name Name of the plugin.\n     * @param {Object} pluginobject Plugin configuration object.\n     * @returns {void}\n     */\n    addPlugin(name, pluginobject) {\n        Plugins.define(name, pluginobject);\n    },\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n    resolveFileGlobPatterns(patterns) {\n        return globUtil.resolveFileGlobPatterns(patterns, this.options);\n    },\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Object} The results for all files that were linted.\n     */\n    executeOnFiles(patterns) {\n        const results = [],\n            options = this.options,\n            fileCache = this._fileCache,\n            configHelper = new Config(options);\n        let prevConfig; // the previous configuration used\n\n        /**\n         * Calculates the hash of the config file used to validate a given file\n         * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash\n         * @returns {string}         the hash of the config\n         */\n        function hashOfConfigFor(filename) {\n            const config = configHelper.getConfig(filename);\n\n            if (!prevConfig) {\n                prevConfig = {};\n            }\n\n            // reuse the previously hashed config if the config hasn't changed\n            if (prevConfig.config !== config) {\n\n                /*\n                 * config changed so we need to calculate the hash of the config\n                 * and the hash of the plugins being used\n                 */\n                prevConfig.config = config;\n\n                const eslintVersion = pkg.version;\n\n                prevConfig.hash = hash(`${eslintVersion}_${stringify(config)}`);\n            }\n\n            return prevConfig.hash;\n        }\n\n        /**\n         * Executes the linter on a file defined by the `filename`. Skips\n         * unsupported file extensions and any files that are already linted.\n         * @param {string} filename The resolved filename of the file to be linted\n         * @param {boolean} warnIgnored always warn when a file is ignored\n         * @returns {void}\n         */\n        function executeOnFile(filename, warnIgnored) {\n            let hashOfConfig,\n                descriptor;\n\n            if (warnIgnored) {\n                results.push(createIgnoreResult(filename, options.cwd));\n                return;\n            }\n\n            if (options.cache) {\n\n                /*\n                 * get the descriptor for this file\n                 * with the metadata and the flag that determines if\n                 * the file has changed\n                 */\n                descriptor = fileCache.getFileDescriptor(filename);\n                const meta = descriptor.meta || {};\n\n                hashOfConfig = hashOfConfigFor(filename);\n\n                const changed = descriptor.changed || meta.hashOfConfig !== hashOfConfig;\n\n                if (!changed) {\n                    debug(`Skipping file since hasn't changed: ${filename}`);\n\n                    /*\n                     * Add the the cached results (always will be 0 error and\n                     * 0 warnings). We should not cache results for files that\n                     * failed, in order to guarantee that next execution will\n                     * process those files as well.\n                     */\n                    results.push(descriptor.meta.results);\n\n                    // move to the next file\n                    return;\n                }\n            } else {\n                fileCache.destroy();\n            }\n\n            debug(`Processing ${filename}`);\n\n            const res = processFile(filename, configHelper, options);\n\n            if (options.cache) {\n\n                /*\n                 * if a file contains errors or warnings we don't want to\n                 * store the file in the cache so we can guarantee that\n                 * next execution will also operate on this file\n                 */\n                if (res.errorCount > 0 || res.warningCount > 0) {\n                    debug(`File has problems, skipping it: ${filename}`);\n\n                    // remove the entry from the cache\n                    fileCache.removeEntry(filename);\n                } else {\n\n                    /*\n                     * since the file passed we store the result here\n                     * TODO: check this as we might not need to store the\n                     * successful runs as it will always should be 0 errors and\n                     * 0 warnings.\n                     */\n                    descriptor.meta.hashOfConfig = hashOfConfig;\n                    descriptor.meta.results = res;\n                }\n            }\n\n            results.push(res);\n        }\n\n        const startTime = Date.now();\n\n\n\n        patterns = this.resolveFileGlobPatterns(patterns);\n        const fileList = globUtil.listFilesToProcess(patterns, options);\n\n        fileList.forEach(fileInfo => {\n            executeOnFile(fileInfo.filename, fileInfo.ignored);\n        });\n\n        const stats = calculateStatsPerRun(results);\n\n        if (options.cache) {\n\n            // persist the cache to disk\n            fileCache.reconcile();\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n\n        return {\n            results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount\n        };\n    },\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} filename An optional string representing the texts filename.\n     * @param {boolean} warnIgnored Always warn when a file is ignored\n     * @returns {Object} The results for the linting.\n     */\n    executeOnText(text, filename, warnIgnored) {\n\n        const results = [],\n            options = this.options,\n            configHelper = new Config(options),\n            ignoredPaths = new IgnoredPaths(options);\n\n        // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)\n        if (filename && !path.isAbsolute(filename)) {\n            filename = path.resolve(options.cwd, filename);\n        }\n\n        if (filename && ignoredPaths.contains(filename)) {\n            if (warnIgnored) {\n                results.push(createIgnoreResult(filename, options.cwd));\n            }\n        } else {\n            results.push(processText(text, configHelper, filename, options.fix, options.allowInlineConfig));\n        }\n\n        const stats = calculateStatsPerRun(results);\n\n        return {\n            results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount\n        };\n    },\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Object} A configuration object for the file.\n     */\n    getConfigForFile(filePath) {\n        const configHelper = new Config(this.options);\n\n        return configHelper.getConfig(filePath);\n    },\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n    isPathIgnored(filePath) {\n        const resolvedPath = path.resolve(this.options.cwd, filePath);\n        const ignoredPaths = new IgnoredPaths(this.options);\n\n        return ignoredPaths.contains(resolvedPath);\n    },\n\n    getFormatter: CLIEngine.getFormatter\n\n};\n\nCLIEngine.version = pkg.version;\n\nmodule.exports = CLIEngine;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/conf/cli-options.js":"/**\n * @fileoverview Default CLIEngineOptions.\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\nmodule.exports = {\n    configFile: null,\n    baseConfig: false,\n    rulePaths: [],\n    useEslintrc: true,\n    envs: [],\n    globals: [],\n    rules: {},\n    extensions: [\".js\"],\n    ignore: true,\n    ignorePath: null,\n    parser: \"\",     // must be empty\n    cache: false,\n\n    // in order to honor the cacheFile option if specified\n    // this option should not have a default value otherwise\n    // it will always be used\n    cacheLocation: \"\",\n    cacheFile: \".eslintcache\",\n    fix: false,\n    allowInlineConfig: true\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/ignored-paths.js":"/**\n * @fileoverview Responsible for loading ignore config files and managing ignore patterns\n * @author Jonathan Rajavuori\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    ignore = require(\"ignore\"),\n    shell = require(\"shelljs\"),\n    pathUtil = require(\"./util/path-util\");\n\nconst debug = require(\"debug\")(\"eslint:ignored-paths\");\n\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ESLINT_IGNORE_FILENAME = \".eslintignore\";\n\n/**\n * Adds `\"*\"` at the end of `\"node_modules/\"`,\n * so that subtle directories could be re-included by .gitignore patterns\n * such as `\"!node_modules/should_not_ignored\"`\n */\nconst DEFAULT_IGNORE_DIRS = [\n    \"/node_modules/*\",\n    \"/bower_components/*\"\n];\nconst DEFAULT_OPTIONS = {\n    dotfiles: false,\n    cwd: process.cwd()\n};\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\n/**\n * Find an ignore file in the current directory.\n * @param {string} cwd Current working directory\n * @returns {string} Path of ignore file or an empty string.\n */\nfunction findIgnoreFile(cwd) {\n    cwd = cwd || DEFAULT_OPTIONS.cwd;\n\n    const ignoreFilePath = path.resolve(cwd, ESLINT_IGNORE_FILENAME);\n\n    return shell.test(\"-f\", ignoreFilePath) ? ignoreFilePath : \"\";\n}\n\n/**\n * Merge options with defaults\n * @param {Object} options Options to merge with DEFAULT_OPTIONS constant\n * @returns {Object} Merged options\n */\nfunction mergeDefaultOptions(options) {\n    options = (options || {});\n    return Object.assign({}, DEFAULT_OPTIONS, options);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * IgnoredPaths class\n */\nclass IgnoredPaths {\n\n    /**\n     * @param {Object} options object containing 'ignore', 'ignorePath' and 'patterns' properties\n     */\n    constructor(options) {\n        options = mergeDefaultOptions(options);\n\n        /**\n         * add pattern to node-ignore instance\n         * @param {Object} ig, instance of node-ignore\n         * @param {string} pattern, pattern do add to ig\n         * @returns {array} raw ignore rules\n         */\n        function addPattern(ig, pattern) {\n            return ig.addPattern(pattern);\n        }\n\n        /**\n         * add ignore file to node-ignore instance\n         * @param {Object} ig, instance of node-ignore\n         * @param {string} filepath, file to add to ig\n         * @returns {array} raw ignore rules\n         */\n        function addIgnoreFile(ig, filepath) {\n            ig.ignoreFiles.push(filepath);\n            return ig.add(fs.readFileSync(filepath, \"utf8\"));\n        }\n\n        this.defaultPatterns = [].concat(DEFAULT_IGNORE_DIRS, options.patterns || []);\n        this.baseDir = options.cwd;\n\n        this.ig = {\n            custom: ignore(),\n            default: ignore()\n        };\n\n        // Add a way to keep track of ignored files.  This was present in node-ignore\n        // 2.x, but dropped for now as of 3.0.10.\n        this.ig.custom.ignoreFiles = [];\n        this.ig.default.ignoreFiles = [];\n\n        if (options.dotfiles !== true) {\n\n            /*\n             * ignore files beginning with a dot, but not files in a parent or\n             * ancestor directory (which in relative format will begin with `../`).\n             */\n            addPattern(this.ig.default, [\".*\", \"!../\"]);\n        }\n\n        addPattern(this.ig.default, this.defaultPatterns);\n\n        if (options.ignore !== false) {\n            let ignorePath;\n\n            if (options.ignorePath) {\n                debug(\"Using specific ignore file\");\n\n                try {\n                    fs.statSync(options.ignorePath);\n                    ignorePath = options.ignorePath;\n                } catch (e) {\n                    e.message = `Cannot read ignore file: ${options.ignorePath}\\nError: ${e.message}`;\n                    throw e;\n                }\n            } else {\n                debug(`Looking for ignore file in ${options.cwd}`);\n                ignorePath = findIgnoreFile(options.cwd);\n\n                try {\n                    fs.statSync(ignorePath);\n                    debug(`Loaded ignore file ${ignorePath}`);\n                } catch (e) {\n                    debug(\"Could not find ignore file in cwd\");\n                    this.options = options;\n                }\n            }\n\n            if (ignorePath) {\n                debug(`Adding ${ignorePath}`);\n                this.baseDir = path.dirname(path.resolve(options.cwd, ignorePath));\n                addIgnoreFile(this.ig.custom, ignorePath);\n                addIgnoreFile(this.ig.default, ignorePath);\n            }\n\n            if (options.ignorePattern) {\n                addPattern(this.ig.custom, options.ignorePattern);\n                addPattern(this.ig.default, options.ignorePattern);\n            }\n        }\n\n        this.options = options;\n    }\n\n    /**\n     * Determine whether a file path is included in the default or custom ignore patterns\n     * @param {string} filepath Path to check\n     * @param {string} [category=null] check 'default', 'custom' or both (null)\n     * @returns {boolean} true if the file path matches one or more patterns, false otherwise\n     */\n    contains(filepath, category) {\n\n        let result = false;\n        const absolutePath = path.resolve(this.options.cwd, filepath);\n        const relativePath = pathUtil.getRelativePath(absolutePath, this.options.cwd);\n\n        if ((typeof category === \"undefined\") || (category === \"default\")) {\n            result = result || (this.ig.default.filter([relativePath]).length === 0);\n        }\n\n        if ((typeof category === \"undefined\") || (category === \"custom\")) {\n            result = result || (this.ig.custom.filter([relativePath]).length === 0);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Returns a list of dir patterns for glob to ignore\n     * @returns {function()} method to check whether a folder should be ignored by glob.\n     */\n    getIgnoredFoldersGlobChecker() {\n\n        const ig = ignore().add(DEFAULT_IGNORE_DIRS);\n\n        if (this.options.dotfiles !== true) {\n\n            // Ignore hidden folders.  (This cannot be \".*\", or else it's not possible to unignore hidden files)\n            ig.add([\".*/*\", \"!../\"]);\n        }\n\n        if (this.options.ignore) {\n            ig.add(this.ig.custom);\n        }\n\n        const filter = ig.createFilter();\n\n        /**\n         * TODO\n         * 1.\n         * Actually, it should be `this.options.baseDir`, which is the base dir of `ignore-path`,\n         * as well as Line 177.\n         * But doing this leads to a breaking change and fails tests.\n         * Related to #6759\n         */\n        const base = this.options.cwd;\n\n        return function(absolutePath) {\n            const relative = pathUtil.getRelativePath(absolutePath, base);\n\n            if (!relative) {\n                return false;\n            }\n\n            return !filter(relative);\n        };\n    }\n}\n\nmodule.exports = IgnoredPaths;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/path-util.js":"/**\n * @fileoverview Common helpers for operations on filenames and paths\n * @author Ian VanSchooten\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Replace Windows with posix style paths\n *\n * @param {string} filepath   Path to convert\n * @returns {string}          Converted filepath\n */\nfunction convertPathToPosix(filepath) {\n    const normalizedFilepath = path.normalize(filepath);\n    const posixFilepath = normalizedFilepath.replace(/\\\\/g, \"/\");\n\n    return posixFilepath;\n}\n\n/**\n * Converts an absolute filepath to a relative path from a given base path\n *\n * For example, if the filepath is `/my/awesome/project/foo.bar`,\n * and the base directory is `/my/awesome/project/`,\n * then this function should return `foo.bar`.\n *\n * path.relative() does something similar, but it requires a baseDir (`from` argument).\n * This function makes it optional and just removes a leading slash if the baseDir is not given.\n *\n * It does not take into account symlinks (for now).\n *\n * @param {string} filepath  Path to convert to relative path.  If already relative,\n *                           it will be assumed to be relative to process.cwd(),\n *                           converted to absolute, and then processed.\n * @param {string} [baseDir] Absolute base directory to resolve the filepath from.\n *                           If not provided, all this function will do is remove\n *                           a leading slash.\n * @returns {string} Relative filepath\n */\nfunction getRelativePath(filepath, baseDir) {\n    let relativePath;\n\n    if (!path.isAbsolute(filepath)) {\n        filepath = path.resolve(filepath);\n    }\n    if (baseDir) {\n        if (!path.isAbsolute(baseDir)) {\n            throw new Error(\"baseDir should be an absolute path\");\n        }\n        relativePath = path.relative(baseDir, filepath);\n    } else {\n        relativePath = filepath.replace(/^\\//, \"\");\n    }\n    return relativePath;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    convertPathToPosix,\n    getRelativePath\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config.js":"/**\n * @fileoverview Responsible for loading config files\n * @author Seth McLaughlin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    ConfigFile = require(\"./config/config-file\"),\n    Plugins = require(\"./config/plugins\"),\n    FileFinder = require(\"./file-finder\"),\n    userHome = require(\"user-home\"),\n    isResolvable = require(\"is-resolvable\"),\n    pathIsInside = require(\"path-is-inside\");\n\nconst debug = require(\"debug\")(\"eslint:config\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PERSONAL_CONFIG_DIR = userHome || null;\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check if item is an javascript object\n * @param {*} item object to check for\n * @returns {boolean} True if its an object\n * @private\n */\nfunction isObject(item) {\n    return typeof item === \"object\" && !Array.isArray(item) && item !== null;\n}\n\n/**\n * Load and parse a JSON config object from a file.\n * @param {string|Object} configToLoad the path to the JSON config file or the config object itself.\n * @returns {Object} the parsed config object (empty object if there was a parse error)\n * @private\n */\nfunction loadConfig(configToLoad) {\n    let config = {},\n        filePath = \"\";\n\n    if (configToLoad) {\n\n        if (isObject(configToLoad)) {\n            config = configToLoad;\n\n            if (config.extends) {\n                config = ConfigFile.applyExtends(config, filePath);\n            }\n        } else {\n            filePath = configToLoad;\n            config = ConfigFile.load(filePath);\n        }\n\n    }\n\n    return config;\n}\n\n/**\n * Get personal config object from ~/.eslintrc.\n * @returns {Object} the personal config object (null if there is no personal config)\n * @private\n */\nfunction getPersonalConfig() {\n    let config;\n\n    if (PERSONAL_CONFIG_DIR) {\n        const filename = ConfigFile.getFilenameForDirectory(PERSONAL_CONFIG_DIR);\n\n        if (filename) {\n            debug(\"Using personal config\");\n            config = loadConfig(filename);\n        }\n    }\n\n    return config || null;\n}\n\n/**\n * Determine if rules were explicitly passed in as options.\n * @param {Object} options The options used to create our configuration.\n * @returns {boolean} True if rules were passed in as options, false otherwise.\n */\nfunction hasRules(options) {\n    return options.rules && Object.keys(options.rules).length > 0;\n}\n\n/**\n * Get a local config object.\n * @param {Object} thisConfig A Config object.\n * @param {string} directory The directory to start looking in for a local config file.\n * @returns {Object} The local config object, or an empty object if there is no local config.\n */\nfunction getLocalConfig(thisConfig, directory) {\n    const localConfigFiles = thisConfig.findLocalConfigFiles(directory),\n        numFiles = localConfigFiles.length,\n        projectConfigPath = ConfigFile.getFilenameForDirectory(thisConfig.options.cwd);\n    let found,\n        config = {},\n        rootPath;\n\n    for (let i = 0; i < numFiles; i++) {\n\n        const localConfigFile = localConfigFiles[i];\n\n        // Don't consider the personal config file in the home directory,\n        // except if the home directory is the same as the current working directory\n        if (path.dirname(localConfigFile) === PERSONAL_CONFIG_DIR && localConfigFile !== projectConfigPath) {\n            continue;\n        }\n\n        // If root flag is set, don't consider file if it is above root\n        if (rootPath && !pathIsInside(path.dirname(localConfigFile), rootPath)) {\n            continue;\n        }\n\n        debug(`Loading ${localConfigFile}`);\n        const localConfig = loadConfig(localConfigFile);\n\n        // Don't consider a local config file found if the config is null\n        if (!localConfig) {\n            continue;\n        }\n\n        // Check for root flag\n        if (localConfig.root === true) {\n            rootPath = path.dirname(localConfigFile);\n        }\n\n        found = true;\n        debug(`Using ${localConfigFile}`);\n        config = ConfigOps.merge(localConfig, config);\n    }\n\n    if (!found && !thisConfig.useSpecificConfig) {\n\n        /*\n         * - Is there a personal config in the user's home directory? If so,\n         *   merge that with the passed-in config.\n         * - Otherwise, if no rules were manually passed in, throw and error.\n         * - Note: This function is not called if useEslintrc is false.\n         */\n        const personalConfig = getPersonalConfig();\n\n        if (personalConfig) {\n            config = ConfigOps.merge(config, personalConfig);\n        } else if (!hasRules(thisConfig.options) && !thisConfig.options.baseConfig) {\n\n            // No config file, no manual configuration, and no rules, so error.\n            const noConfigError = new Error(\"No ESLint configuration found.\");\n\n            noConfigError.messageTemplate = \"no-config-found\";\n            noConfigError.messageData = {\n                directory,\n                filesExamined: localConfigFiles\n            };\n\n            throw noConfigError;\n        }\n    }\n\n    return config;\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * Configuration class\n */\nclass Config {\n\n    /**\n     * Config options\n     * @param {Object} options Options to be passed in\n     */\n    constructor(options) {\n        options = options || {};\n\n        this.ignore = options.ignore;\n        this.ignorePath = options.ignorePath;\n        this.cache = {};\n        this.parser = options.parser;\n        this.parserOptions = options.parserOptions || {};\n\n        this.baseConfig = options.baseConfig ? loadConfig(options.baseConfig) : { rules: {} };\n\n        this.useEslintrc = (options.useEslintrc !== false);\n\n        this.env = (options.envs || []).reduce((envs, name) => {\n            envs[ name ] = true;\n            return envs;\n        }, {});\n\n        /*\n         * Handle declared globals.\n         * For global variable foo, handle \"foo:false\" and \"foo:true\" to set\n         * whether global is writable.\n         * If user declares \"foo\", convert to \"foo:false\".\n         */\n        this.globals = (options.globals || []).reduce((globals, def) => {\n            const parts = def.split(\":\");\n\n            globals[parts[0]] = (parts.length > 1 && parts[1] === \"true\");\n\n            return globals;\n        }, {});\n\n        const useConfig = options.configFile;\n\n        this.options = options;\n\n        if (useConfig) {\n            debug(`Using command line config ${useConfig}`);\n            if (isResolvable(useConfig) || isResolvable(`eslint-config-${useConfig}`) || useConfig.charAt(0) === \"@\") {\n                this.useSpecificConfig = loadConfig(useConfig);\n            } else {\n                this.useSpecificConfig = loadConfig(path.resolve(this.options.cwd, useConfig));\n            }\n        }\n    }\n\n    /**\n     * Build a config object merging the base config (conf/eslint-recommended),\n     * the environments config (conf/environments.js) and eventually the user\n     * config.\n     * @param {string} filePath a file in whose directory we start looking for a local config\n     * @returns {Object} config object\n     */\n    getConfig(filePath) {\n        const directory = filePath ? path.dirname(filePath) : this.options.cwd;\n        let config,\n            userConfig;\n\n        debug(`Constructing config for ${filePath ? filePath : \"text\"}`);\n\n        config = this.cache[directory];\n\n        if (config) {\n            debug(\"Using config from cache\");\n            return config;\n        }\n\n        // Step 1: Determine user-specified config from .eslintrc.* and package.json files\n        if (this.useEslintrc) {\n            debug(\"Using .eslintrc and package.json files\");\n            userConfig = getLocalConfig(this, directory);\n        } else {\n            debug(\"Not using .eslintrc or package.json files\");\n            userConfig = {};\n        }\n\n        // Step 2: Create a copy of the baseConfig\n        config = ConfigOps.merge({}, this.baseConfig);\n\n        // Step 3: Merge in the user-specified configuration from .eslintrc and package.json\n        config = ConfigOps.merge(config, userConfig);\n\n        // Step 4: Merge in command line config file\n        if (this.useSpecificConfig) {\n            debug(\"Merging command line config file\");\n\n            config = ConfigOps.merge(config, this.useSpecificConfig);\n        }\n\n        // Step 5: Merge in command line environments\n        debug(\"Merging command line environment settings\");\n        config = ConfigOps.merge(config, { env: this.env });\n\n        // Step 6: Merge in command line rules\n        if (this.options.rules) {\n            debug(\"Merging command line rules\");\n            config = ConfigOps.merge(config, { rules: this.options.rules });\n        }\n\n        // Step 7: Merge in command line globals\n        config = ConfigOps.merge(config, { globals: this.globals });\n\n        // Only override parser if it is passed explicitly through the command line or if it's not\n        // defined yet (because the final object will at least have the parser key)\n        if (this.parser || !config.parser) {\n            config = ConfigOps.merge(config, {\n                parser: this.parser\n            });\n        }\n\n        if (this.parserOptions) {\n            config = ConfigOps.merge(config, {\n                parserOptions: this.parserOptions\n            });\n        }\n\n        // Step 8: Merge in command line plugins\n        if (this.options.plugins) {\n            debug(\"Merging command line plugins\");\n            Plugins.loadAll(this.options.plugins);\n            config = ConfigOps.merge(config, { plugins: this.options.plugins });\n        }\n\n        // Step 9: Apply environments to the config if present\n        if (config.env) {\n            config = ConfigOps.applyEnvironments(config);\n        }\n\n        this.cache[directory] = config;\n\n        return config;\n    }\n\n    /**\n     * Find local config files from directory and parent directories.\n     * @param {string} directory The directory to start searching from.\n     * @returns {string[]} The paths of local config files found.\n     */\n    findLocalConfigFiles(directory) {\n\n        if (!this.localConfigFinder) {\n            this.localConfigFinder = new FileFinder(ConfigFile.CONFIG_FILES, this.options.cwd);\n        }\n\n        return this.localConfigFinder.findAllInDirectoryAndParents(directory);\n    }\n}\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/config-file.js":"/**\n * @fileoverview Helper to locate and load configuration files.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-use-before-define: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    shell = require(\"shelljs\"),\n    ConfigOps = require(\"./config-ops\"),\n    validator = require(\"./config-validator\"),\n    Plugins = require(\"./plugins\"),\n    pathUtil = require(\"../util/path-util\"),\n    ModuleResolver = require(\"../util/module-resolver\"),\n    pathIsInside = require(\"path-is-inside\"),\n    stripBom = require(\"strip-bom\"),\n    stripComments = require(\"strip-json-comments\"),\n    stringify = require(\"json-stable-stringify\"),\n    defaultOptions = require(\"../../conf/eslint-recommended\"),\n    requireUncached = require(\"require-uncached\");\n\nconst debug = require(\"debug\")(\"eslint:config-file\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines sort order for object keys for json-stable-stringify\n *\n * see: https://github.com/substack/json-stable-stringify#cmp\n *\n * @param   {Object} a The first comparison object ({key: akey, value: avalue})\n * @param   {Object} b The second comparison object ({key: bkey, value: bvalue})\n * @returns {number}   1 or -1, used in stringify cmp method\n */\nfunction sortByKey(a, b) {\n    return a.key > b.key ? 1 : -1;\n}\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst CONFIG_FILES = [\n    \".eslintrc.js\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\nconst resolver = new ModuleResolver();\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents.\n * @private\n */\nfunction readFile(filePath) {\n    return stripBom(fs.readFileSync(filePath, \"utf8\"));\n}\n\n/**\n * Determines if a given string represents a filepath or not using the same\n * conventions as require(), meaning that the first character must be nonalphanumeric\n * and not the @ sign which is used for scoped packages to be considered a file path.\n * @param {string} filePath The string to check.\n * @returns {boolean} True if it's a filepath, false if not.\n * @private\n */\nfunction isFilePath(filePath) {\n    return path.isAbsolute(filePath) || !/\\w|@/.test(filePath.charAt(0));\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.safeLoad(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return requireUncached(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        return loadJSONConfigFile(filePath).eslintConfig || null;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configMissingError(configName) {\n    const error = new Error(`Failed to load config \"${configName}\" to extend from.`);\n\n    error.messageTemplate = \"extend-config-missing\";\n    error.messageData = {\n        configName\n    };\n    return error;\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {Object} file The path to the configuration.\n * @returns {Object} The configuration information.\n * @private\n */\nfunction loadConfigFile(file) {\n    const filePath = file.filePath;\n    let config;\n\n    switch (path.extname(filePath)) {\n        case \".js\":\n            config = loadJSConfigFile(filePath);\n            if (file.configName) {\n                config = config.configs[file.configName];\n                if (!config) {\n                    throw configMissingError(file.configFullName);\n                }\n            }\n            break;\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                config = loadPackageJSONConfigFile(filePath);\n                if (config === null) {\n                    return null;\n                }\n            } else {\n                config = loadJSONConfigFile(filePath);\n            }\n            break;\n\n        case \".yaml\":\n        case \".yml\":\n            config = loadYAMLConfigFile(filePath);\n            break;\n\n        default:\n            config = loadLegacyConfigFile(filePath);\n    }\n\n    return ConfigOps.merge(ConfigOps.createEmptyConfig(), config);\n}\n\n/**\n * Writes a configuration file in JSON format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeJSONConfigFile(config, filePath) {\n    debug(`Writing JSON config file: ${filePath}`);\n\n    const content = stringify(config, { cmp: sortByKey, space: 4 });\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file in YAML format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeYAMLConfigFile(config, filePath) {\n    debug(`Writing YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    const content = yaml.safeDump(config, { sortKeys: true });\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file in JavaScript format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeJSConfigFile(config, filePath) {\n    debug(`Writing JS config file: ${filePath}`);\n\n    const content = `module.exports = ${stringify(config, { cmp: sortByKey, space: 4 })};`;\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @throws {Error} When an unknown file type is specified.\n * @private\n */\nfunction write(config, filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n            writeJSConfigFile(config, filePath);\n            break;\n\n        case \".json\":\n            writeJSONConfigFile(config, filePath);\n            break;\n\n        case \".yaml\":\n        case \".yml\":\n            writeYAMLConfigFile(config, filePath);\n            break;\n\n        default:\n            throw new Error(\"Can't write to unknown file type.\");\n    }\n}\n\n/**\n * Determines the base directory for node packages referenced in a config file.\n * This does not include node_modules in the path so it can be used for all\n * references relative to a config file.\n * @param {string} configFilePath The config file referencing the file.\n * @returns {string} The base directory for the file path.\n * @private\n */\nfunction getBaseDir(configFilePath) {\n\n    // calculates the path of the project including ESLint as dependency\n    const projectPath = path.resolve(__dirname, \"../../../\");\n\n    if (configFilePath && pathIsInside(configFilePath, projectPath)) {\n\n        // be careful of https://github.com/substack/node-resolve/issues/78\n        return path.join(path.resolve(configFilePath));\n    }\n\n    /*\n     * default to ESLint project path since it's unlikely that plugins will be\n     * in this directory\n     */\n    return path.join(projectPath);\n}\n\n/**\n * Determines the lookup path, including node_modules, for package\n * references relative to a config file.\n * @param {string} configFilePath The config file referencing the file.\n * @returns {string} The lookup path for the file path.\n * @private\n */\nfunction getLookupPath(configFilePath) {\n    const basedir = getBaseDir(configFilePath);\n\n    return path.join(basedir, \"node_modules\");\n}\n\n/**\n * Resolves a eslint core config path\n * @param {string} name The eslint config name.\n * @returns {string} The resolved path of the config.\n * @private\n */\nfunction getEslintCoreConfigPath(name) {\n    if (name === \"eslint:recommended\") {\n\n       /*\n        * Add an explicit substitution for eslint:recommended to\n        * conf/eslint-recommended.js.\n        */\n        return path.resolve(__dirname, \"../../conf/eslint-recommended.js\");\n    }\n\n    if (name === \"eslint:all\") {\n\n       /*\n        * Add an explicit substitution for eslint:all to conf/eslint-all.js\n        */\n        return path.resolve(__dirname, \"../../conf/eslint-all.js\");\n    }\n\n    throw configMissingError(name);\n}\n\n/**\n * Applies values from the \"extends\" field in a configuration file.\n * @param {Object} config The configuration information.\n * @param {string} filePath The file path from which the configuration information\n *      was loaded.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} A new configuration object with all of the \"extends\" fields\n *      loaded and merged.\n * @private\n */\nfunction applyExtends(config, filePath, relativeTo) {\n    let configExtends = config.extends;\n\n    // normalize into an array for easier handling\n    if (!Array.isArray(config.extends)) {\n        configExtends = [config.extends];\n    }\n\n    // Make the last element in an array take the highest precedence\n    config = configExtends.reduceRight((previousValue, parentPath) => {\n        try {\n            if (parentPath.startsWith(\"eslint:\")) {\n                parentPath = getEslintCoreConfigPath(parentPath);\n            } else if (isFilePath(parentPath)) {\n\n                /*\n                 * If the `extends` path is relative, use the directory of the current configuration\n                 * file as the reference point. Otherwise, use as-is.\n                 */\n                parentPath = (path.isAbsolute(parentPath)\n                    ? parentPath\n                    : path.join(relativeTo || path.dirname(filePath), parentPath)\n                );\n            }\n            debug(`Loading ${parentPath}`);\n            return ConfigOps.merge(load(parentPath, false, relativeTo), previousValue);\n        } catch (e) {\n\n            /*\n             * If the file referenced by `extends` failed to load, add the path\n             * to the configuration file that referenced it to the error\n             * message so the user is able to see where it was referenced from,\n             * then re-throw.\n             */\n            e.message += `\\nReferenced from: ${filePath}`;\n            throw e;\n        }\n\n    }, config);\n\n    return config;\n}\n\n/**\n * Brings package name to correct format based on prefix\n * @param {string} name The name of the package.\n * @param {string} prefix Can be either \"eslint-plugin\" or \"eslint-config\n * @returns {string} Normalized name of the package\n * @private\n */\nfunction normalizePackageName(name, prefix) {\n\n    /*\n     * On Windows, name can come in with Windows slashes instead of Unix slashes.\n     * Normalize to Unix first to avoid errors later on.\n     * https://github.com/eslint/eslint/issues/5644\n     */\n    if (name.indexOf(\"\\\\\") > -1) {\n        name = pathUtil.convertPathToPosix(name);\n    }\n\n    if (name.charAt(0) === \"@\") {\n\n        /*\n         * it's a scoped package\n         * package name is \"eslint-config\", or just a username\n         */\n        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`),\n            scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`);\n\n        if (scopedPackageShortcutRegex.test(name)) {\n            name = name.replace(scopedPackageShortcutRegex, `$1/${prefix}`);\n        } else if (!scopedPackageNameRegex.test(name.split(\"/\")[1])) {\n\n            /*\n             * for scoped packages, insert the eslint-config after the first / unless\n             * the path is already @scope/eslint or @scope/eslint-config-xxx\n             */\n            name = name.replace(/^@([^/]+)\\/(.*)$/, `@$1/${prefix}-$2`);\n        }\n    } else if (name.indexOf(`${prefix}-`) !== 0) {\n        name = `${prefix}-${name}`;\n    }\n\n    return name;\n}\n\n/**\n * Resolves a configuration file path into the fully-formed path, whether filename\n * or package name.\n * @param {string} filePath The filepath to resolve.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} An object containing 3 properties:\n * - 'filePath' (required) the resolved path that can be used directly to load the configuration.\n * - 'configName' the name of the configuration inside the plugin.\n * - 'configFullName' the name of the configuration as used in the eslint config (e.g. 'plugin:node/recommended').\n * @private\n */\nfunction resolve(filePath, relativeTo) {\n    if (isFilePath(filePath)) {\n        return { filePath: path.resolve(relativeTo || \"\", filePath) };\n    }\n    let normalizedPackageName;\n\n    if (filePath.startsWith(\"plugin:\")) {\n        const configFullName = filePath;\n        const pluginName = filePath.substr(7, filePath.lastIndexOf(\"/\") - 7);\n        const configName = filePath.substr(filePath.lastIndexOf(\"/\") + 1, filePath.length - filePath.lastIndexOf(\"/\") - 1);\n\n        normalizedPackageName = normalizePackageName(pluginName, \"eslint-plugin\");\n        debug(`Attempting to resolve ${normalizedPackageName}`);\n        filePath = resolver.resolve(normalizedPackageName, getLookupPath(relativeTo));\n        return { filePath, configName, configFullName };\n    }\n    normalizedPackageName = normalizePackageName(filePath, \"eslint-config\");\n    debug(`Attempting to resolve ${normalizedPackageName}`);\n    filePath = resolver.resolve(normalizedPackageName, getLookupPath(relativeTo));\n    return { filePath };\n\n\n\n}\n\n/**\n * Loads a configuration file from the given file path.\n * @param {string} filePath The filename or package name to load the configuration\n *      information from.\n * @param {boolean} [applyEnvironments=false] Set to true to merge in environment settings.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} The configuration information.\n * @private\n */\nfunction load(filePath, applyEnvironments, relativeTo) {\n    const resolvedPath = resolve(filePath, relativeTo),\n        dirname = path.dirname(resolvedPath.filePath),\n        lookupPath = getLookupPath(dirname);\n    let config = loadConfigFile(resolvedPath);\n\n    if (config) {\n\n        // ensure plugins are properly loaded first\n        if (config.plugins) {\n            Plugins.loadAll(config.plugins);\n        }\n\n        // remove parser from config if it is the default parser\n        if (config.parser === defaultOptions.parser) {\n            config.parser = null;\n        }\n\n        // include full path of parser if present\n        if (config.parser) {\n            if (isFilePath(config.parser)) {\n                config.parser = path.resolve(dirname || \"\", config.parser);\n            } else {\n                config.parser = resolver.resolve(config.parser, lookupPath);\n            }\n        }\n\n        // validate the configuration before continuing\n        validator.validate(config, filePath);\n\n        /*\n         * If an `extends` property is defined, it represents a configuration file to use as\n         * a \"parent\". Load the referenced file and merge the configuration recursively.\n         */\n        if (config.extends) {\n            config = applyExtends(config, filePath, dirname);\n        }\n\n        if (config.env && applyEnvironments) {\n\n            // Merge in environment-specific globals and parserOptions.\n            config = ConfigOps.applyEnvironments(config);\n        }\n\n    }\n\n    return config;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    getBaseDir,\n    getLookupPath,\n    load,\n    resolve,\n    write,\n    applyExtends,\n    normalizePackageName,\n    CONFIG_FILES,\n\n    /**\n     * Retrieves the configuration filename for a given directory. It loops over all\n     * of the valid configuration filenames in order to find the first one that exists.\n     * @param {string} directory The directory to check for a config file.\n     * @returns {?string} The filename of the configuration file for the directory\n     *      or null if there is no configuration file in the directory.\n     */\n    getFilenameForDirectory(directory) {\n        for (let i = 0, len = CONFIG_FILES.length; i < len; i++) {\n            const filename = path.join(directory, CONFIG_FILES[i]);\n\n            if (shell.test(\"-f\", filename)) {\n                return filename;\n            }\n        }\n\n        return null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/plugins.js":"/**\n * @fileoverview Plugins manager\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Environments = require(\"./environments\"),\n    Rules = require(\"../rules\");\n\nconst debug = require(\"debug\")(\"eslint:plugins\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nlet plugins = Object.create(null);\n\nconst PLUGIN_NAME_PREFIX = \"eslint-plugin-\",\n    NAMESPACE_REGEX = /^@.*\\//i;\n\n/**\n * Removes the prefix `eslint-plugin-` from a plugin name.\n * @param {string} pluginName The name of the plugin which may have the prefix.\n * @returns {string} The name of the plugin without prefix.\n */\nfunction removePrefix(pluginName) {\n    return pluginName.indexOf(PLUGIN_NAME_PREFIX) === 0 ? pluginName.substring(PLUGIN_NAME_PREFIX.length) : pluginName;\n}\n\n/**\n * Gets the scope (namespace) of a plugin.\n * @param {string} pluginName The name of the plugin which may have the prefix.\n * @returns {string} The name of the plugins namepace if it has one.\n */\nfunction getNamespace(pluginName) {\n    return pluginName.match(NAMESPACE_REGEX) ? pluginName.match(NAMESPACE_REGEX)[0] : \"\";\n}\n\n/**\n * Removes the namespace from a plugin name.\n * @param {string} pluginName The name of the plugin which may have the prefix.\n * @returns {string} The name of the plugin without the namespace.\n */\nfunction removeNamespace(pluginName) {\n    return pluginName.replace(NAMESPACE_REGEX, \"\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    removePrefix,\n    getNamespace,\n    removeNamespace,\n\n    /**\n     * Defines a plugin with a given name rather than loading from disk.\n     * @param {string} pluginName The name of the plugin to load.\n     * @param {Object} plugin The plugin object.\n     * @returns {void}\n     */\n    define(pluginName, plugin) {\n        const pluginNamespace = getNamespace(pluginName),\n            pluginNameWithoutNamespace = removeNamespace(pluginName),\n            pluginNameWithoutPrefix = removePrefix(pluginNameWithoutNamespace),\n            shortName = pluginNamespace + pluginNameWithoutPrefix;\n\n        // load up environments and rules\n        plugins[shortName] = plugin;\n        Environments.importPlugin(plugin, shortName);\n        Rules.importPlugin(plugin, shortName);\n\n        // load up environments and rules for the name that '@scope/' was omitted\n        // 3 lines below will be removed by 4.0.0\n        plugins[pluginNameWithoutPrefix] = plugin;\n        Environments.importPlugin(plugin, pluginNameWithoutPrefix);\n        Rules.importPlugin(plugin, pluginNameWithoutPrefix);\n    },\n\n    /**\n     * Gets a plugin with the given name.\n     * @param {string} pluginName The name of the plugin to retrieve.\n     * @returns {Object} The plugin or null if not loaded.\n     */\n    get(pluginName) {\n        return plugins[pluginName] || null;\n    },\n\n    /**\n     * Returns all plugins that are loaded.\n     * @returns {Object} The plugins cache.\n     */\n    getAll() {\n        return plugins;\n    },\n\n    /**\n     * Loads a plugin with the given name.\n     * @param {string} pluginName The name of the plugin to load.\n     * @returns {void}\n     * @throws {Error} If the plugin cannot be loaded.\n     */\n    load(pluginName) {\n        const pluginNamespace = getNamespace(pluginName),\n            pluginNameWithoutNamespace = removeNamespace(pluginName),\n            pluginNameWithoutPrefix = removePrefix(pluginNameWithoutNamespace),\n            shortName = pluginNamespace + pluginNameWithoutPrefix,\n            longName = pluginNamespace + PLUGIN_NAME_PREFIX + pluginNameWithoutPrefix;\n        let plugin = null;\n\n        if (pluginName.match(/\\s+/)) {\n            const whitespaceError = new Error(`Whitespace found in plugin name '${pluginName}'`);\n\n            whitespaceError.messageTemplate = \"whitespace-found\";\n            whitespaceError.messageData = {\n                pluginName: longName\n            };\n            throw whitespaceError;\n        }\n\n        if (!plugins[shortName]) {\n            try {\n                plugin = require(longName);\n            } catch (pluginLoadErr) {\n                try {\n\n                    // Check whether the plugin exists\n                    require.resolve(longName);\n                } catch (missingPluginErr) {\n\n                    // If the plugin can't be resolved, display the missing plugin error (usually a config or install error)\n                    debug(`Failed to load plugin ${longName}.`);\n                    missingPluginErr.message = `Failed to load plugin ${pluginName}: ${missingPluginErr.message}`;\n                    missingPluginErr.messageTemplate = \"plugin-missing\";\n                    missingPluginErr.messageData = {\n                        pluginName: longName\n                    };\n                    throw missingPluginErr;\n                }\n\n                // Otherwise, the plugin exists and is throwing on module load for some reason, so print the stack trace.\n                throw pluginLoadErr;\n            }\n\n            this.define(pluginName, plugin);\n        }\n    },\n\n    /**\n     * Loads all plugins from an array.\n     * @param {string[]} pluginNames An array of plugins names.\n     * @returns {void}\n     * @throws {Error} If a plugin cannot be loaded.\n     */\n    loadAll(pluginNames) {\n        pluginNames.forEach(this.load, this);\n    },\n\n    /**\n     * Resets plugin information. Use for tests only.\n     * @returns {void}\n     */\n    testReset() {\n        plugins = Object.create(null);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/module-resolver.js":"/**\n * @fileoverview Implements the Node.js require.resolve algorithm\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Module = require(\"module\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = {\n\n    /*\n     * module.paths is an array of paths to search for resolving things relative\n     * to this file. Module.globalPaths contains all of the special Node.js\n     * directories that can also be searched for modules.\n     *\n     * Need to check for existence of module.paths because Jest seems not to\n     * include it. See https://github.com/eslint/eslint/issues/5791.\n     */\n    lookupPaths: module.paths ? module.paths.concat(Module.globalPaths) : Module.globalPaths.concat()\n};\n\n/**\n * Resolves modules based on a set of options.\n */\nclass ModuleResolver {\n\n    /**\n     * Resolves modules based on a set of options.\n     * @param {Object} options The options for resolving modules.\n     * @param {string[]} options.lookupPaths An array of paths to include in the\n     *      lookup with the highest priority paths coming first.\n     */\n    constructor(options) {\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options || {});\n    }\n\n    /**\n     * Resolves the file location of a given module relative to the configured\n     * lookup paths.\n     * @param {string} name The module name to resolve.\n     * @param {string} extraLookupPath An extra path to look into for the module.\n     *      This path is used with the highest priority.\n     * @returns {string} The resolved file path for the module.\n     * @throws {Error} If the module cannot be resolved.\n     */\n    resolve(name, extraLookupPath) {\n\n        /*\n         * First, clone the lookup paths so we're not messing things up for\n         * subsequent calls to this function. Then, move the extraLookupPath to the\n         * top of the lookup paths list so it will be searched first.\n         */\n        const lookupPaths = this.options.lookupPaths.concat();\n\n        lookupPaths.unshift(extraLookupPath);\n\n        /**\n         * Module._findPath is an internal method to Node.js, then one they use to\n         * lookup file paths when require() is called. So, we are hooking into the\n         * exact same logic that Node.js uses.\n         */\n        const result = Module._findPath(name, lookupPaths);   // eslint-disable-line no-underscore-dangle\n\n        if (!result) {\n            throw new Error(`Cannot find module '${name}'`);\n        }\n\n        return result;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nmodule.exports = ModuleResolver;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/file-finder.js":"/**\n * @fileoverview Util class to find config files.\n * @author Aliaksei Shytkin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the entries for a directory. Including a try-catch may be detrimental to\n * function performance, so move it out here a separate function.\n * @param {string} directory The directory to search in.\n * @returns {string[]} The entries in the directory or an empty array on error.\n * @private\n */\nfunction getDirectoryEntries(directory) {\n    try {\n        return fs.readdirSync(directory);\n    } catch (ex) {\n        return [];\n    }\n}\n\n/**\n * Create a hash of filenames from a directory listing\n * @param {string[]} entries Array of directory entries.\n * @param {string} directory Path to a current directory.\n * @param {string[]} supportedConfigs List of support filenames.\n * @returns {Object} Hashmap of filenames\n */\nfunction normalizeDirectoryEntries(entries, directory, supportedConfigs) {\n    const fileHash = {};\n\n    entries.forEach(entry => {\n        if (supportedConfigs.indexOf(entry) >= 0) {\n            const resolvedEntry = path.resolve(directory, entry);\n\n            if (fs.statSync(resolvedEntry).isFile()) {\n                fileHash[entry] = resolvedEntry;\n            }\n        }\n    });\n    return fileHash;\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * FileFinder class\n */\nclass FileFinder {\n\n    /**\n     * @param {string[]} files The basename(s) of the file(s) to find.\n     * @param {stirng} cwd Current working directory\n     */\n    constructor(files, cwd) {\n        this.fileNames = Array.isArray(files) ? files : [files];\n        this.cwd = cwd || process.cwd();\n        this.cache = {};\n    }\n\n    /**\n     * Find all instances of files with the specified file names, in directory and\n     * parent directories. Cache the results.\n     * Does not check if a matching directory entry is a file.\n     * Searches for all the file names in this.fileNames.\n     * Is currently used by lib/config.js to find .eslintrc and package.json files.\n     * @param  {string} directory The directory to start the search from.\n     * @returns {string[]} The file paths found.\n     */\n    findAllInDirectoryAndParents(directory) {\n        const cache = this.cache;\n\n        if (directory) {\n            directory = path.resolve(this.cwd, directory);\n        } else {\n            directory = this.cwd;\n        }\n\n        if (cache.hasOwnProperty(directory)) {\n            return cache[directory];\n        }\n\n        const dirs = [];\n        const fileNames = this.fileNames;\n        let searched = 0;\n\n        do {\n            dirs[searched++] = directory;\n            cache[directory] = [];\n\n            const filesMap = normalizeDirectoryEntries(getDirectoryEntries(directory), directory, fileNames);\n\n            if (Object.keys(filesMap).length) {\n                for (let k = 0; k < fileNames.length; k++) {\n\n                    if (filesMap[fileNames[k]]) {\n                        const filePath = filesMap[fileNames[k]];\n\n                        // Add the file path to the cache of each directory searched.\n                        for (let j = 0; j < searched; j++) {\n                            cache[dirs[j]].push(filePath);\n                        }\n\n                        break;\n                    }\n                }\n            }\n            const child = directory;\n\n            // Assign parent directory to directory.\n            directory = path.dirname(directory);\n\n            if (directory === child) {\n                return cache[dirs[0]];\n            }\n        } while (!cache.hasOwnProperty(directory));\n\n        // Add what has been cached previously to the cache of each directory searched.\n        for (let i = 0; i < searched; i++) {\n            dirs.push.apply(cache[dirs[i]], cache[directory]);\n        }\n\n        return cache[dirs[0]];\n    }\n}\n\nmodule.exports = FileFinder;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/glob-util.js":"/**\n * @fileoverview Utilities for working with globs and the filesystem.\n * @author Ian VanSchooten\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    GlobSync = require(\"./glob\"),\n    shell = require(\"shelljs\"),\n\n    pathUtil = require(\"./path-util\"),\n    IgnoredPaths = require(\"../ignored-paths\");\n\nconst debug = require(\"debug\")(\"eslint:glob-util\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if a provided path is a directory and returns a glob string matching\n * all files under that directory if so, the path itself otherwise.\n *\n * Reason for this is that `glob` needs `/**` to collect all the files under a\n * directory where as our previous implementation without `glob` simply walked\n * a directory that is passed. So this is to maintain backwards compatibility.\n *\n * Also makes sure all path separators are POSIX style for `glob` compatibility.\n *\n * @param {Object}   [options]                    An options object\n * @param {string[]} [options.extensions=[\".js\"]] An array of accepted extensions\n * @param {string}   [options.cwd=process.cwd()]  The cwd to use to resolve relative pathnames\n * @returns {Function} A function that takes a pathname and returns a glob that\n *                     matches all files with the provided extensions if\n *                     pathname is a directory.\n */\nfunction processPath(options) {\n    const cwd = (options && options.cwd) || process.cwd();\n    let extensions = (options && options.extensions) || [\".js\"];\n\n    extensions = extensions.map(ext => ext.replace(/^\\./, \"\"));\n\n    let suffix = \"/**\";\n\n    if (extensions.length === 1) {\n        suffix += `/*.${extensions[0]}`;\n    } else {\n        suffix += `/*.{${extensions.join(\",\")}}`;\n    }\n\n    /**\n     * A function that converts a directory name to a glob pattern\n     *\n     * @param {string} pathname The directory path to be modified\n     * @returns {string} The glob path or the file path itself\n     * @private\n     */\n    return function(pathname) {\n        let newPath = pathname;\n        const resolvedPath = path.resolve(cwd, pathname);\n\n        if (shell.test(\"-d\", resolvedPath)) {\n            newPath = pathname.replace(/[/\\\\]$/, \"\") + suffix;\n        }\n\n        return pathUtil.convertPathToPosix(newPath);\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Resolves any directory patterns into glob-based patterns for easier handling.\n * @param   {string[]} patterns    File patterns (such as passed on the command line).\n * @param   {Object} options       An options object.\n * @returns {string[]} The equivalent glob patterns and filepath strings.\n */\nfunction resolveFileGlobPatterns(patterns, options) {\n\n    const processPathExtensions = processPath(options);\n\n    return patterns.filter(p => p.length).map(processPathExtensions);\n}\n\n/**\n * Build a list of absolute filesnames on which ESLint will act.\n * Ignored files are excluded from the results, as are duplicates.\n *\n * @param   {string[]} globPatterns            Glob patterns.\n * @param   {Object}   [options]               An options object.\n * @param   {string}   [options.cwd]           CWD (considered for relative filenames)\n * @param   {boolean}  [options.ignore]        False disables use of .eslintignore.\n * @param   {string}   [options.ignorePath]    The ignore file to use instead of .eslintignore.\n * @param   {string}   [options.ignorePattern] A pattern of files to ignore.\n * @returns {string[]} Resolved absolute filenames.\n */\nfunction listFilesToProcess(globPatterns, options) {\n    options = options || { ignore: true };\n    const files = [],\n        added = {};\n\n    const cwd = (options && options.cwd) || process.cwd();\n\n    /**\n     * Executes the linter on a file defined by the `filename`. Skips\n     * unsupported file extensions and any files that are already linted.\n     * @param {string} filename The file to be processed\n     * @param {boolean} shouldWarnIgnored Whether or not a report should be made if\n     *                                    the file is ignored\n     * @param {IgnoredPaths} ignoredPaths An instance of IgnoredPaths\n     * @returns {void}\n     */\n    function addFile(filename, shouldWarnIgnored, ignoredPaths) {\n        let ignored = false;\n        let isSilentlyIgnored;\n\n        if (ignoredPaths.contains(filename, \"default\")) {\n            ignored = (options.ignore !== false) && shouldWarnIgnored;\n            isSilentlyIgnored = !shouldWarnIgnored;\n        }\n\n        if (options.ignore !== false) {\n            if (ignoredPaths.contains(filename, \"custom\")) {\n                if (shouldWarnIgnored) {\n                    ignored = true;\n                } else {\n                    isSilentlyIgnored = true;\n                }\n            }\n        }\n\n        if (isSilentlyIgnored && !ignored) {\n            return;\n        }\n\n        if (added[filename]) {\n            return;\n        }\n        files.push({ filename, ignored });\n        added[filename] = true;\n    }\n\n    debug(\"Creating list of files to process.\");\n    globPatterns.forEach(pattern => {\n        const file = path.resolve(cwd, pattern);\n\n        if (shell.test(\"-f\", file)) {\n            const ignoredPaths = new IgnoredPaths(options);\n\n            addFile(fs.realpathSync(file), !shell.test(\"-d\", file), ignoredPaths);\n        } else {\n\n            // regex to find .hidden or /.hidden patterns, but not ./relative or ../relative\n            const globIncludesDotfiles = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/.test(pattern);\n\n            const ignoredPaths = new IgnoredPaths(Object.assign({}, options, { dotfiles: options.dotfiles || globIncludesDotfiles }));\n            const shouldIgnore = ignoredPaths.getIgnoredFoldersGlobChecker();\n            const globOptions = {\n                nodir: true,\n                dot: true,\n                cwd\n            };\n\n            new GlobSync(pattern, globOptions, shouldIgnore).found.forEach(globMatch => {\n                addFile(path.resolve(cwd, globMatch), false, ignoredPaths);\n            });\n        }\n    });\n\n    return files;\n}\n\nmodule.exports = {\n    resolveFileGlobPatterns,\n    listFilesToProcess\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/glob.js":"/**\n * @fileoverview An inherited `glob.GlobSync` to support .gitignore patterns.\n * @author Kael Zhang\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Sync = require(\"glob\").GlobSync,\n    util = require(\"util\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst IGNORE = Symbol(\"ignore\");\n\n/**\n * Subclass of `glob.GlobSync`\n * @param {string}     pattern      Pattern to be matched.\n * @param {Object}     options      `options` for `glob`\n * @param {function()} shouldIgnore Method to check whether a directory should be ignored.\n * @constructor\n */\nfunction GlobSync(pattern, options, shouldIgnore) {\n\n    /**\n     * We don't put this thing to argument `options` to avoid\n     * further problems, such as `options` validation.\n     *\n     * Use `Symbol` as much as possible to avoid confliction.\n     */\n    this[IGNORE] = shouldIgnore;\n\n    Sync.call(this, pattern, options);\n}\n\nutil.inherits(GlobSync, Sync);\n\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_readdir\", \"_mark\"] }] */\n\nGlobSync.prototype._readdir = function(abs, inGlobStar) {\n\n    /**\n     * `options.nodir` makes `options.mark` as `true`.\n     * Mark `abs` first\n     * to make sure `\"node_modules\"` will be ignored immediately with ignore pattern `\"node_modules/\"`.\n\n     * There is a built-in cache about marked `File.Stat` in `glob`, so that we could not worry about the extra invocation of `this._mark()`\n     */\n    const marked = this._mark(abs);\n\n    if (this[IGNORE](marked)) {\n        return null;\n    }\n\n    return Sync.prototype._readdir.call(this, abs, inGlobStar);\n};\n\n\nmodule.exports = GlobSync;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/source-code-fixer.js":"/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:text-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {SourceCode} sourceCode The source code to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceCode, messages) {\n\n    debug(\"Applying fixes\");\n\n    if (!sourceCode) {\n        debug(\"No source code to fix\");\n        return {\n            fixed: false,\n            messages,\n            output: \"\"\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = (sourceCode.hasBOM ? BOM : \"\"),\n        text = sourceCode.text;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    messages.forEach(problem => {\n        if (problem.hasOwnProperty(\"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            const fix = problem.fix;\n            const start = fix.range[0];\n            const end = fix.range[1];\n\n            // Remain it as a problem if it's overlapped or it's a negative range\n            if (lastPos >= start || start > end) {\n                remainingMessages.push(problem);\n                continue;\n            }\n\n            // Remove BOM.\n            if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n                output = \"\";\n            }\n\n            // Make output to this fix.\n            output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n            output += fix.text;\n            lastPos = end;\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: true,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/hash.js":"/**\n * @fileoverview Defining the hashing function in one place.\n * @author Michael Ficarra\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst murmur = require(\"imurmurhash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * hash the given string\n * @param  {string} str the string to hash\n * @returns {string}    the hash\n */\nfunction hash(str) {\n    return murmur(str).result().toString(36);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = hash;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/testers/rule-tester.js":"/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* global describe, it */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.add(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, global: {globals}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, global: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    assert = require(\"assert\"),\n    util = require(\"util\"),\n    validator = require(\"../config/config-validator\"),\n    validate = require(\"is-my-json-valid\"),\n    eslint = require(\"../eslint\"),\n    rules = require(\"../rules\"),\n    metaSchema = require(\"../../conf/json-schema-schema.json\"),\n    SourceCodeFixer = require(\"../util/source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\nlet defaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"args\",\n    \"errors\"\n];\n\nconst validateSchema = validate(metaSchema, { verbose: true });\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n *\n * @param {any} x - A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n *\n * @param {any} x - A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates a new instance of RuleTester.\n * @param {Object} [testerConfig] Optional, extra configuration for the tester\n * @constructor\n */\nfunction RuleTester(testerConfig) {\n\n    /**\n     * The configuration to use for this tester. Combination of the tester\n     * configuration and the default configuration.\n     * @type {Object}\n     */\n    this.testerConfig = lodash.merge(\n\n        // we have to clone because merge uses the first argument for recipient\n        lodash.cloneDeep(defaultConfig),\n        testerConfig\n    );\n\n    /**\n     * Rule definitions to define before tests.\n     * @type {Object}\n     */\n    this.rules = {};\n}\n\n/**\n * Set the configuration to use for all future tests\n * @param {Object} config the configuration to use.\n * @returns {void}\n */\nRuleTester.setDefaultConfig = function(config) {\n    if (typeof config !== \"object\") {\n        throw new Error(\"RuleTester.setDefaultConfig: config must be an object\");\n    }\n    defaultConfig = config;\n\n    // Make sure the rules object exists since it is assumed to exist later\n    defaultConfig.rules = defaultConfig.rules || {};\n};\n\n/**\n * Get the current configuration used for all tests\n * @returns {Object} the current configuration\n */\nRuleTester.getDefaultConfig = function() {\n    return defaultConfig;\n};\n\n/**\n * Reset the configuration to the initial configuration of the tester removing\n * any changes made until now.\n * @returns {void}\n */\nRuleTester.resetDefaultConfig = function() {\n    defaultConfig = lodash.cloneDeep(testerDefaultConfig);\n};\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\n\nRuleTester[DESCRIBE] = RuleTester[IT] = null;\n\n/**\n * This is `it` or `describe` if those don't exist.\n * @this {Mocha}\n * @param {string} text - The description of the test case.\n * @param {Function} method - The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction defaultHandler(text, method) {\n    return method.apply(this);\n}\n\n// If people use `mocha test.js --watch` command, `describe` and `it` function\n// instances are different for each execution. So this should get fresh instance\n// always.\nObject.defineProperties(RuleTester, {\n    describe: {\n        get() {\n            return (\n                RuleTester[DESCRIBE] ||\n                (typeof describe === \"function\" ? describe : defaultHandler)\n            );\n        },\n        set(value) {\n            RuleTester[DESCRIBE] = value;\n        },\n        configurable: true,\n        enumerable: true\n    },\n    it: {\n        get() {\n            return (\n                RuleTester[IT] ||\n                (typeof it === \"function\" ? it : defaultHandler)\n            );\n        },\n        set(value) {\n            RuleTester[IT] = value;\n        },\n        configurable: true,\n        enumerable: true\n    }\n});\n\nRuleTester.prototype = {\n\n    /**\n     * Define a rule for one particular run of tests.\n     * @param {string} name The name of the rule to define.\n     * @param {Function} rule The rule definition.\n     * @returns {void}\n     */\n    defineRule(name, rule) {\n        this.rules[name] = rule;\n    },\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Function} rule The rule to test.\n     * @param {Object} test The collection of tests to run.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            result = {};\n\n        if (lodash.isNil(test) || typeof test !== \"object\") {\n            throw new Error(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (lodash.isNil(test[scenarioType])) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n        /* eslint-disable no-shadow */\n\n        /**\n         * Run the rule for the given item\n         * @param {string} ruleName name of the rule\n         * @param {string|Object} item Item to run the rule against\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(ruleName, item) {\n            let config = lodash.cloneDeep(testerConfig),\n                code, filename, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                // Assumes everything on the item is a config except for the\n                // parameters used by this tester\n                const itemConfig = lodash.omit(item, RuleTesterParameters);\n\n                // Create the config object from the tester config and this item\n                // specific configurations.\n                config = lodash.merge(\n                    config,\n                    itemConfig\n                );\n            }\n\n            if (item.filename) {\n                filename = item.filename;\n            }\n\n            if (item.options) {\n                const options = item.options.concat();\n\n                options.unshift(1);\n                config.rules[ruleName] = options;\n            } else {\n                config.rules[ruleName] = 1;\n            }\n\n            eslint.defineRule(ruleName, rule);\n\n            const schema = validator.getRuleOptionsSchema(ruleName);\n\n            if (schema) {\n                validateSchema(schema);\n\n                if (validateSchema.errors) {\n                    throw new Error([\n                        `Schema for rule ${ruleName} is invalid:`\n                    ].concat(validateSchema.errors.map(error => `\\t${error.field}: ${error.message}`)).join(\"\\n\"));\n                }\n            }\n\n            validator.validate(config, \"rule-tester\");\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            eslint.reset();\n\n            eslint.on(\"Program\", node => {\n                beforeAST = cloneDeeplyExcludesParent(node);\n            });\n\n            eslint.on(\"Program:exit\", node => {\n                afterAST = node;\n            });\n\n            // Freezes rule-context properties.\n            const originalGet = rules.get;\n\n            try {\n                rules.get = function(ruleId) {\n                    const rule = originalGet(ruleId);\n\n                    if (typeof rule === \"function\") {\n                        return function(context) {\n                            Object.freeze(context);\n                            freezeDeeply(context.options);\n                            freezeDeeply(context.settings);\n                            freezeDeeply(context.parserOptions);\n\n                            return rule(context);\n                        };\n                    }\n                    return {\n                        meta: rule.meta,\n                        create(context) {\n                            Object.freeze(context);\n                            freezeDeeply(context.options);\n                            freezeDeeply(context.settings);\n                            freezeDeeply(context.parserOptions);\n\n                            return rule.create(context);\n                        }\n                    };\n\n                };\n\n                return {\n                    messages: eslint.verify(code, config, filename, true),\n                    beforeAST,\n                    afterAST: cloneDeeplyExcludesParent(afterAST)\n                };\n            } finally {\n                rules.get = originalGet;\n            }\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!lodash.isEqual(beforeAST, afterAST)) {\n\n                // Not using directly to avoid performance problem in node 6.1.0. See #6111\n                assert.deepEqual(beforeAST, afterAST, \"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string} ruleName name of the rule\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(ruleName, item) {\n            const result = runRuleForItem(ruleName, item);\n            const messages = result.messages;\n\n            assert.equal(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                        messages.length, util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.equal(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string} ruleName name of the rule\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(ruleName, item) {\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            const result = runRuleForItem(ruleName, item);\n            const messages = result.messages;\n\n\n\n            if (typeof item.errors === \"number\") {\n                assert.equal(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n            } else {\n                assert.equal(messages.length, item.errors.length,\n                    util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    assert.ok(!(\"fatal\" in messages[i]), `A fatal parsing error occurred: ${messages[i].message}`);\n                    assert.equal(messages[i].ruleId, ruleName, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof item.errors[i] === \"string\" || item.errors[i] instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(messages[i].message, item.errors[i]);\n                    } else if (typeof item.errors[i] === \"object\") {\n\n                        /*\n                         * Error object.\n                         * This may have a message, node type, line, and/or\n                         * column.\n                         */\n                        if (item.errors[i].message) {\n                            assertMessageMatches(messages[i].message, item.errors[i].message);\n                        }\n\n                        if (item.errors[i].type) {\n                            assert.equal(messages[i].nodeType, item.errors[i].type, `Error type should be ${item.errors[i].type}, found ${messages[i].nodeType}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"line\")) {\n                            assert.equal(messages[i].line, item.errors[i].line, `Error line should be ${item.errors[i].line}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"column\")) {\n                            assert.equal(messages[i].column, item.errors[i].column, `Error column should be ${item.errors[i].column}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"endLine\")) {\n                            assert.equal(messages[i].endLine, item.errors[i].endLine, `Error endLine should be ${item.errors[i].endLine}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"endColumn\")) {\n                            assert.equal(messages[i].endColumn, item.errors[i].endColumn, `Error endColumn should be ${item.errors[i].endColumn}`);\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(messages[i], null, \"Error should be a string, object, or RegExp.\");\n                    }\n                }\n            }\n\n            if (item.hasOwnProperty(\"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        messages.filter(message => message.fix).length,\n                        0,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    const fixResult = SourceCodeFixer.applyFixes(eslint.getSourceCode(), messages);\n\n                    assert.equal(fixResult.output, item.output, \"Output is incorrect.\");\n                }\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         */\n        RuleTester.describe(ruleName, () => {\n            RuleTester.describe(\"valid\", () => {\n                test.valid.forEach(valid => {\n                    RuleTester.it(typeof valid === \"object\" ? valid.code : valid, () => {\n                        eslint.defineRules(this.rules);\n                        testValidTemplate(ruleName, valid);\n                    });\n                });\n            });\n\n            RuleTester.describe(\"invalid\", () => {\n                test.invalid.forEach(invalid => {\n                    RuleTester.it(invalid.code, () => {\n                        eslint.defineRules(this.rules);\n                        testInvalidTemplate(ruleName, invalid);\n                    });\n                });\n            });\n        });\n\n        return result.suite;\n    }\n};\n\n\nmodule.exports = RuleTester;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/bin/eslint.js":"#!/usr/bin/env node\n\n/**\n * @fileoverview Main CLI that is run via the eslint command.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-console:off */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst useStdIn = (process.argv.indexOf(\"--stdin\") > -1),\n    init = (process.argv.indexOf(\"--init\") > -1),\n    debug = (process.argv.indexOf(\"--debug\") > -1);\n\n// must do this initialization *before* other requires in order to work\nif (debug) {\n    require(\"debug\").enable(\"eslint:*,-eslint:code-path\");\n}\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// now we can safely include the other modules that use debug\nconst concat = require(\"concat-stream\"),\n    cli = require(\"../lib/cli\"),\n    path = require(\"path\"),\n    fs = require(\"fs\");\n\n//------------------------------------------------------------------------------\n// Execution\n//------------------------------------------------------------------------------\n\nprocess.once(\"uncaughtException\", err => {\n\n    // lazy load\n    const lodash = require(\"lodash\");\n\n    if (typeof err.messageTemplate === \"string\" && err.messageTemplate.length > 0) {\n        const template = lodash.template(fs.readFileSync(path.resolve(__dirname, `../messages/${err.messageTemplate}.txt`), \"utf-8\"));\n\n        console.log(\"\\nOops! Something went wrong! :(\");\n        console.log(`\\n${template(err.messageData || {})}`);\n    } else {\n        console.log(err.message);\n        console.log(err.stack);\n    }\n\n    process.exitCode = 1;\n});\n\nif (useStdIn) {\n    process.stdin.pipe(concat({ encoding: \"string\" }, text => {\n        process.exitCode = cli.execute(process.argv, text);\n    }));\n} else if (init) {\n    const configInit = require(\"../lib/config/config-initializer\");\n\n    configInit.initializeConfig(err => {\n        if (err) {\n            process.exitCode = 1;\n            console.error(err.message);\n            console.error(err.stack);\n        } else {\n            process.exitCode = 0;\n        }\n    });\n} else {\n    process.exitCode = cli.execute(process.argv);\n}\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/cli.js":"/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    shell = require(\"shelljs\"),\n    options = require(\"./options\"),\n    CLIEngine = require(\"./cli-engine\"),\n    mkdirp = require(\"mkdirp\"),\n    log = require(\"./logging\");\n\nconst debug = require(\"debug\")(\"eslint:cli\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Translates the CLI options into the options expected by the CLIEngine.\n * @param {Object} cliOptions The CLI options to translate.\n * @returns {CLIEngineOptions} The options object for the CLIEngine.\n * @private\n */\nfunction translateOptions(cliOptions) {\n    return {\n        envs: cliOptions.env,\n        extensions: cliOptions.ext,\n        rules: cliOptions.rule,\n        plugins: cliOptions.plugin,\n        globals: cliOptions.global,\n        ignore: cliOptions.ignore,\n        ignorePath: cliOptions.ignorePath,\n        ignorePattern: cliOptions.ignorePattern,\n        configFile: cliOptions.config,\n        rulePaths: cliOptions.rulesdir,\n        useEslintrc: cliOptions.eslintrc,\n        parser: cliOptions.parser,\n        parserOptions: cliOptions.parserOptions,\n        cache: cliOptions.cache,\n        cacheFile: cliOptions.cacheFile,\n        cacheLocation: cliOptions.cacheLocation,\n        fix: cliOptions.fix,\n        allowInlineConfig: cliOptions.inlineConfig\n    };\n}\n\n/**\n * Outputs the results of the linting.\n * @param {CLIEngine} engine The CLIEngine to use.\n * @param {LintResult[]} results The results to print.\n * @param {string} format The name of the formatter to use or the path to the formatter.\n * @param {string} outputFile The path for the output file.\n * @returns {boolean} True if the printing succeeds, false if not.\n * @private\n */\nfunction printResults(engine, results, format, outputFile) {\n    let formatter;\n\n    try {\n        formatter = engine.getFormatter(format);\n    } catch (e) {\n        log.error(e.message);\n        return false;\n    }\n\n    const output = formatter(results);\n\n    if (output) {\n        if (outputFile) {\n            const filePath = path.resolve(process.cwd(), outputFile);\n\n            if (shell.test(\"-d\", filePath)) {\n                log.error(\"Cannot write to output file path, it is a directory: %s\", outputFile);\n                return false;\n            }\n\n            try {\n                mkdirp.sync(path.dirname(filePath));\n                fs.writeFileSync(filePath, output);\n            } catch (ex) {\n                log.error(\"There was a problem writing the output file:\\n%s\", ex);\n                return false;\n            }\n        } else {\n            log.info(output);\n        }\n    }\n\n    return true;\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as\n * for other Node.js programs to effectively run the CLI.\n */\nconst cli = {\n\n    /**\n     * Executes the CLI based on an array of arguments that is passed in.\n     * @param {string|Array|Object} args The arguments to process.\n     * @param {string} [text] The text to lint (used for TTY).\n     * @returns {int} The exit code for the operation.\n     */\n    execute(args, text) {\n\n        let currentOptions;\n\n        try {\n            currentOptions = options.parse(args);\n        } catch (error) {\n            log.error(error.message);\n            return 1;\n        }\n\n        const files = currentOptions._;\n\n        if (currentOptions.version) { // version from package.json\n\n            log.info(`v${require(\"../package.json\").version}`);\n\n        } else if (currentOptions.printConfig) {\n            if (files.length) {\n                log.error(\"The --print-config option must be used with exactly one file name.\");\n                return 1;\n            } else if (text) {\n                log.error(\"The --print-config option is not available for piped-in code.\");\n                return 1;\n            }\n\n            const engine = new CLIEngine(translateOptions(currentOptions));\n\n            const fileConfig = engine.getConfigForFile(currentOptions.printConfig);\n\n            log.info(JSON.stringify(fileConfig, null, \"  \"));\n            return 0;\n        } else if (currentOptions.help || (!files.length && !text)) {\n\n            log.info(options.generateHelp());\n\n        } else {\n\n            debug(`Running on ${text ? \"text\" : \"files\"}`);\n\n            // disable --fix for piped-in code until we know how to do it correctly\n            if (text && currentOptions.fix) {\n                log.error(\"The --fix option is not available for piped-in code.\");\n                return 1;\n            }\n\n            const engine = new CLIEngine(translateOptions(currentOptions));\n\n            const report = text ? engine.executeOnText(text, currentOptions.stdinFilename, true) : engine.executeOnFiles(files);\n\n            if (currentOptions.fix) {\n                debug(\"Fix mode enabled - applying fixes\");\n                CLIEngine.outputFixes(report);\n            }\n\n            if (currentOptions.quiet) {\n                debug(\"Quiet mode enabled - filtering out warnings\");\n                report.results = CLIEngine.getErrorResults(report.results);\n            }\n\n            if (printResults(engine, report.results, currentOptions.format, currentOptions.outputFile)) {\n                const tooManyWarnings = currentOptions.maxWarnings >= 0 && report.warningCount > currentOptions.maxWarnings;\n\n                if (!report.errorCount && tooManyWarnings) {\n                    log.error(\"ESLint found too many warnings (maximum: %s).\", currentOptions.maxWarnings);\n                }\n\n                return (report.errorCount || tooManyWarnings) ? 1 : 0;\n            }\n            return 1;\n\n\n        }\n\n        return 0;\n    }\n};\n\nmodule.exports = cli;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/options.js":"/**\n * @fileoverview Options configuration for optionator.\n * @author George Zahariev\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst optionator = require(\"optionator\");\n\n//------------------------------------------------------------------------------\n// Initialization and Public Interface\n//------------------------------------------------------------------------------\n\n// exports \"parse(args)\", \"generateHelp()\", and \"generateHelpForOption(optionName)\"\nmodule.exports = optionator({\n    prepend: \"eslint [options] file.js [file.js] [dir]\",\n    defaults: {\n        concatRepeatedArrays: true,\n        mergeRepeatedObjects: true\n    },\n    options: [\n        {\n            heading: \"Basic configuration\"\n        },\n        {\n            option: \"config\",\n            alias: \"c\",\n            type: \"path::String\",\n            description: \"Use configuration from this file or shareable config\"\n        },\n        {\n            option: \"eslintrc\",\n            type: \"Boolean\",\n            default: \"true\",\n            description: \"Disable use of configuration from .eslintrc\"\n        },\n        {\n            option: \"env\",\n            type: \"[String]\",\n            description: \"Specify environments\"\n        },\n        {\n            option: \"ext\",\n            type: \"[String]\",\n            default: \".js\",\n            description: \"Specify JavaScript file extensions\"\n        },\n        {\n            option: \"global\",\n            type: \"[String]\",\n            description: \"Define global variables\"\n        },\n        {\n            option: \"parser\",\n            type: \"String\",\n            description: \"Specify the parser to be used\"\n        },\n        {\n            option: \"parser-options\",\n            type: \"Object\",\n            description: \"Specify parser options\"\n        },\n        {\n            heading: \"Caching\"\n        },\n        {\n            option: \"cache\",\n            type: \"Boolean\",\n            default: \"false\",\n            description: \"Only check changed files\"\n        },\n        {\n            option: \"cache-file\",\n            type: \"path::String\",\n            default: \".eslintcache\",\n            description: \"Path to the cache file. Deprecated: use --cache-location\"\n        },\n        {\n            option: \"cache-location\",\n            type: \"path::String\",\n            description: \"Path to the cache file or directory\"\n        },\n        {\n            heading: \"Specifying rules and plugins\"\n        },\n        {\n            option: \"rulesdir\",\n            type: \"[path::String]\",\n            description: \"Use additional rules from this directory\"\n        },\n        {\n            option: \"plugin\",\n            type: \"[String]\",\n            description: \"Specify plugins\"\n        },\n        {\n            option: \"rule\",\n            type: \"Object\",\n            description: \"Specify rules\"\n        },\n        {\n            heading: \"Ignoring files\"\n        },\n        {\n            option: \"ignore-path\",\n            type: \"path::String\",\n            description: \"Specify path of ignore file\"\n        },\n        {\n            option: \"ignore\",\n            type: \"Boolean\",\n            default: \"true\",\n            description: \"Disable use of ignore files and patterns\"\n        },\n        {\n            option: \"ignore-pattern\",\n            type: \"[String]\",\n            description: \"Pattern of files to ignore (in addition to those in .eslintignore)\",\n            concatRepeatedArrays: [true, {\n                oneValuePerFlag: true\n            }]\n        },\n        {\n            heading: \"Using stdin\"\n        },\n        {\n            option: \"stdin\",\n            type: \"Boolean\",\n            default: \"false\",\n            description: \"Lint code provided on <STDIN>\"\n        },\n        {\n            option: \"stdin-filename\",\n            type: \"String\",\n            description: \"Specify filename to process STDIN as\"\n        },\n        {\n            heading: \"Handling warnings\"\n        },\n        {\n            option: \"quiet\",\n            type: \"Boolean\",\n            default: \"false\",\n            description: \"Report errors only\"\n        },\n        {\n            option: \"max-warnings\",\n            type: \"Int\",\n            default: \"-1\",\n            description: \"Number of warnings to trigger nonzero exit code\"\n        },\n        {\n            heading: \"Output\"\n        },\n        {\n            option: \"output-file\",\n            alias: \"o\",\n            type: \"path::String\",\n            description: \"Specify file to write report to\"\n        },\n        {\n            option: \"format\",\n            alias: \"f\",\n            type: \"String\",\n            default: \"stylish\",\n            description: \"Use a specific output format\"\n        },\n        {\n            option: \"color\",\n            type: \"Boolean\",\n            alias: \"no-color\",\n            description: \"Force enabling/disabling of color\"\n        },\n        {\n            heading: \"Miscellaneous\"\n        },\n        {\n            option: \"init\",\n            type: \"Boolean\",\n            default: \"false\",\n            description: \"Run config initialization wizard\"\n        },\n        {\n            option: \"fix\",\n            type: \"Boolean\",\n            default: false,\n            description: \"Automatically fix problems\"\n        },\n        {\n            option: \"debug\",\n            type: \"Boolean\",\n            default: false,\n            description: \"Output debugging information\"\n        },\n        {\n            option: \"help\",\n            alias: \"h\",\n            type: \"Boolean\",\n            description: \"Show help\"\n        },\n        {\n            option: \"version\",\n            alias: \"v\",\n            type: \"Boolean\",\n            description: \"Output the version number\"\n        },\n        {\n            option: \"inline-config\",\n            type: \"Boolean\",\n            default: \"true\",\n            description: \"Prevent comments from changing config or rules\"\n        },\n        {\n            option: \"print-config\",\n            type: \"path::String\",\n            description: \"Print the configuration for the given file\"\n        }\n    ]\n});\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/logging.js":"/**\n * @fileoverview Handle logging for ESLint\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n/* eslint no-console: \"off\" */\n\n/* istanbul ignore next */\nmodule.exports = {\n\n    /**\n     * Cover for console.log\n     * @returns {void}\n     */\n    info() {\n        console.log.apply(console, Array.prototype.slice.call(arguments));\n    },\n\n    /**\n     * Cover for console.error\n     * @returns {void}\n     */\n    error() {\n        console.error.apply(console, Array.prototype.slice.call(arguments));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/conf/eslint-all.js":"/**\n * @fileoverview Config to enable all rules.\n * @author Robert Fletcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst load = require(\"../lib/load-rules\"),\n    rules = require(\"../lib/rules\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst enabledRules = Object.keys(load()).reduce((result, ruleId) => {\n    if (!rules.get(ruleId).meta.deprecated) {\n        result[ruleId] = \"error\";\n    }\n    return result;\n}, {});\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = { rules: enabledRules };\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/accessor-pairs.js":"/**\n * @fileoverview Rule to flag wrapping non-iife in parens\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node - A node to check.\n * @param {number} index - An expected index of the node in arguments.\n * @param {string} object - An expected name of the object of the method.\n * @param {string} property - An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    const parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        parent.callee.type === \"MemberExpression\" &&\n        parent.callee.computed === false &&\n        isIdentifier(parent.callee.object, object) &&\n        isIdentifier(parent.callee.property, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    node = node.parent.parent;\n\n    return node.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(node, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(node, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce getter and setter pairs in objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\"\n                },\n                setWithoutGet: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n    create(context) {\n        const config = context.options[0] || {};\n        const checkGetWithoutSet = config.getWithoutSet === true;\n        const checkSetWithoutGet = config.setWithoutGet !== false;\n\n        /**\n         * Checks a object expression to see if it has setter and getter both present or none.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLonelySetGet(node) {\n            let isSetPresent = false;\n            let isGetPresent = false;\n            const isDescriptor = isPropertyDescriptor(node);\n\n            for (let i = 0, end = node.properties.length; i < end; i++) {\n                const property = node.properties[i];\n\n                let propToCheck = \"\";\n\n                if (property.kind === \"init\") {\n                    if (isDescriptor && !property.computed) {\n                        propToCheck = property.key.name;\n                    }\n                } else {\n                    propToCheck = property.kind;\n                }\n\n                switch (propToCheck) {\n                    case \"set\":\n                        isSetPresent = true;\n                        break;\n\n                    case \"get\":\n                        isGetPresent = true;\n                        break;\n\n                    default:\n\n                        // Do nothing\n                }\n\n                if (isSetPresent && isGetPresent) {\n                    break;\n                }\n            }\n\n            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {\n                context.report({ node, message: \"Getter is not present.\" });\n            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {\n                context.report({ node, message: \"Setter is not present.\" });\n            }\n        }\n\n        return {\n            ObjectExpression(node) {\n                if (checkSetWithoutGet || checkGetWithoutSet) {\n                    checkLonelySetGet(node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/array-bracket-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside of array brackets.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside array brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    singleValue: {\n                        type: \"boolean\"\n                    },\n                    objectsInArrays: {\n                        type: \"boolean\"\n                    },\n                    arraysInArrays: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option - The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            singleElementException: isOptionSet(\"singleValue\"),\n            objectsInArraysException: isOptionSet(\"objectsInArrays\"),\n            arraysInArraysException: isOptionSet(\"arraysInArrays\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Reports that there shouldn't be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    const nextToken = sourceCode.getTokenAfter(token);\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(token);\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Determines if a node is an object type\n        * @param {ASTNode} node - The node to check.\n        * @returns {boolean} Whether or not the node is an object type.\n        */\n        function isObjectType(node) {\n            return node && (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\");\n        }\n\n        /**\n        * Determines if a node is an array type\n        * @param {ASTNode} node - The node to check.\n        * @returns {boolean} Whether or not the node is an array type.\n        */\n        function isArrayType(node) {\n            return node && (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n        }\n\n        /**\n         * Validates the spacing around array brackets\n         * @param {ASTNode} node - The node we're checking for spacing\n         * @returns {void}\n         */\n        function validateArraySpacing(node) {\n            if (options.spaced && node.elements.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                second = sourceCode.getFirstToken(node, 1),\n                last = node.typeAnnotation\n                    ? sourceCode.getTokenBefore(node.typeAnnotation)\n                    : sourceCode.getLastToken(node),\n                penultimate = sourceCode.getTokenBefore(last),\n                firstElement = node.elements[0],\n                lastElement = node.elements[node.elements.length - 1];\n\n            const openingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(firstElement) ||\n                options.arraysInArraysException && isArrayType(firstElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            const closingBracketMustBeSpaced =\n                options.objectsInArraysException && isObjectType(lastElement) ||\n                options.arraysInArraysException && isArrayType(lastElement) ||\n                options.singleElementException && node.elements.length === 1\n                    ? !options.spaced : options.spaced;\n\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {\n                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrayPattern: validateArraySpacing,\n            ArrayExpression: validateArraySpacing\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/array-callback-return.js":"/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;\n\n/**\n * Checks a given code path segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * - ArrowFunctionExpression -> `=>` token.\n *\n * @param {ASTNode} node - A function node to get.\n * @param {SourceCode} sourceCode - A source code to get tokens.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getLocation(node, sourceCode) {\n    if (node.type === \"ArrowFunctionExpression\") {\n        return sourceCode.getTokenBefore(node.body);\n    }\n    return node.id || node;\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isTargetMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || \"\")\n    );\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method.\n *\n * @param {ASTNode} node - A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {boolean} `true` if the node is the callback of an array method.\n */\nfunction isCallbackOfArrayMethod(node) {\n    while (node) {\n        const parent = node.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                node = parent;\n                break;\n\n            // If the upper function is IIFE, checks the destination of the return value.\n            // e.g.\n            //   foo.every((function() {\n            //     // setup...\n            //     return function callback() { ... };\n            //   })());\n            case \"ReturnStatement\": {\n                const func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return false;\n                }\n                node = func.parent;\n                break;\n            }\n\n            // e.g.\n            //   Array.from([], function() {});\n            //   list.every(function() {});\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === node\n                    );\n                }\n                if (isTargetMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === node\n                    );\n                }\n                return false;\n\n            // Otherwise this node is not target.\n            default:\n                return false;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false,\n            node: null\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node,\n                    loc: getLocation(node, context.getSourceCode()).loc.start,\n                    message: funcInfo.hasReturn\n                        ? \"Expected to return a value at the end of {{name}}.\"\n                        : \"Expected to return a value in {{name}}.\",\n                    data: {\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\n                    }\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        TARGET_NODE_TYPE.test(node.type) &&\n                        node.body.type === \"BlockStatement\" &&\n                        isCallbackOfArrayMethod(node) &&\n                        !node.async &&\n                        !node.generator,\n                    node\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    if (!node.argument) {\n                        context.report({\n                            node,\n                            message: \"{{name}} expected a return value.\",\n                            data: {\n                                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n                            }\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/arrow-body-style.js":"/**\n * @fileoverview Rule to require braces in arrow function body.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require braces around arrow function bodies\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options;\n        const always = options[0] === \"always\";\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\n        const never = options[0] === \"never\";\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether a arrow function body needs braces\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function validate(node) {\n            const arrowBody = node.body;\n\n            if (arrowBody.type === \"BlockStatement\") {\n                const blockBody = arrowBody.body;\n\n                if (blockBody.length !== 1 && !never) {\n                    return;\n                }\n\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n                    return;\n                }\n\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        message: \"Unexpected block statement surrounding arrow body.\",\n                        fix(fixer) {\n                            if (blockBody.length !== 1 || blockBody[0].type !== \"ReturnStatement\" || !blockBody[0].argument) {\n                                return null;\n                            }\n\n                            const sourceText = sourceCode.getText();\n                            const returnKeyword = sourceCode.getFirstToken(blockBody[0]);\n                            const firstValueToken = sourceCode.getTokenAfter(returnKeyword);\n                            let lastValueToken = sourceCode.getLastToken(blockBody[0]);\n\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\n\n                                /* The last token of the returned value is the last token of the ReturnExpression (if\n                                 * the ReturnExpression has no semicolon), or the second-to-last token (if the ReturnExpression\n                                 * has a semicolon).\n                                 */\n                                lastValueToken = sourceCode.getTokenBefore(lastValueToken);\n                            }\n\n                            const tokenAfterArrowBody = sourceCode.getTokenAfter(arrowBody);\n\n                            if (tokenAfterArrowBody && tokenAfterArrowBody.type === \"Punctuator\" && /^[([/`+-]/.test(tokenAfterArrowBody.value)) {\n\n                                // Don't do a fix if the next token would cause ASI issues when preceded by the returned value.\n                                return null;\n                            }\n\n                            const textBeforeReturn = sourceText.slice(arrowBody.range[0] + 1, returnKeyword.range[0]);\n                            const textBetweenReturnAndValue = sourceText.slice(returnKeyword.range[1], firstValueToken.range[0]);\n                            const rawReturnValueText = sourceText.slice(firstValueToken.range[0], lastValueToken.range[1]);\n                            const returnValueText = astUtils.isOpeningBraceToken(firstValueToken) ? `(${rawReturnValueText})` : rawReturnValueText;\n                            const textAfterValue = sourceText.slice(lastValueToken.range[1], blockBody[0].range[1] - 1);\n                            const textAfterReturnStatement = sourceText.slice(blockBody[0].range[1], arrowBody.range[1] - 1);\n\n                            /*\n                             * For fixes that only contain spaces around the return value, remove the extra spaces.\n                             * This avoids ugly fixes that end up with extra spaces after the arrow, e.g. `() =>   0 ;`\n                             */\n                            return fixer.replaceText(\n                                arrowBody,\n                                (textBeforeReturn + textBetweenReturnAndValue).replace(/^\\s*$/, \"\") + returnValueText + (textAfterValue + textAfterReturnStatement).replace(/^\\s*$/, \"\")\n                            );\n                        }\n                    });\n                }\n            } else {\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\n                    context.report({\n                        node,\n                        loc: arrowBody.loc.start,\n                        message: \"Expected block statement surrounding arrow body.\",\n                        fix(fixer) {\n                            const lastTokenBeforeBody = sourceCode.getLastTokenBetween(sourceCode.getFirstToken(node), arrowBody, astUtils.isNotOpeningParenToken);\n                            const firstBodyToken = sourceCode.getTokenAfter(lastTokenBeforeBody);\n\n                            return fixer.replaceTextRange(\n                                [firstBodyToken.range[0], node.range[1]],\n                                `{return ${sourceCode.getText().slice(firstBodyToken.range[0], node.range[1])}}`\n                            );\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: validate\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/arrow-parens.js":"/**\n * @fileoverview Rule to require parens in arrow function arguments.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses around arrow function arguments\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    requireForBlockBody: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const message = \"Expected parentheses around arrow function argument.\";\n        const asNeededMessage = \"Unexpected parentheses around single function argument.\";\n        const asNeeded = context.options[0] === \"as-needed\";\n        const requireForBlockBodyMessage = \"Unexpected parentheses around single function argument having a body with no curly braces\";\n        const requireForBlockBodyNoParensMessage = \"Expected parentheses around arrow function argument having a body with curly braces.\";\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n\n        const sourceCode = context.getSourceCode();\n\n\n        /**\n         * Determines whether a arrow function argument end with `)`\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function parens(node) {\n            const token = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n\n            // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n            if (\n                requireForBlockBody &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                node.body.type !== \"BlockStatement\" &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(token)) {\n                    context.report({\n                        node,\n                        message: requireForBlockBodyMessage,\n                        fix(fixer) {\n                            const paramToken = context.getTokenAfter(token);\n                            const closingParenToken = context.getTokenAfter(paramToken);\n\n                            return fixer.replaceTextRange([\n                                token.range[0],\n                                closingParenToken.range[1]\n                            ], paramToken.value);\n                        }\n                    });\n                }\n                return;\n            }\n\n            if (\n                requireForBlockBody &&\n                node.body.type === \"BlockStatement\"\n            ) {\n                if (!astUtils.isOpeningParenToken(token)) {\n                    context.report({\n                        node,\n                        message: requireForBlockBodyNoParensMessage,\n                        fix(fixer) {\n                            return fixer.replaceText(token, `(${token.value})`);\n                        }\n                    });\n                }\n                return;\n            }\n\n            // \"as-needed\": x => x\n            if (asNeeded &&\n                node.params.length === 1 &&\n                node.params[0].type === \"Identifier\" &&\n                !node.params[0].typeAnnotation &&\n                !node.returnType\n            ) {\n                if (astUtils.isOpeningParenToken(token)) {\n                    context.report({\n                        node,\n                        message: asNeededMessage,\n                        fix(fixer) {\n                            const paramToken = context.getTokenAfter(token);\n                            const closingParenToken = context.getTokenAfter(paramToken);\n\n                            return fixer.replaceTextRange([\n                                token.range[0],\n                                closingParenToken.range[1]\n                            ], paramToken.value);\n                        }\n                    });\n                }\n                return;\n            }\n\n            if (token.type === \"Identifier\") {\n                const after = sourceCode.getTokenAfter(token);\n\n                // (x) => x\n                if (after.value !== \")\") {\n                    context.report({\n                        node,\n                        message,\n                        fix(fixer) {\n                            return fixer.replaceText(token, `(${token.value})`);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: parens\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/arrow-spacing.js":"/**\n * @fileoverview Rule to define spacing before/after arrow function's arrow.\n * @author Jxck\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after the arrow in arrow functions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // merge rules with default\n        const rule = { before: true, after: true },\n            option = context.options[0] || {};\n\n        rule.before = option.before !== false;\n        rule.after = option.after !== false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Get tokens of arrow(`=>`) and before/after arrow.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {Object} Tokens of arrow and before/after arrow.\n         */\n        function getTokens(node) {\n            const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);\n\n            return {\n                before: sourceCode.getTokenBefore(arrow),\n                arrow,\n                after: sourceCode.getTokenAfter(arrow)\n            };\n        }\n\n        /**\n         * Count spaces before/after arrow(`=>`) token.\n         * @param {Object} tokens Tokens before/after arrow.\n         * @returns {Object} count of space before/after arrow.\n         */\n        function countSpaces(tokens) {\n            const before = tokens.arrow.range[0] - tokens.before.range[1];\n            const after = tokens.after.range[0] - tokens.arrow.range[1];\n\n            return { before, after };\n        }\n\n        /**\n         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.\n         * if before/after value is `true`, there should be space(s).\n         * if before/after value is `false`, there should be no space.\n         * @param {ASTNode} node The arrow function node.\n         * @returns {void}\n         */\n        function spaces(node) {\n            const tokens = getTokens(node);\n            const countSpace = countSpaces(tokens);\n\n            if (rule.before) {\n\n                // should be space(s) before arrow\n                if (countSpace.before === 0) {\n                    context.report({\n                        node: tokens.before,\n                        message: \"Missing space before =>.\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space before arrow\n                if (countSpace.before > 0) {\n                    context.report({\n                        node: tokens.before,\n                        message: \"Unexpected space before =>.\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);\n                        }\n                    });\n                }\n            }\n\n            if (rule.after) {\n\n                // should be space(s) after arrow\n                if (countSpace.after === 0) {\n                    context.report({\n                        node: tokens.after,\n                        message: \"Missing space after =>.\",\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokens.arrow, \" \");\n                        }\n                    });\n                }\n            } else {\n\n                // should be no space after arrow\n                if (countSpace.after > 0) {\n                    context.report({\n                        node: tokens.after,\n                        message: \"Unexpected space after =>.\",\n                        fix(fixer) {\n                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: spaces\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/block-scoped-var.js":"/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node - A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {escope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const identifier = reference.identifier;\n\n            context.report({ node: identifier, message: \"'{{name}}' used outside of binding context.\", data: { name: identifier.name } });\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node - A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            const scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                const idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/block-spacing.js":"/**\n * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst util = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside single-line blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ]\n    },\n\n    create(context) {\n        const always = (context.options[0] !== \"never\"),\n            message = always ? \"Requires a space\" : \"Unexpected space(s)\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                if (node.cases.length > 0) {\n                    return sourceCode.getTokenBefore(node.cases[0]);\n                }\n                return sourceCode.getLastToken(node, 1);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks whether or not:\n         *   - given tokens are on same line.\n         *   - there is/isn't a space between given tokens.\n         * @param {Token} left - A token to check.\n         * @param {Token} right - The token which is next to `left`.\n         * @returns {boolean}\n         *    When the option is `\"always\"`, `true` if there are one or more spaces between given tokens.\n         *    When the option is `\"never\"`, `true` if there are not any spaces between given tokens.\n         *    If given tokens are not on same line, it's always `true`.\n         */\n        function isValid(left, right) {\n            return (\n                !util.isTokenOnSameLine(left, right) ||\n                sourceCode.isSpaceBetweenTokens(left, right) === always\n            );\n        }\n\n        /**\n         * Reports invalid spacing style inside braces.\n         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.\n         * @returns {void}\n         */\n        function checkSpacingInsideBraces(node) {\n\n            // Gets braces and the first/last token of content.\n            const openBrace = getOpenBrace(node);\n            const closeBrace = sourceCode.getLastToken(node);\n            const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            // Skip if the node is invalid or empty.\n            if (openBrace.type !== \"Punctuator\" ||\n                openBrace.value !== \"{\" ||\n                closeBrace.type !== \"Punctuator\" ||\n                closeBrace.value !== \"}\" ||\n                firstToken === closeBrace\n            ) {\n                return;\n            }\n\n            // Skip line comments for option never\n            if (!always && firstToken.type === \"Line\") {\n                return;\n            }\n\n            // Check.\n            if (!isValid(openBrace, firstToken)) {\n                context.report({\n                    node,\n                    loc: openBrace.loc.start,\n                    message: \"{{message}} after '{'.\",\n                    data: {\n                        message\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(firstToken, \" \");\n                        }\n\n                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);\n                    }\n                });\n            }\n            if (!isValid(lastToken, closeBrace)) {\n                context.report({\n                    node,\n                    loc: closeBrace.loc.start,\n                    message: \"{{message}} before '}'.\",\n                    data: {\n                        message\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(lastToken, \" \");\n                        }\n\n                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            BlockStatement: checkSpacingInsideBraces,\n            SwitchStatement: checkSpacingInsideBraces\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/brace-style.js":"/**\n * @fileoverview Rule to flag block statements that do not use the one true brace style\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent brace style for blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowSingleLine: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const style = context.options[0] || \"1tbs\",\n            params = context.options[1] || {},\n            sourceCode = context.getSourceCode();\n\n        const OPEN_MESSAGE = \"Opening curly brace does not appear on the same line as controlling statement.\",\n            OPEN_MESSAGE_ALLMAN = \"Opening curly brace appears on the same line as controlling statement.\",\n            BODY_MESSAGE = \"Statement inside of curly braces should be on next line.\",\n            CLOSE_MESSAGE = \"Closing curly brace does not appear on the same line as the subsequent block.\",\n            CLOSE_MESSAGE_SINGLE = \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n            CLOSE_MESSAGE_STROUSTRUP_ALLMAN = \"Closing curly brace appears on the same line as the subsequent block.\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Fixes a place where a newline unexpectedly appears\n        * @param {Token} firstToken The token before the unexpected newline\n        * @param {Token} secondToken The token after the unexpected newline\n        * @returns {Function} A fixer function to remove the newlines between the tokens\n        */\n        function removeNewlineBetween(firstToken, secondToken) {\n            const textRange = [firstToken.range[1], secondToken.range[0]];\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\n            const NEWLINE_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n            // Don't do a fix if there is a comment between the tokens\n            return fixer => fixer.replaceTextRange(textRange, textBetween.trim() ? null : textBetween.replace(NEWLINE_REGEX, \"\"));\n        }\n\n        /**\n        * Validates a pair of curly brackets based on the user's config\n        * @param {Token} openingCurly The opening curly bracket\n        * @param {Token} closingCurly The closing curly bracket\n        * @returns {void}\n        */\n        function validateCurlyPair(openingCurly, closingCurly) {\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n                context.report({\n                    node: openingCurly,\n                    message: OPEN_MESSAGE,\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n                });\n            }\n\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    message: OPEN_MESSAGE_ALLMAN,\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n                });\n            }\n\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n                context.report({\n                    node: openingCurly,\n                    message: BODY_MESSAGE,\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n                });\n            }\n\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n                context.report({\n                    node: closingCurly,\n                    message: CLOSE_MESSAGE_SINGLE,\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n                });\n            }\n        }\n\n        /**\n        * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\n        * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\n        * @returns {void}\n        */\n        function validateCurlyBeforeKeyword(curlyToken) {\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    message: CLOSE_MESSAGE,\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\n                });\n            }\n\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n                context.report({\n                    node: curlyToken,\n                    message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BlockStatement(node) {\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n                }\n            },\n            ClassBody(node) {\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n            },\n            SwitchStatement(node) {\n                const closingCurly = sourceCode.getLastToken(node);\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n\n                validateCurlyPair(openingCurly, closingCurly);\n            },\n            IfStatement(node) {\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n\n                    // Handle the keyword after the `if` block (before `else`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n                }\n            },\n            TryStatement(node) {\n\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n                if (node.handler && node.finalizer) {\n\n                    // Handle the keyword after the `catch` block (before `finally`)\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/callback-return.js":"/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }]\n    },\n\n    create(context) {\n\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a node contains only identifers\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the node contains only identifers\n         */\n        function containsOnlyIdentifiers(node) {\n            if (node.type === \"Identifier\") {\n                return true;\n            }\n\n            if (node.type === \"MemberExpression\") {\n                if (node.object.type === \"Identifier\") {\n                    return true;\n                } else if (node.object.type === \"MemberExpression\") {\n                    return containsOnlyIdentifiers(node.object);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n\n                // if we're not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        const parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report({ node, message: \"Expected return with your callback function.\" });\n                }\n\n            }\n\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/camelcase.js":"/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = [];\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.indexOf(\"_\") > -1 && name !== name.toUpperCase();\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.indexOf(node) < 0) {\n                reported.push(node);\n                context.report({ node, message: \"Identifier '{{name}}' is not in camel case.\", data: { name: node.name } });\n            }\n        }\n\n        const options = context.options[0] || {};\n        let properties = options.properties || \"\";\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        return {\n\n            Identifier(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them\n                 */\n                const name = node.name.replace(/^_+|_+$/g, \"\"),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                            node.parent.object.name === node.name &&\n                            isUnderscored(name)) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                            isUnderscored(name) &&\n                            (effectiveParent.right.type !== \"MemberExpression\" ||\n                            effectiveParent.left.type === \"MemberExpression\" &&\n                            effectiveParent.left.property.name === node.name)) {\n                        report(node);\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\" &&\n                            node.parent.key === node && node.parent.value !== node) {\n                        return;\n                    }\n\n                    if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                        report(node);\n                    }\n\n                // Check if it's an import specifier\n                } else if ([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"].indexOf(node.parent.type) >= 0) {\n\n                    // Report only if the local imported identifier is underscored\n                    if (node.parent.local && node.parent.local.name === node.name && isUnderscored(name)) {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/capitalized-comments.js":"/**\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\n * @author Kevin Partington\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"../util/patterns/letters\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALWAYS_MESSAGE = \"Comments should not begin with a lowercase character\",\n    NEVER_MESSAGE = \"Comments should not begin with an uppercase character\",\n    DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n    WHITESPACE = /\\s/g,\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/,    // TODO: Combine w/ max-len pattern?\n    DEFAULTS = {\n        ignorePattern: null,\n        ignoreInlineComments: false,\n        ignoreConsecutiveComments: false\n    };\n\n/*\n * Base schema body for defining the basic capitalization rule, ignorePattern,\n * and ignoreInlineComments values.\n * This can be used in a few different ways in the actual schema.\n */\nconst SCHEMA_BODY = {\n    type: \"object\",\n    properties: {\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreInlineComments: {\n            type: \"boolean\"\n        },\n        ignoreConsecutiveComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\n/**\n * Get normalized options for either block or line comments from the given\n * user-provided options.\n * - If the user-provided options is just a string, returns a normalized\n *   set of options using default values for all other options.\n * - If the user-provided options is an object, then a normalized option\n *   set is returned. Options specified in overrides will take priority\n *   over options specified in the main options object, which will in\n *   turn take priority over the rule's defaults.\n *\n * @param {Object|string} rawOptions The user-provided options.\n * @param {string} which Either \"line\" or \"block\".\n * @returns {Object} The normalized options.\n */\nfunction getNormalizedOptions(rawOptions, which) {\n    if (!rawOptions) {\n        return Object.assign({}, DEFAULTS);\n    }\n\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n\n/**\n * Get normalized options for block and line comments.\n *\n * @param {Object|string} rawOptions The user-provided options.\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\n * normalized options objects.\n */\nfunction getAllNormalizedOptions(rawOptions) {\n    return {\n        Line: getNormalizedOptions(rawOptions, \"line\"),\n        Block: getNormalizedOptions(rawOptions, \"block\")\n    };\n}\n\n/**\n * Creates a regular expression for each ignorePattern defined in the rule\n * options.\n *\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\n *\n * @param {Object} normalizedOptions The normalized rule options.\n * @returns {void}\n */\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n    Object.keys(normalizedOptions).forEach(key => {\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n        if (ignorePatternStr) {\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`);\n\n            normalizedOptions[key].ignorePatternRegExp = regExp;\n        }\n    });\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: [\n            { enum: [\"always\", \"never\"] },\n            {\n                oneOf: [\n                    SCHEMA_BODY,\n                    {\n                        type: \"object\",\n                        properties: {\n                            line: SCHEMA_BODY,\n                            block: SCHEMA_BODY\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const capitalize = context.options[0] || \"always\",\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\n            sourceCode = context.getSourceCode();\n\n        createRegExpForIgnorePatterns(normalizedOptions);\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Checks whether a comment is an inline comment.\n         *\n         * For the purpose of this rule, a comment is inline if:\n         * 1. The comment is preceded by a token on the same line; and\n         * 2. The command is followed by a token on the same line.\n         *\n         * Note that the comment itself need not be single-line!\n         *\n         * Also, it follows from this definition that only block comments can\n         * be considered as possibly inline. This is because line comments\n         * would consume any following tokens on the same line as the comment.\n         *\n         * @param {ASTNode} comment The comment node to check.\n         * @returns {boolean} True if the comment is an inline comment, false\n         * otherwise.\n         */\n        function isInlineComment(comment) {\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\n\n            return Boolean(\n                previousToken &&\n                nextToken &&\n                comment.loc.start.line === previousToken.loc.end.line &&\n                comment.loc.end.line === nextToken.loc.start.line\n            );\n        }\n\n        /**\n         * Determine if a comment follows another comment.\n         *\n         * @param {ASTNode} comment The comment to check.\n         * @returns {boolean} True if the comment follows a valid comment.\n         */\n        function isConsecutiveComment(comment) {\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\n\n            return Boolean(\n                previousTokenOrComment &&\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\n            );\n        }\n\n        /**\n         * Check a comment to determine if it is valid for this rule.\n         *\n         * @param {ASTNode} comment The comment node to process.\n         * @param {Object} options The options for checking this comment.\n         * @returns {boolean} True if the comment is valid, false otherwise.\n         */\n        function isCommentValid(comment, options) {\n\n            // 1. Check for default ignore pattern.\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n                return true;\n            }\n\n            // 2. Check for custom ignore pattern.\n            const commentWithoutAsterisks = comment.value\n                .replace(/\\*/g, \"\");\n\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 3. Check for inline comments.\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\n                return true;\n            }\n\n            // 4. Is this a consecutive comment (and are we tolerating those)?\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n                return true;\n            }\n\n            // 5. Does the comment start with a possible URL?\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\n                return true;\n            }\n\n            // 6. Is the initial word character a letter?\n            const commentWordCharsOnly = commentWithoutAsterisks\n                .replace(WHITESPACE, \"\");\n\n            if (commentWordCharsOnly.length === 0) {\n                return true;\n            }\n\n            const firstWordChar = commentWordCharsOnly[0];\n\n            if (!LETTER_PATTERN.test(firstWordChar)) {\n                return true;\n            }\n\n            // 7. Check the case of the initial word character.\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n            if (capitalize === \"always\" && isLowercase) {\n                return false;\n            } else if (capitalize === \"never\" && isUppercase) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Process a comment to determine if it needs to be reported.\n         *\n         * @param {ASTNode} comment The comment node to process.\n         * @returns {void}\n         */\n        function processComment(comment) {\n            const options = normalizedOptions[comment.type],\n                commentValid = isCommentValid(comment, options);\n\n            if (!commentValid) {\n                const message = capitalize === \"always\"\n                    ? ALWAYS_MESSAGE\n                    : NEVER_MESSAGE;\n\n                context.report({\n                    node: null,         // Intentionally using loc instead\n                    loc: comment.loc,\n                    message,\n                    fix(fixer) {\n                        const match = comment.value.match(LETTER_PATTERN);\n\n                        return fixer.replaceTextRange(\n\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\n                        );\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            Program() {\n                const comments = sourceCode.getAllComments();\n\n                comments.forEach(processComment);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/patterns/letters.js":"/**\n * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).\n * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js\n * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.\n * @author Kevin Partington\n * @license MIT License (from JSCS). See below.\n */\n\n/*\n * The MIT License (MIT)\n *\n * Copyright 2013-2016 Dulin Marat and other contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\"use strict\";\n\nmodule.exports = /[A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/;\n\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/class-methods-use-this.js":"/**\n * @fileoverview Rule to enforce that all class methods use 'this'.\n * @author Patrick Williams\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce that class methods utilize `this`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                exceptMethods: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n    create(context) {\n        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};\n        const exceptMethods = new Set(config.exceptMethods || []);\n\n        const stack = [];\n\n        /**\n         * Initializes the current context to false and pushes it onto the stack.\n         * These booleans represent whether 'this' has been used in the context.\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            stack.push(false);\n        }\n\n        /**\n         * Check if the node is an instance method\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} True if its an instance method\n         * @private\n         */\n        function isInstanceMethod(node) {\n            return !node.static && node.kind !== \"constructor\" && node.type === \"MethodDefinition\";\n        }\n\n        /**\n         * Check if the node is an instance method not excluded by config\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} True if it is an instance method, and not excluded by config\n         * @private\n         */\n        function isIncludedInstanceMethod(node) {\n            return isInstanceMethod(node) && !exceptMethods.has(node.key.name);\n        }\n\n        /**\n         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.\n         * Static methods and the constructor are exempt.\n         * Then pops the context off the stack.\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         * @private\n         */\n        function exitFunction(node) {\n            const methodUsesThis = stack.pop();\n\n            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {\n                context.report({\n                    node,\n                    message: \"Expected 'this' to be used by class method '{{classMethod}}'.\",\n                    data: {\n                        classMethod: node.parent.key.name\n                    }\n                });\n            }\n        }\n\n        /**\n         * Mark the current context as having used 'this'.\n         * @returns {void}\n         * @private\n         */\n        function markThisUsed() {\n            if (stack.length) {\n                stack[stack.length - 1] = true;\n            }\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markThisUsed,\n            Super: markThisUsed\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/comma-dangle.js":"/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = Object.freeze({\n    arrays: \"never\",\n    objects: \"never\",\n    imports: \"never\",\n    exports: \"never\",\n    functions: \"ignore\"\n});\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\n *\n * @param {ASTNode} lastItem - The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(lastItem) {\n    return !(\n        lastItem.type === \"RestElement\" ||\n        lastItem.type === \"RestProperty\" ||\n        lastItem.type === \"ExperimentalRestProperty\"\n    );\n}\n\n/**\n * Normalize option value.\n *\n * @param {string|Object|undefined} optionValue - The 1st option value to normalize.\n * @returns {Object} The normalized option value.\n */\nfunction normalizeOptions(optionValue) {\n    if (typeof optionValue === \"string\") {\n        return {\n            arrays: optionValue,\n            objects: optionValue,\n            imports: optionValue,\n            exports: optionValue,\n\n            // For backward compatibility, always ignore functions.\n            functions: \"ignore\"\n        };\n    }\n    if (typeof optionValue === \"object\" && optionValue !== null) {\n        return {\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\n        };\n    }\n\n    return DEFAULT_OPTIONS;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                defs: {\n                    value: {\n                        enum: [\n                            \"always\",\n                            \"always-multiline\",\n                            \"only-multiline\",\n                            \"never\"\n                        ]\n                    },\n                    valueWithIgnore: {\n                        anyOf: [\n                            {\n                                $ref: \"#/defs/value\"\n                            },\n                            {\n                                enum: [\"ignore\"]\n                            }\n                        ]\n                    }\n                },\n                anyOf: [\n                    {\n                        $ref: \"#/defs/value\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            arrays: { $refs: \"#/defs/valueWithIgnore\" },\n                            objects: { $refs: \"#/defs/valueWithIgnore\" },\n                            imports: { $refs: \"#/defs/valueWithIgnore\" },\n                            exports: { $refs: \"#/defs/valueWithIgnore\" },\n                            functions: { $refs: \"#/defs/valueWithIgnore\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = normalizeOptions(context.options[0]);\n        const sourceCode = context.getSourceCode();\n        const UNEXPECTED_MESSAGE = \"Unexpected trailing comma.\";\n        const MISSING_MESSAGE = \"Missing trailing comma.\";\n\n        /**\n         * Gets the last item of the given node.\n         * @param {ASTNode} node - The node to get.\n         * @returns {ASTNode|null} The last node or null.\n         */\n        function getLastItem(node) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ObjectPattern\":\n                    return lodash.last(node.properties);\n                case \"ArrayExpression\":\n                case \"ArrayPattern\":\n                    return lodash.last(node.elements);\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                    return lodash.last(node.specifiers);\n                case \"FunctionDeclaration\":\n                case \"FunctionExpression\":\n                case \"ArrowFunctionExpression\":\n                    return lodash.last(node.params);\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return lodash.last(node.arguments);\n                default:\n                    return null;\n            }\n        }\n\n        /**\n         * Gets the trailing comma token of the given node.\n         * If the trailing comma does not exist, this returns the token which is\n         * the insertion point of the trailing comma token.\n         *\n         * @param {ASTNode} node - The node to get.\n         * @param {ASTNode} lastItem - The last item of the node.\n         * @returns {Token} The trailing comma token or the insertion point.\n         */\n        function getTrailingToken(node, lastItem) {\n            switch (node.type) {\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return sourceCode.getLastToken(node, 1);\n                default: {\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\n\n                    if (astUtils.isCommaToken(nextToken)) {\n                        return nextToken;\n                    }\n                    return sourceCode.getLastToken(lastItem);\n                }\n            }\n        }\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            const penultimateToken = getTrailingToken(node, lastItem);\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (astUtils.isCommaToken(trailingToken)) {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.start,\n                    message: UNEXPECTED_MESSAGE,\n                    fix(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            const lastItem = getLastItem(node);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            const trailingToken = getTrailingToken(node, lastItem);\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.end,\n                    message: MISSING_MESSAGE,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(trailingToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        const predicate = {\n            always: forceTrailingComma,\n            \"always-multiline\": forceTrailingCommaIfMultiline,\n            \"only-multiline\": allowTrailingCommaIfMultiline,\n            never: forbidTrailingComma,\n            ignore: lodash.noop\n        };\n\n        return {\n            ObjectExpression: predicate[options.objects],\n            ObjectPattern: predicate[options.objects],\n\n            ArrayExpression: predicate[options.arrays],\n            ArrayPattern: predicate[options.arrays],\n\n            ImportDeclaration: predicate[options.imports],\n\n            ExportNamedDeclaration: predicate[options.exports],\n\n            FunctionDeclaration: predicate[options.functions],\n            FunctionExpression: predicate[options.functions],\n            ArrowFunctionExpression: predicate[options.functions],\n            CallExpression: predicate[options.functions],\n            NewExpression: predicate[options.functions]\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/comma-spacing.js":"/**\n * @fileoverview Comma spacing - validates spacing before and after comma\n * @author Vignesh Anand aka vegetableman.\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after commas\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n        const tokensAndComments = sourceCode.tokensAndComments;\n\n        const options = {\n            before: context.options[0] ? !!context.options[0].before : false,\n            after: context.options[0] ? !!context.options[0].after : true\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // list of comma tokens to ignore for the check of leading whitespace\n        const commaTokensToIgnore = [];\n\n        /**\n         * Reports a spacing error with an appropriate message.\n         * @param {ASTNode} node The binary expression node to report.\n         * @param {string} dir Is the error \"before\" or \"after\" the comma?\n         * @param {ASTNode} otherNode The node at the left or right of `node`\n         * @returns {void}\n         * @private\n         */\n        function report(node, dir, otherNode) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (options[dir]) {\n                        if (dir === \"before\") {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.insertTextAfter(node, \" \");\n\n                    }\n                    let start, end;\n                    const newText = \"\";\n\n                    if (dir === \"before\") {\n                        start = otherNode.range[1];\n                        end = node.range[0];\n                    } else {\n                        start = node.range[1];\n                        end = otherNode.range[0];\n                    }\n\n                    return fixer.replaceTextRange([start, end], newText);\n\n                },\n                message: options[dir]\n                  ? \"A space is required {{dir}} ','.\"\n                  : \"There should be no space {{dir}} ','.\",\n                data: {\n                    dir\n                }\n            });\n        }\n\n        /**\n         * Validates the spacing around a comma token.\n         * @param {Object} tokens - The tokens to be validated.\n         * @param {Token} tokens.comma The token representing the comma.\n         * @param {Token} [tokens.left] The last token before the comma.\n         * @param {Token} [tokens.right] The first token after the comma.\n         * @param {Token|ASTNode} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(tokens, reportItem) {\n            if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&\n                    (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))\n            ) {\n                report(reportItem, \"before\", tokens.left);\n            }\n\n            if (tokens.right && !options.after && tokens.right.type === \"Line\") {\n                return;\n            }\n\n            if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&\n                    (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))\n            ) {\n                report(reportItem, \"after\", tokens.right);\n            }\n        }\n\n        /**\n         * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.\n         * @param {ASTNode} node An ArrayExpression or ArrayPattern node.\n         * @returns {void}\n         */\n        function addNullElementsToIgnoreList(node) {\n            let previousToken = sourceCode.getFirstToken(node);\n\n            node.elements.forEach(element => {\n                let token;\n\n                if (element === null) {\n                    token = sourceCode.getTokenAfter(previousToken);\n\n                    if (astUtils.isCommaToken(token)) {\n                        commaTokensToIgnore.push(token);\n                    }\n                } else {\n                    token = sourceCode.getTokenAfter(element);\n                }\n\n                previousToken = token;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"() {\n                tokensAndComments.forEach((token, i) => {\n\n                    if (!astUtils.isCommaToken(token)) {\n                        return;\n                    }\n\n                    if (token && token.type === \"JSXText\") {\n                        return;\n                    }\n\n                    const previousToken = tokensAndComments[i - 1];\n                    const nextToken = tokensAndComments[i + 1];\n\n                    validateCommaItemSpacing({\n                        comma: token,\n                        left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,\n                        right: astUtils.isCommaToken(nextToken) ? null : nextToken\n                    }, token);\n                });\n            },\n            ArrayExpression: addNullElementsToIgnoreList,\n            ArrayPattern: addNullElementsToIgnoreList\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/comma-style.js":"/**\n * @fileoverview Comma style - enforces comma styles of two types: last and first\n * @author Vignesh Anand aka vegetableman\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent comma style\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: [\n            {\n                enum: [\"first\", \"last\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const style = context.options[0] || \"last\",\n            sourceCode = context.getSourceCode();\n        const exceptions = {\n            ArrayPattern: true,\n            ArrowFunctionExpression: true,\n            CallExpression: true,\n            FunctionDeclaration: true,\n            FunctionExpression: true,\n            ImportDeclaration: true,\n            ObjectPattern: true\n        };\n\n        if (context.options.length === 2 && context.options[1].hasOwnProperty(\"exceptions\")) {\n            const keys = Object.keys(context.options[1].exceptions);\n\n            for (let i = 0; i < keys.length; i++) {\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Modified text based on the style\n         * @param {string} styleType Style type\n         * @param {string} text Source code text\n         * @returns {string} modified text\n         * @private\n         */\n        function getReplacedText(styleType, text) {\n            switch (styleType) {\n                case \"between\":\n                    return `,${text.replace(\"\\n\", \"\")}`;\n\n                case \"first\":\n                    return `${text},`;\n\n                case \"last\":\n                    return `,${text}`;\n\n                default:\n                    return \"\";\n            }\n        }\n\n        /**\n         * Determines the fixer function for a given style.\n         * @param {string} styleType comma style\n         * @param {ASTNode} previousItemToken The token to check.\n         * @param {ASTNode} commaToken The token to check.\n         * @param {ASTNode} currentItemToken The token to check.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n            const text =\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\n\n            return function(fixer) {\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n            };\n        }\n\n        /**\n         * Validates the spacing around single items in lists.\n         * @param {Token} previousItemToken The last token from the previous item.\n         * @param {Token} commaToken The token representing the comma.\n         * @param {Token} currentItemToken The first token of the current item.\n         * @param {Token} reportItem The item to use when reporting an error.\n         * @returns {void}\n         * @private\n         */\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // do nothing.\n\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n\n                // lone comma\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.start.column\n                    },\n                    message: \"Bad line breaking before and after ','.\",\n                    fix: getFixerFunction(\"between\", previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    message: \"',' should be placed first.\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n\n                context.report({\n                    node: reportItem,\n                    loc: {\n                        line: commaToken.loc.end.line,\n                        column: commaToken.loc.end.column\n                    },\n                    message: \"',' should be placed last.\",\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n                });\n            }\n        }\n\n        /**\n         * Checks the comma placement with regards to a declaration/property/element\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} property The property of the node containing child nodes.\n         * @private\n         * @returns {void}\n         */\n        function validateComma(node, property) {\n            const items = node[property],\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\n\n            if (items.length > 1 || arrayLiteral) {\n\n                // seed as opening [\n                let previousItemToken = sourceCode.getFirstToken(node);\n\n                items.forEach(item => {\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                        reportItem = item || currentItemToken,\n                        tokenBeforeComma = sourceCode.getTokenBefore(commaToken);\n\n                    // Check if previous token is wrapped in parentheses\n                    if (tokenBeforeComma && astUtils.isClosingParenToken(tokenBeforeComma)) {\n                        previousItemToken = tokenBeforeComma;\n                    }\n\n                    /*\n                     * This works by comparing three token locations:\n                     * - previousItemToken is the last token of the previous item\n                     * - commaToken is the location of the comma before the current item\n                     * - currentItemToken is the first token of the current item\n                     *\n                     * These values get switched around if item is undefined.\n                     * previousItemToken will refer to the last token not belonging\n                     * to the current item, which could be a comma or an opening\n                     * square bracket. currentItemToken could be a comma.\n                     *\n                     * All comparisons are done based on these tokens directly, so\n                     * they are always valid regardless of an undefined item.\n                     */\n                    if (astUtils.isCommaToken(commaToken)) {\n                        validateCommaItemSpacing(previousItemToken, commaToken,\n                                currentItemToken, reportItem);\n                    }\n\n                    if (item) {\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n\n                        previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n                    }\n                });\n\n                /*\n                 * Special case for array literals that have empty last items, such\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\n                 * AST, so we need to look at the token to verify that there's no\n                 * dangling comma.\n                 */\n                if (arrayLiteral) {\n\n                    const lastToken = sourceCode.getLastToken(node),\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n                    if (astUtils.isCommaToken(nextToLastToken)) {\n                        validateCommaItemSpacing(\n                            sourceCode.getTokenBefore(nextToLastToken),\n                            nextToLastToken,\n                            lastToken,\n                            lastToken\n                        );\n                    }\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        const nodes = {};\n\n        if (!exceptions.VariableDeclaration) {\n            nodes.VariableDeclaration = function(node) {\n                validateComma(node, \"declarations\");\n            };\n        }\n        if (!exceptions.ObjectExpression) {\n            nodes.ObjectExpression = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ObjectPattern) {\n            nodes.ObjectPattern = function(node) {\n                validateComma(node, \"properties\");\n            };\n        }\n        if (!exceptions.ArrayExpression) {\n            nodes.ArrayExpression = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.ArrayPattern) {\n            nodes.ArrayPattern = function(node) {\n                validateComma(node, \"elements\");\n            };\n        }\n        if (!exceptions.FunctionDeclaration) {\n            nodes.FunctionDeclaration = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.FunctionExpression) {\n            nodes.FunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.ArrowFunctionExpression) {\n            nodes.ArrowFunctionExpression = function(node) {\n                validateComma(node, \"params\");\n            };\n        }\n        if (!exceptions.CallExpression) {\n            nodes.CallExpression = function(node) {\n                validateComma(node, \"arguments\");\n            };\n        }\n        if (!exceptions.ImportDeclaration) {\n            nodes.ImportDeclaration = function(node) {\n                validateComma(node, \"specifiers\");\n            };\n        }\n\n        return nodes;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/complexity.js":"/**\n * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.\n * Counts the number of if, conditional, for, whilte, try, switch/case,\n * @author Patrick Brosset\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum cyclomatic complexity allowed in a program\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let THRESHOLD = 20;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            THRESHOLD = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            THRESHOLD = option.max;\n        }\n        if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store complexity (handling nested functions)\n        const fns = [];\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            fns.push(1);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n            const complexity = fns.pop();\n\n            if (complexity > THRESHOLD) {\n                context.report({\n                    node,\n                    message: \"{{name}} has a complexity of {{complexity}}.\",\n                    data: { name, complexity }\n                });\n            }\n        }\n\n        /**\n         * Increase the complexity of the function in context\n         * @returns {void}\n         * @private\n         */\n        function increaseComplexity() {\n            if (fns.length) {\n                fns[fns.length - 1]++;\n            }\n        }\n\n        /**\n         * Increase the switch complexity in context\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function increaseSwitchComplexity(node) {\n\n            // Avoiding `default`\n            if (node.test) {\n                increaseComplexity(node);\n            }\n        }\n\n        /**\n         * Increase the logical path complexity in context\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function increaseLogicalComplexity(node) {\n\n            // Avoiding &&\n            if (node.operator === \"||\") {\n                increaseComplexity(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            CatchClause: increaseComplexity,\n            ConditionalExpression: increaseComplexity,\n            LogicalExpression: increaseLogicalComplexity,\n            ForStatement: increaseComplexity,\n            ForInStatement: increaseComplexity,\n            ForOfStatement: increaseComplexity,\n            IfStatement: increaseComplexity,\n            SwitchCase: increaseSwitchComplexity,\n            WhileStatement: increaseComplexity,\n            DoWhileStatement: increaseComplexity\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/computed-property-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside computed properties.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside computed property brackets\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const propertyNameMustBeSpaced = context.options[0] === \"always\"; // default is \"never\"\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Reports that there shouldn't be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @param {Token} tokenAfter - The token after `token`.\n        * @returns {void}\n        */\n        function reportNoBeginningSpace(node, token, tokenAfter) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @param {Token} tokenBefore - The token before `token`.\n        * @returns {void}\n        */\n        function reportNoEndingSpace(node, token, tokenBefore) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{tokenValue}}'.\",\n                data: {\n                    tokenValue: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Returns a function that checks the spacing of a node on the property name\n         * that was passed in.\n         * @param {string} propertyName The property on the node to check for spacing\n         * @returns {Function} A function that will check spacing on a node\n         */\n        function checkSpacing(propertyName) {\n            return function(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const property = node[propertyName];\n\n                const before = sourceCode.getTokenBefore(property),\n                    first = sourceCode.getFirstToken(property),\n                    last = sourceCode.getLastToken(property),\n                    after = sourceCode.getTokenAfter(property);\n\n                if (astUtils.isTokenOnSameLine(before, first)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {\n                            reportRequiredBeginningSpace(node, before);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(before, first)) {\n                            reportNoBeginningSpace(node, before, first);\n                        }\n                    }\n                }\n\n                if (astUtils.isTokenOnSameLine(last, after)) {\n                    if (propertyNameMustBeSpaced) {\n                        if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {\n                            reportRequiredEndingSpace(node, after);\n                        }\n                    } else {\n                        if (sourceCode.isSpaceBetweenTokens(last, after)) {\n                            reportNoEndingSpace(node, after, last);\n                        }\n                    }\n                }\n            };\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Property: checkSpacing(\"key\"),\n            MemberExpression: checkSpacing(\"property\")\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/consistent-return.js":"/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n* Checks whether a given node is a `constructor` method in an ES6 class\n* @param {ASTNode} node A node to check\n* @returns {boolean} `true` if the node is a `constructor` method\n*/\nfunction isClassConstructor(node) {\n    return node.type === \"FunctionExpression\" &&\n        node.parent &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `return` statements to either always or never specify values\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        let funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         *\n         * @param {ASTNode} node - A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            let loc, name;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\n                astUtils.isES5Constructor(node) ||\n                isClassConstructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = { line: 1, column: 0 };\n                name = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc.start;\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || node).loc.start;\n            }\n\n            if (!name) {\n                name = astUtils.getFunctionNameWithKind(node);\n            }\n\n            // Reports.\n            context.report({\n                node,\n                loc,\n                message: \"Expected to return a value at the end of {{name}}.\",\n                data: { name }\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    message: \"\",\n                    node\n                };\n            },\n            onCodePathEnd() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement(node) {\n                const argument = node.argument;\n                let hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !isIdentifier(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.message = \"{{name}} expected {{which}} return value.\";\n                    funcInfo.data = {\n                        name: funcInfo.node.type === \"Program\"\n                            ? \"Program\"\n                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node)),\n                        which: hasReturnValue ? \"a\" : \"no\"\n                    };\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({\n                        node,\n                        message: funcInfo.message,\n                        data: funcInfo.data\n                    });\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/consistent-this.js":"/**\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\n * @author Raphael Pigulla\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent naming when capturing the current execution context\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\",\n                minLength: 1\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n        let aliases = [];\n\n        if (context.options.length === 0) {\n            aliases.push(\"that\");\n        } else {\n            aliases = context.options;\n        }\n\n        /**\n         * Reports that a variable declarator or assignment expression is assigning\n         * a non-'this' value to the specified alias.\n         * @param {ASTNode} node - The assigning node.\n         * @param {string} alias - the name of the alias that was incorrectly used.\n         * @returns {void}\n         */\n        function reportBadAssignment(node, alias) {\n            context.report({ node, message: \"Designated alias '{{alias}}' is not assigned to 'this'.\", data: { alias } });\n        }\n\n        /**\n         * Checks that an assignment to an identifier only assigns 'this' to the\n         * appropriate alias, and the alias is only assigned to 'this'.\n         * @param {ASTNode} node - The assigning node.\n         * @param {Identifier} name - The name of the variable assigned to.\n         * @param {Expression} value - The value of the assignment.\n         * @returns {void}\n         */\n        function checkAssignment(node, name, value) {\n            const isThis = value.type === \"ThisExpression\";\n\n            if (aliases.indexOf(name) !== -1) {\n                if (!isThis || node.operator && node.operator !== \"=\") {\n                    reportBadAssignment(node, name);\n                }\n            } else if (isThis) {\n                context.report({ node, message: \"Unexpected alias '{{name}}' for 'this'.\", data: { name } });\n            }\n        }\n\n        /**\n         * Ensures that a variable declaration of the alias in a program or function\n         * is assigned to the correct value.\n         * @param {string} alias alias the check the assignment of.\n         * @param {Object} scope scope of the current code we are checking.\n         * @private\n         * @returns {void}\n         */\n        function checkWasAssigned(alias, scope) {\n            const variable = scope.set.get(alias);\n\n            if (!variable) {\n                return;\n            }\n\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\n                def.node.init !== null)) {\n                return;\n            }\n\n            // The alias has been declared and not assigned: check it was\n            // assigned later in the same scope.\n            if (!variable.references.some(reference => {\n                const write = reference.writeExpr;\n\n                return (\n                    reference.from === scope &&\n                    write && write.type === \"ThisExpression\" &&\n                    write.parent.operator === \"=\"\n                );\n            })) {\n                variable.defs.map(def => def.node).forEach(node => {\n                    reportBadAssignment(node, alias);\n                });\n            }\n        }\n\n        /**\n         * Check each alias to ensure that is was assinged to the correct value.\n         * @returns {void}\n         */\n        function ensureWasAssigned() {\n            const scope = context.getScope();\n\n            aliases.forEach(alias => {\n                checkWasAssigned(alias, scope);\n            });\n        }\n\n        return {\n            \"Program:exit\": ensureWasAssigned,\n            \"FunctionExpression:exit\": ensureWasAssigned,\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n            VariableDeclarator(node) {\n                const id = node.id;\n                const isDestructuring =\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n                if (node.init !== null && !isDestructuring) {\n                    checkAssignment(node, id.name, node.init);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (node.left.type === \"Identifier\") {\n                    checkAssignment(node, node.left.name, node.right);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/constructor-super.js":"/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n *\n * @param {CodePathSegment} segment - A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        message: calledInSomePaths\n                            ? \"Lacked a call of 'super()' in some code paths.\"\n                            : \"Expected to call 'super()'.\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    message: \"Unexpected duplicate 'super()'.\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node - A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                message: \"Unexpected duplicate 'super()'.\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                message: \"Unexpected 'super()' because 'super' is not a constructor.\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        message: \"Unexpected 'super()'.\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node - A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/curly.js":"/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst esUtils = require(\"esutils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const multiOnly = (context.options[0] === \"multi\");\n        const multiLine = (context.options[0] === \"multi-line\");\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\n        const consistent = (context.options[1] === \"consistent\");\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            const before = sourceCode.getTokenBefore(node);\n            const last = sourceCode.getLastToken(node);\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            const first = sourceCode.getFirstToken(node),\n                last = sourceCode.getLastToken(node);\n\n            return first.loc.start.line === last.loc.end.line;\n        }\n\n        /**\n         * Checks if the given token is an `else` token or not.\n         *\n         * @param {Token} token - The token to check.\n         * @returns {boolean} `true` if the token is an `else` token.\n         */\n        function isElseKeywordToken(token) {\n            return token.value === \"else\" && token.type === \"Keyword\";\n        }\n\n        /**\n         * Gets the `else` keyword token of a given `IfStatement` node.\n         * @param {ASTNode} node - A `IfStatement` node to get.\n         * @returns {Token} The `else` keyword token.\n         */\n        function getElseKeyword(node) {\n            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);\n        }\n\n        /**\n         * Checks a given IfStatement node requires braces of the consequent chunk.\n         * This returns `true` when below:\n         *\n         * 1. The given node has the `alternate` node.\n         * 2. There is a `IfStatement` which doesn't have `alternate` node in the\n         *    trailing statement chain of the `consequent` node.\n         *\n         * @param {ASTNode} node - A IfStatement node to check.\n         * @returns {boolean} `true` if the node requires braces of the consequent chunk.\n         */\n        function requiresBraceOfConsequent(node) {\n            if (node.alternate && node.consequent.type === \"BlockStatement\") {\n                if (node.consequent.body.length >= 2) {\n                    return true;\n                }\n\n                node = node.consequent.body[0];\n                while (node) {\n                    if (node.type === \"IfStatement\" && !node.alternate) {\n                        return true;\n                    }\n                    node = astUtils.getTrailingStatement(node);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports \"Expected { after ...\" error\n         * @param {ASTNode} node The node to report.\n         * @param {ASTNode} bodyNode The body node that is incorrectly missing curly brackets\n         * @param {string} name The name to report.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {void}\n         * @private\n         */\n        function reportExpectedBraceError(node, bodyNode, name, suffix) {\n            context.report({\n                node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                message: \"Expected { after '{{name}}'{{suffix}}.\",\n                data: {\n                    name,\n                    suffix: (suffix ? ` ${suffix}` : \"\")\n                },\n                fix: fixer => fixer.replaceText(bodyNode, `{${sourceCode.getText(bodyNode)}}`)\n            });\n        }\n\n        /**\n        * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\n        * @param {Token} closingBracket The } token\n        * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\n        */\n        function needsSemicolon(closingBracket) {\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n            if (astUtils.isSemicolonToken(tokenBefore)) {\n\n                // If the last statement already has a semicolon, don't add another one.\n                return false;\n            }\n\n            if (!tokenAfter) {\n\n                // If there are no statements after this block, there is no need to add a semicolon.\n                return false;\n            }\n\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n\n                // If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\n                // don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\n                // a SyntaxError if it was followed by `else`.\n                return false;\n            }\n\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n\n                // If the next token is on the same line, insert a semicolon.\n                return true;\n            }\n\n            if (/^[([/`+-]/.test(tokenAfter.value)) {\n\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n                return true;\n            }\n\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n                return true;\n            }\n\n            // Otherwise, do not insert a semicolon.\n            return false;\n        }\n\n        /**\n         * Reports \"Unnecessary { after ...\" error\n         * @param {ASTNode} node The node to report.\n         * @param {ASTNode} bodyNode The block statement that is incorrectly surrounded by parens\n         * @param {string} name The name to report.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {void}\n         * @private\n         */\n        function reportUnnecessaryBraceError(node, bodyNode, name, suffix) {\n            context.report({\n                node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                message: \"Unnecessary { after '{{name}}'{{suffix}}.\",\n                data: {\n                    name,\n                    suffix: (suffix ? ` ${suffix}` : \"\")\n                },\n                fix(fixer) {\n\n                    // `do while` expressions sometimes need a space to be inserted after `do`.\n                    // e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\n                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\n                        sourceCode.getTokenBefore(bodyNode).end === bodyNode.start &&\n                        esUtils.code.isIdentifierPartES6(sourceCode.getText(bodyNode).charCodeAt(1));\n\n                    const openingBracket = sourceCode.getFirstToken(bodyNode);\n                    const closingBracket = sourceCode.getLastToken(bodyNode);\n                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                    if (needsSemicolon(closingBracket)) {\n\n                        /*\n                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\n                         * change the semantics of the code due to ASI), don't perform a fix.\n                         */\n                        return null;\n                    }\n\n                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\n                        sourceCode.getText(lastTokenInBlock) +\n                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n\n                    return fixer.replaceText(bodyNode, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n            });\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, suffix) {\n            const hasBlock = (body.type === \"BlockStatement\");\n            let expected = null;\n\n            if (node.type === \"IfStatement\" && node.consequent === body && requiresBraceOfConsequent(node)) {\n                expected = true;\n            } else if (multiOnly) {\n                if (hasBlock && body.body.length === 1) {\n                    expected = false;\n                }\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n            } else if (multiOrNest) {\n                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {\n                    const leadingComments = sourceCode.getComments(body.body[0]).leading;\n\n                    expected = leadingComments.length > 0;\n                } else if (!isOneLiner(body)) {\n                    expected = true;\n                }\n            } else {\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected,\n                check() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            reportExpectedBraceError(node, body, name, suffix);\n                        } else {\n                            reportUnnecessaryBraceError(node, body, name, suffix);\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            const preparedChecks = [];\n\n            do {\n                preparedChecks.push(prepareCheck(node, node.consequent, \"if\", \"condition\"));\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(node, node.alternate, \"else\"));\n                    break;\n                }\n                node = node.alternate;\n            } while (node);\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                const expected = preparedChecks.some(preparedCheck => {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(preparedCheck => {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    prepareIfChecks(node).forEach(preparedCheck => {\n                        preparedCheck.check();\n                    });\n                }\n            },\n\n            WhileStatement(node) {\n                prepareCheck(node, node.body, \"while\", \"condition\").check();\n            },\n\n            DoWhileStatement(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement(node) {\n                prepareCheck(node, node.body, \"for\", \"condition\").check();\n            },\n\n            ForInStatement(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/default-case.js":"/**\n * @fileoverview require default case in switch statements\n * @author Aliaksei Shytkin\n */\n\"use strict\";\n\nconst DEFAULT_COMMENT_PATTERN = /^no default$/i;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `default` cases in `switch` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                commentPattern: {\n                    type: \"string\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const commentPattern = options.commentPattern\n            ? new RegExp(options.commentPattern)\n            : DEFAULT_COMMENT_PATTERN;\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Shortcut to get last element of array\n         * @param  {*[]} collection Array\n         * @returns {*} Last element\n         */\n        function last(collection) {\n            return collection[collection.length - 1];\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            SwitchStatement(node) {\n\n                if (!node.cases.length) {\n\n                    /*\n                     * skip check of empty switch because there is no easy way\n                     * to extract comments inside it now\n                     */\n                    return;\n                }\n\n                const hasDefault = node.cases.some(v => v.test === null);\n\n                if (!hasDefault) {\n\n                    let comment;\n\n                    const lastCase = last(node.cases);\n                    const comments = sourceCode.getComments(lastCase).trailing;\n\n                    if (comments.length) {\n                        comment = last(comments);\n                    }\n\n                    if (!comment || !commentPattern.test(comment.value.trim())) {\n                        context.report({ node, message: \"Expected a default case.\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/dot-location.js":"/**\n * @fileoverview Validates newlines before and after dots\n * @author Greg Cochard\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent newlines before and after dots\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"object\", \"property\"]\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n\n        // default to onObject if no preference is passed\n        const onObject = config === \"object\" || !config;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if the dot between object and property is on the correct loccation.\n         * @param {ASTNode} obj The object owning the property.\n         * @param {ASTNode} prop The property of the object.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkDotLocation(obj, prop, node) {\n            const dot = sourceCode.getTokenBefore(prop);\n            const textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);\n            const textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);\n\n            if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                if (onObject) {\n                    if (!astUtils.isTokenOnSameLine(obj, dot)) {\n                        const neededTextAfterObj = astUtils.isDecimalInteger(obj) ? \" \" : \"\";\n\n                        context.report({\n                            node,\n                            loc: dot.loc.start,\n                            message: \"Expected dot to be on same line as object.\",\n                            fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${neededTextAfterObj}.${textBeforeDot}${textAfterDot}`)\n                        });\n                    }\n                } else if (!astUtils.isTokenOnSameLine(dot, prop)) {\n                    context.report({\n                        node,\n                        loc: dot.loc.start,\n                        message: \"Expected dot to be on same line as property.\",\n                        fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${textBeforeDot}${textAfterDot}.`)\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the dot within a member expression.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            checkDotLocation(node.object, node.property, node);\n        }\n\n        return {\n            MemberExpression: checkNode\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/dot-notation.js":"/**\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\n * @author Josh Perez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;\nconst keywords = require(\"../util/keywords\");\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce dot notation whenever possible\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowKeywords: {\n                        type: \"boolean\"\n                    },\n                    allowPattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;\n        const sourceCode = context.getSourceCode();\n\n        let allowPattern;\n\n        if (options.allowPattern) {\n            allowPattern = new RegExp(options.allowPattern);\n        }\n\n        return {\n            MemberExpression(node) {\n                if (\n                    node.computed &&\n                    node.property.type === \"Literal\" &&\n                    validIdentifier.test(node.property.value) &&\n                    (allowKeywords || keywords.indexOf(String(node.property.value)) === -1)\n                ) {\n                    if (!(allowPattern && allowPattern.test(node.property.value))) {\n                        context.report({\n                            node: node.property,\n                            message: \"[{{propertyValue}}] is better written in dot notation.\",\n                            data: {\n                                propertyValue: JSON.stringify(node.property.value)\n                            },\n                            fix(fixer) {\n                                const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n                                const rightBracket = sourceCode.getLastToken(node);\n\n                                if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {\n\n                                    // Don't perform any fixes if there are comments inside the brackets.\n                                    return null;\n                                }\n\n                                const textBeforeDot = astUtils.isDecimalInteger(node.object) ? \" \" : \"\";\n\n                                return fixer.replaceTextRange(\n                                    [leftBracket.range[0], rightBracket.range[1]],\n                                    `${textBeforeDot}.${node.property.value}`\n                                );\n                            }\n                        });\n                    }\n                }\n                if (\n                    !allowKeywords &&\n                    !node.computed &&\n                    keywords.indexOf(String(node.property.name)) !== -1\n                ) {\n                    context.report({\n                        node: node.property,\n                        message: \".{{propertyName}} is a syntax error.\",\n                        data: {\n                            propertyName: node.property.name\n                        },\n                        fix(fixer) {\n                            const dot = sourceCode.getTokenBefore(node.property);\n                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);\n\n                            if (textAfterDot.trim()) {\n\n                                // Don't perform any fixes if there are comments between the dot and the property name.\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [dot.range[0], node.property.range[1]],\n                                `[${textAfterDot}\"${node.property.name}\"]`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/keywords.js":"/**\n * @fileoverview A shared list of ES3 keywords.\n * @author Josh Perez\n */\n\"use strict\";\n\nmodule.exports = [\n    \"abstract\",\n    \"boolean\",\n    \"break\",\n    \"byte\",\n    \"case\",\n    \"catch\",\n    \"char\",\n    \"class\",\n    \"const\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"delete\",\n    \"do\",\n    \"double\",\n    \"else\",\n    \"enum\",\n    \"export\",\n    \"extends\",\n    \"false\",\n    \"final\",\n    \"finally\",\n    \"float\",\n    \"for\",\n    \"function\",\n    \"goto\",\n    \"if\",\n    \"implements\",\n    \"import\",\n    \"in\",\n    \"instanceof\",\n    \"int\",\n    \"interface\",\n    \"long\",\n    \"native\",\n    \"new\",\n    \"null\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"return\",\n    \"short\",\n    \"static\",\n    \"super\",\n    \"switch\",\n    \"synchronized\",\n    \"this\",\n    \"throw\",\n    \"throws\",\n    \"transient\",\n    \"true\",\n    \"try\",\n    \"typeof\",\n    \"var\",\n    \"void\",\n    \"volatile\",\n    \"while\",\n    \"with\"\n];\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/eol-last.js":"/**\n * @fileoverview Require or disallow newline at the end of files\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow newline at the end of files\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\n            }\n        ]\n    },\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkBadEOF(node) {\n                const sourceCode = context.getSourceCode(),\n                    src = sourceCode.getText(),\n                    location = {\n                        column: lodash.last(sourceCode.lines).length,\n                        line: sourceCode.lines.length\n                    },\n                    LF = \"\\n\",\n                    CRLF = `\\r${LF}`,\n                    endsWithNewline = lodash.endsWith(src, LF);\n\n                let mode = context.options[0] || \"always\",\n                    appendCRLF = false;\n\n                if (mode === \"unix\") {\n\n                    // `\"unix\"` should behave exactly as `\"always\"`\n                    mode = \"always\";\n                }\n                if (mode === \"windows\") {\n\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n                    mode = \"always\";\n                    appendCRLF = true;\n                }\n                if (mode === \"always\" && !endsWithNewline) {\n\n                    // File is not newline-terminated, but should be\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Newline required at end of file but not found.\",\n                        fix(fixer) {\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n                        }\n                    });\n                } else if (mode === \"never\" && endsWithNewline) {\n\n                    // File is newline-terminated, but shouldn't be\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Newline not allowed at end of file.\",\n                        fix(fixer) {\n                            const finalEOLs = /(?:\\r?\\n)+$/,\n                                match = finalEOLs.exec(sourceCode.text),\n                                start = match.index,\n                                end = sourceCode.text.length;\n\n                            return fixer.replaceTextRange([start, end], \"\");\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/eqeqeq.js":"/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                null: {\n                                    enum: [\"always\", \"never\", \"ignore\"]\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    additionalItems: false\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"smart\", \"allow-null\"]\n                        }\n                    ],\n                    additionalItems: false\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const config = context.options[0] || \"always\";\n        const options = context.options[1] || {};\n        const sourceCode = context.getSourceCode();\n\n        const nullOption = (config === \"always\")\n            ? options.null || \"always\"\n            : \"ignore\";\n        const enforceRuleForNull = (nullOption === \"always\");\n        const enforceInverseRuleForNull = (nullOption === \"never\");\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n        }\n\n        /**\n         * Gets the location (line and column) of the binary expression's operator\n         * @param {ASTNode} node The binary expression node to check\n         * @param {string} operator The operator to find\n         * @returns {Object} { line, column } location of operator\n         * @private\n         */\n        function getOperatorLocation(node) {\n            const opToken = sourceCode.getTokenAfter(node.left);\n\n            return { line: opToken.loc.start.line, column: opToken.loc.start.column };\n        }\n\n        /**\n         * Reports a message for this rule.\n         * @param {ASTNode} node The binary expression node that was checked\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\n         * @returns {void}\n         * @private\n         */\n        function report(node, expectedOperator) {\n            context.report({\n                node,\n                loc: getOperatorLocation(node),\n                message: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\",\n                data: { expectedOperator, actualOperator: node.operator },\n                fix(fixer) {\n\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n                        const operatorToken = sourceCode.getFirstTokenBetween(\n                            node.left,\n                            node.right,\n                            token => token.value === node.operator\n                        );\n\n                        return fixer.replaceText(operatorToken, expectedOperator);\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            BinaryExpression(node) {\n                const isNull = isNullCheck(node);\n\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    if (enforceInverseRuleForNull && isNull) {\n                        report(node, node.operator.slice(0, -1));\n                    }\n                    return;\n                }\n\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNull)) {\n                    return;\n                }\n\n                if (!enforceRuleForNull && isNull) {\n                    return;\n                }\n\n                report(node, `${node.operator}=`);\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/func-call-spacing.js":"/**\n * @fileoverview Rule to control spacing within function calls\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing between function identifiers and their invocations\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                allowNewlines: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const never = context.options[0] !== \"always\";\n        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;\n        const sourceCode = context.getSourceCode();\n        const text = sourceCode.getText();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);\n            const prevToken = parenToken && sourceCode.getTokenBefore(parenToken);\n\n            // Parens in NewExpression are optional\n            if (!(parenToken && parenToken.range[1] < node.range[1])) {\n                return;\n            }\n\n            const textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\\/\\*.*?\\*\\//g, \"\");\n            const hasWhitespace = /\\s/.test(textBetweenTokens);\n            const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);\n\n            /*\n             * never allowNewlines hasWhitespace hasNewline message\n             * F     F             F             F          Missing space between function name and paren.\n             * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     F             T             T          Unexpected newline between function name and paren.\n             * F     F             T             F          (OK)\n             * F     T             T             F          (OK)\n             * F     T             T             T          (OK)\n             * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * F     T             F             F          Missing space between function name and paren.\n             * T     T             F             F          (Invalid `never && allowNewlines`)\n             * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     T             T             T          (Invalid `never && allowNewlines`)\n             * T     T             T             F          (Invalid `never && allowNewlines`)\n             * T     F             T             F          Unexpected space between function name and paren.\n             * T     F             T             T          Unexpected space between function name and paren.\n             * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)\n             * T     F             F             F          (OK)\n             *\n             * T                   T                        Unexpected space between function name and paren.\n             * F                   F                        Missing space between function name and paren.\n             * F     F                           T          Unexpected newline between function name and paren.\n             */\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected space between function name and paren.\",\n                    fix(fixer) {\n\n                        // Only autofix if there is no newline\n                        // https://github.com/eslint/eslint/issues/7787\n                        if (!hasNewline) {\n                            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Missing space between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.insertTextBefore(parenToken, \" \");\n                    }\n                });\n            } else if (!never && !allowNewlines && hasNewline) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected newline between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: checkSpacing,\n            NewExpression: checkSpacing\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/func-name-matching.js":"/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let message;\n\n            if (nameMatches === \"always\" && isProp) {\n                message = \"Function name `{{funcName}}` should match property name `{{name}}`\";\n            } else if (nameMatches === \"always\") {\n                message = \"Function name `{{funcName}}` should match variable name `{{name}}`\";\n            } else if (isProp) {\n                message = \"Function name `{{funcName}}` should not match property name `{{name}}`\";\n            } else {\n                message = \"Function name `{{funcName}}` should not match variable name `{{name}}`\";\n            }\n            context.report({\n                node,\n                message,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            Property(node) {\n                if (node.value.type !== \"FunctionExpression\" || !node.value.id || node.computed && !isStringLiteral(node.key)) {\n                    return;\n                }\n                if (node.key.type === \"Identifier\" && shouldWarn(node.key.name, node.value.id.name)) {\n                    report(node, node.key.name, node.value.id.name, true);\n                } else if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/func-names.js":"/**\n * @fileoverview Rule to warn when a function expression does not have a name.\n * @author Kyle T. Nunery\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow named `function` expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const never = context.options[0] === \"never\";\n        const asNeeded = context.options[0] === \"as-needed\";\n\n        /**\n         * Determines whether the current FunctionExpression node is a get, set, or\n         * shorthand method in an object literal or a class.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\n         */\n        function isObjectOrClassMethod(node) {\n            const parent = node.parent;\n\n            return (parent.type === \"MethodDefinition\" || (\n                parent.type === \"Property\" && (\n                    parent.method ||\n                    parent.kind === \"get\" ||\n                    parent.kind === \"set\"\n                )\n            ));\n        }\n\n        /**\n         * Determines whether the current FunctionExpression node has a name that would be\n         * inferred from context in a conforming ES6 environment.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} True if the node would have a name assigned automatically.\n         */\n        function hasInferredName(node) {\n            const parent = node.parent;\n\n            return isObjectOrClassMethod(node) ||\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\n                (parent.type === \"Property\" && parent.value === node) ||\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\n                (parent.type === \"ExportDefaultDeclaration\" && parent.declaration === node) ||\n                (parent.type === \"AssignmentPattern\" && parent.right === node);\n        }\n\n        return {\n            \"FunctionExpression:exit\"(node) {\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                const hasName = Boolean(node.id && node.id.name);\n                const name = astUtils.getFunctionNameWithKind(node);\n\n                if (never) {\n                    if (hasName) {\n                        context.report({\n                            node,\n                            message: \"Unexpected named {{name}}.\",\n                            data: { name }\n                        });\n                    }\n                } else {\n                    if (!hasName && (asNeeded ? !hasInferredName(node) : !isObjectOrClassMethod(node))) {\n                        context.report({\n                            node,\n                            message: \"Unexpected unnamed {{name}}.\",\n                            data: { name }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/func-style.js":"/**\n * @fileoverview Rule to enforce a particular function style\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either `function` declarations or expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"declaration\", \"expression\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    allowArrowFunctions: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const style = context.options[0],\n            allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,\n            enforceDeclarations = (style === \"declaration\"),\n            stack = [];\n\n        const nodesToCheck = {\n            FunctionDeclaration(node) {\n                stack.push(false);\n\n                if (!enforceDeclarations && node.parent.type !== \"ExportDefaultDeclaration\") {\n                    context.report({ node, message: \"Expected a function expression.\" });\n                }\n            },\n            \"FunctionDeclaration:exit\"() {\n                stack.pop();\n            },\n\n            FunctionExpression(node) {\n                stack.push(false);\n\n                if (enforceDeclarations && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, message: \"Expected a function declaration.\" });\n                }\n            },\n            \"FunctionExpression:exit\"() {\n                stack.pop();\n            },\n\n            ThisExpression() {\n                if (stack.length > 0) {\n                    stack[stack.length - 1] = true;\n                }\n            }\n        };\n\n        if (!allowArrowFunctions) {\n            nodesToCheck.ArrowFunctionExpression = function() {\n                stack.push(false);\n            };\n\n            nodesToCheck[\"ArrowFunctionExpression:exit\"] = function(node) {\n                const hasThisExpr = stack.pop();\n\n                if (enforceDeclarations && !hasThisExpr && node.parent.type === \"VariableDeclarator\") {\n                    context.report({ node: node.parent, message: \"Expected a function declaration.\" });\n                }\n            };\n        }\n\n        return nodesToCheck;\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/generator-star-spacing.js":"/**\n * @fileoverview Rule to check the spacing around the * in generator functions.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing around `*` operators in generator functions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const mode = (function(option) {\n            if (!option || typeof option === \"string\") {\n                return {\n                    before: { before: true, after: false },\n                    after: { before: false, after: true },\n                    both: { before: true, after: true },\n                    neither: { before: false, after: false }\n                }[option || \"before\"];\n            }\n            return option;\n        }(context.options[0]));\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if the given token is a star token or not.\n         *\n         * @param {Token} token - The token to check.\n         * @returns {boolean} `true` if the token is a star token.\n         */\n        function isStarToken(token) {\n            return token.value === \"*\" && token.type === \"Punctuator\";\n        }\n\n        /**\n         * Gets the generator star token of the given function node.\n         *\n         * @param {ASTNode} node - The function node to get.\n         * @returns {Token} Found star token.\n         */\n        function getStarToken(node) {\n            return sourceCode.getFirstToken(\n                (node.parent.method || node.parent.type === \"MethodDefinition\") ? node.parent : node,\n                isStarToken\n            );\n        }\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(side, leftToken, rightToken) {\n            if (!!(rightToken.range[0] - leftToken.range[1]) !== mode[side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = mode[side];\n                const node = after ? leftToken : rightToken;\n                const type = spaceRequired ? \"Missing\" : \"Unexpected\";\n                const message = \"{{type}} space {{side}} *.\";\n                const data = {\n                    type,\n                    side\n                };\n\n                context.report({\n                    node,\n                    message,\n                    data,\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a generator function.\n         * @param {ASTNode} node A function expression or declaration node.\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const starToken = getStarToken(node);\n\n            // Only check before when preceded by `function`|`static` keyword\n            const prevToken = sourceCode.getTokenBefore(starToken);\n\n            if (prevToken.value === \"function\" || prevToken.value === \"static\") {\n                checkSpacing(\"before\", prevToken, starToken);\n            }\n\n            const nextToken = sourceCode.getTokenAfter(starToken);\n\n            checkSpacing(\"after\", starToken, nextToken);\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/global-require.js":"/**\n * @fileoverview Rule for disallowing require() outside of the top-level module context\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst ACCEPTABLE_PARENTS = [\n    \"AssignmentExpression\",\n    \"VariableDeclarator\",\n    \"MemberExpression\",\n    \"ExpressionStatement\",\n    \"CallExpression\",\n    \"ConditionalExpression\",\n    \"Program\",\n    \"VariableDeclaration\"\n];\n\n/**\n * Finds the escope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    /* istanbul ignore else: correctly returns null */\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {ASTNode} node The identifier node to check.\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `require()` calls to be placed at top-level module scope\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            CallExpression(node) {\n                const currentScope = context.getScope();\n\n                if (node.callee.name === \"require\" && !isShadowed(currentScope, node.callee)) {\n                    const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\n\n                    if (!isGoodRequire) {\n                        context.report({ node, message: \"Unexpected require().\" });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/guard-for-in.js":"/**\n * @fileoverview Rule to flag for-in loops without if statements inside\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `for-in` loops to include an `if` statement\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ForInStatement(node) {\n\n                /*\n                 * If the for-in statement has {}, then the real body is the body\n                 * of the BlockStatement. Otherwise, just use body as provided.\n                 */\n                const body = node.body.type === \"BlockStatement\" ? node.body.body[0] : node.body;\n\n                if (body && body.type !== \"IfStatement\") {\n                    context.report({ node, message: \"The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/handle-callback-err.js":"/**\n * @fileoverview Ensure handling of errors when we know they exist.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require error handling in callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            }\n        ]\n    },\n\n    create(context) {\n\n        const errorArgument = context.options[0] || \"err\";\n\n        /**\n         * Checks if the given argument should be interpreted as a regexp pattern.\n         * @param {string} stringToCheck The string which should be checked.\n         * @returns {boolean} Whether or not the string should be interpreted as a pattern.\n         */\n        function isPattern(stringToCheck) {\n            const firstChar = stringToCheck[0];\n\n            return firstChar === \"^\";\n        }\n\n        /**\n         * Checks if the given name matches the configured error argument.\n         * @param {string} name The name which should be compared.\n         * @returns {boolean} Whether or not the given name matches the configured error variable name.\n         */\n        function matchesConfiguredErrorName(name) {\n            if (isPattern(errorArgument)) {\n                const regexp = new RegExp(errorArgument);\n\n                return regexp.test(name);\n            }\n            return name === errorArgument;\n        }\n\n        /**\n         * Get the parameters of a given function scope.\n         * @param {Object} scope The function scope.\n         * @returns {array} All parameters of the given scope.\n         */\n        function getParameters(scope) {\n            return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === \"Parameter\");\n        }\n\n        /**\n         * Check to see if we're handling the error object properly.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         */\n        function checkForError(node) {\n            const scope = context.getScope(),\n                parameters = getParameters(scope),\n                firstParameter = parameters[0];\n\n            if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {\n                if (firstParameter.references.length === 0) {\n                    context.report({ node, message: \"Expected error to be handled.\" });\n                }\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkForError,\n            FunctionExpression: checkForError,\n            ArrowFunctionExpression: checkForError\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/id-blacklist.js":"/**\n * @fileoverview Rule that warns when identifier names that are\n * blacklisted in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const blacklist = context.options;\n\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return blacklist.indexOf(name) !== -1;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\" &&\n                effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({ node, message: \"Identifier '{{name}}' is blacklisted.\", data: {\n                name: node.name\n            } });\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // Always check object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                        node.parent.object.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                        // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Report anything that is a match and not a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/id-length.js":"/**\n * @fileoverview Rule that warns when identifier names are shorter or longer\n * than the values provided in configuration.\n * @author Burak Yigit Kaya aka BYK\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce minimum and maximum identifier lengths\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    min: {\n                        type: \"number\"\n                    },\n                    max: {\n                        type: \"number\"\n                    },\n                    exceptions: {\n                        type: \"array\",\n                        uniqueItems: true,\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n        const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n        const properties = options.properties !== \"never\";\n        const exceptions = (options.exceptions ? options.exceptions : [])\n            .reduce((obj, item) => {\n                obj[item] = true;\n\n                return obj;\n            }, {});\n\n        const SUPPORTED_EXPRESSIONS = {\n            MemberExpression: properties && function(parent) {\n                return !parent.computed && (\n\n                    // regular property assignment\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\n\n                    // or the last identifier in an ObjectPattern destructuring\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\n                );\n            },\n            AssignmentPattern(parent, node) {\n                return parent.left === node;\n            },\n            VariableDeclarator(parent, node) {\n                return parent.id === node;\n            },\n            Property: properties && function(parent, node) {\n                return parent.key === node;\n            },\n            ImportDefaultSpecifier: true,\n            RestElement: true,\n            FunctionExpression: true,\n            ArrowFunctionExpression: true,\n            ClassDeclaration: true,\n            FunctionDeclaration: true,\n            MethodDefinition: true,\n            CatchClause: true\n        };\n\n        return {\n            Identifier(node) {\n                const name = node.name;\n                const parent = node.parent;\n\n                const isShort = name.length < minLength;\n                const isLong = name.length > maxLength;\n\n                if (!(isShort || isLong) || exceptions[name]) {\n                    return;  // Nothing to report\n                }\n\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n\n                if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {\n                    context.report({\n                        node,\n                        message: isShort\n                            ? \"Identifier name '{{name}}' is too short (< {{min}}).\"\n                            : \"Identifier name '{{name}}' is too long (> {{max}}).\",\n                        data: { name, min: minLength, max: maxLength }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/id-match.js":"/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require identifiers to match a specified regular expression\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\"\n                    }\n                }\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern);\n\n        const options = context.options[1] || {},\n            properties = !!options.properties,\n            onlyDeclarations = !!options.onlyDeclarations;\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {string} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\" &&\n                effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({ node, message: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\", data: {\n                name: node.name,\n                pattern\n            } });\n        }\n\n        return {\n\n            Identifier(node) {\n                const name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!properties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                } else if (parent.type === \"Property\") {\n\n                    if (!properties || parent.key.name !== name) {\n                        return;\n                    }\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                } else {\n                    const isDeclaration = effectiveParent.type === \"FunctionDeclaration\" || effectiveParent.type === \"VariableDeclarator\";\n\n                    if (onlyDeclarations && !isDeclaration) {\n                        return;\n                    }\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/indent.js":"/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    },\n                    outerIIFEBody: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    MemberExpression: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    FunctionDeclaration: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    FunctionExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            },\n                            body: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        }\n                    },\n                    CallExpression: {\n                        type: \"object\",\n                        properties: {\n                            parameters: {\n                                oneOf: [\n                                    {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    {\n                                        enum: [\"first\"]\n                                    }\n                                ]\n                            }\n                        }\n                    },\n                    ArrayExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    },\n                    ObjectExpression: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                enum: [\"first\"]\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const DEFAULT_VARIABLE_INDENT = 1;\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\n\n        let indentType = \"space\";\n        let indentSize = 4;\n        const options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            },\n            outerIIFEBody: null,\n            FunctionDeclaration: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            FunctionExpression: {\n                parameters: DEFAULT_PARAMETER_INDENT,\n                body: DEFAULT_FUNCTION_BODY_INDENT\n            },\n            CallExpression: {\n                arguments: DEFAULT_PARAMETER_INDENT\n            },\n            ArrayExpression: 1,\n            ObjectExpression: 1\n        };\n\n        const sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                const opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                const variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n\n                if (typeof opts.outerIIFEBody === \"number\") {\n                    options.outerIIFEBody = opts.outerIIFEBody;\n                }\n\n                if (typeof opts.MemberExpression === \"number\") {\n                    options.MemberExpression = opts.MemberExpression;\n                }\n\n                if (typeof opts.FunctionDeclaration === \"object\") {\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n                }\n\n                if (typeof opts.FunctionExpression === \"object\") {\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\n                }\n\n                if (typeof opts.CallExpression === \"object\") {\n                    Object.assign(options.CallExpression, opts.CallExpression);\n                }\n\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n                    options.ArrayExpression = opts.ArrayExpression;\n                }\n\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n                    options.ObjectExpression = opts.ObjectExpression;\n                }\n            }\n        }\n\n        const caseIndentStore = {};\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n            let foundStatement;\n\n            if (actualSpaces > 0 && actualTabs > 0) {\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n            } else if (actualSpaces > 0) {\n\n                // Abbreviate the message if the expected indentation is also spaces.\n                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n            } else if (actualTabs > 0) {\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n            } else {\n                foundStatement = \"0\";\n            }\n\n            return `Expected indentation of ${expectedStatement} but found ${foundStatement}.`;\n        }\n\n        /**\n         * Reports a given indent violation\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @param {Object=} loc Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @param {int} lastNodeCheckEndOffset Number of charecters to skip from the end\n         * @returns {void}\n         */\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n            if (gottenSpaces && gottenTabs) {\n\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n                return;\n            }\n\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n\n            const textRange = isLastNodeCheck\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n\n            context.report({\n                node,\n                loc,\n                message: createErrorMessage(needed, gottenSpaces, gottenTabs),\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n            });\n        }\n\n        /**\n         * Get the actual indent of node\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\n         contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\n         `badChar` is the amount of the other indentation character.\n         */\n        function getNodeIndent(node, byLastLine) {\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n            const spaces = indentChars.filter(char => char === \" \").length;\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\n\n            return {\n                space: spaces,\n                tab: tabs,\n                goodChar: indentType === \"space\" ? spaces : tabs,\n                badChar: indentType === \"space\" ? tabs : spaces\n            };\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} neededIndent needed indent\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {void}\n         */\n        function checkNodeIndent(node, neededIndent) {\n            const actualIndent = getNodeIndent(node, false);\n\n            if (\n                node.type !== \"ArrayExpression\" &&\n                node.type !== \"ObjectExpression\" &&\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\n                isNodeFirstInLine(node)\n            ) {\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\n            }\n\n            if (node.type === \"IfStatement\" && node.alternate) {\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                checkNodeIndent(elseToken, neededIndent);\n\n                if (!isNodeFirstInLine(node.alternate)) {\n                    checkNodeIndent(node.alternate, neededIndent);\n                }\n            }\n\n            if (node.type === \"TryStatement\" && node.handler) {\n                const catchToken = sourceCode.getFirstToken(node.handler);\n\n                checkNodeIndent(catchToken, neededIndent);\n            }\n\n            if (node.type === \"TryStatement\" && node.finalizer) {\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n\n                checkNodeIndent(finallyToken, neededIndent);\n            }\n\n            if (node.type === \"DoWhileStatement\") {\n                const whileToken = sourceCode.getTokenAfter(node.body);\n\n                checkNodeIndent(whileToken, neededIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent) {\n            nodes.forEach(node => checkNodeIndent(node, indent));\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            const lastToken = sourceCode.getLastToken(node);\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent first line needed indent\n         * @returns {void}\n         */\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n\n            // in case if return statement ends with ');' we have traverse back to ')'\n            // otherwise we'll measure indent for ';' and replace ')'\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n            if (textBeforeClosingParenthesis.trim()) {\n\n                // There are tokens before the closing paren, don't report this case\n                return;\n            }\n\n            const endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent.goodChar !== firstLineIndent) {\n                report(\n                    node,\n                    firstLineIndent,\n                    endIndent.space,\n                    endIndent.tab,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            const startIndent = getNodeIndent(node, false);\n\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent.space,\n                    startIndent.tab,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns a parent node of given node based on a specified type\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @param {string} type type that is being looked for\n         * @param {string} stopAtList end points for the evaluating code\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getParentNodeByType(node, type, stopAtList) {\n            let parent = node.parent;\n\n            if (!stopAtList) {\n                stopAtList = [\"Program\"];\n            }\n\n            while (parent.type !== type && stopAtList.indexOf(parent.type) === -1 && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === type ? parent : null;\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            return getParentNodeByType(node, \"VariableDeclarator\");\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            const parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n        function isOuterIIFE(node) {\n            const parent = node.parent;\n            let stmt = parent.parent;\n\n            /*\n             * Verify that the node is an IIEF\n             */\n            if (\n                parent.type !== \"CallExpression\" ||\n                parent.callee !== node) {\n\n                return false;\n            }\n\n            /*\n             * Navigate legal ancestors to determine whether this IIEF is outer\n             */\n            while (\n                stmt.type === \"UnaryExpression\" && (\n                    stmt.operator === \"!\" ||\n                    stmt.operator === \"~\" ||\n                    stmt.operator === \"+\" ||\n                    stmt.operator === \"-\") ||\n                stmt.type === \"AssignmentExpression\" ||\n                stmt.type === \"LogicalExpression\" ||\n                stmt.type === \"SequenceExpression\" ||\n                stmt.type === \"VariableDeclarator\") {\n\n                stmt = stmt.parent;\n            }\n\n            return ((\n                    stmt.type === \"ExpressionStatement\" ||\n                    stmt.type === \"VariableDeclaration\") &&\n                stmt.parent && stmt.parent.type === \"Program\"\n            );\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            const calleeNode = node.parent; // FunctionExpression\n            let indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false, false).goodChar;\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode).goodChar;\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                const calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent).goodChar;\n                    }\n                }\n            }\n\n            // function body indent should be indent + indent size, unless this\n            // is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\n            let functionOffset = indentSize;\n\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n                functionOffset = options.outerIIFEBody * indentSize;\n            } else if (calleeNode.type === \"FunctionExpression\") {\n                functionOffset = options.FunctionExpression.body * indentSize;\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\n                functionOffset = options.FunctionDeclaration.body * indentSize;\n            }\n            indent += functionOffset;\n\n            // check if the node is inside a variable\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - functionOffset);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            const lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check to see if the first element inside an array is an object and on the same line as the node\n         * If the node is not an array then it will return false.\n         * @param {ASTNode} node node to check\n         * @returns {boolean} success/failure\n         */\n        function isFirstArrayElementOnSameLine(node) {\n            if (node.type === \"ArrayExpression\" && node.elements[0]) {\n                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === \"ObjectExpression\";\n            }\n            return false;\n\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(elem => elem !== null);\n\n            let nodeIndent;\n            let elementsIndent;\n            const parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                const parent = node.parent;\n\n                nodeIndent = getNodeIndent(parent).goodChar;\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n                            nodeIndent = nodeIndent + (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n                            if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {\n\n                                /*\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\n                                 * e.g. [{\n                                 *        foo: 1\n                                 *      },\n                                 *      {\n                                 *        bar: 1\n                                 *      }]\n                                 * the second object is not indented.\n                                 */\n                            } else if (typeof options[parent.type] === \"number\") {\n                                nodeIndent += options[parent.type] * indentSize;\n                            } else {\n                                nodeIndent = parentElements[0].loc.start.column;\n                            }\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n                            if (typeof options.CallExpression.arguments === \"number\") {\n                                nodeIndent += options.CallExpression.arguments * indentSize;\n                            } else if (options.CallExpression.arguments === \"first\") {\n                                if (parent.arguments.indexOf(node) !== -1) {\n                                    nodeIndent = parent.arguments[0].loc.start.column;\n                                }\n                            } else {\n                                nodeIndent += indentSize;\n                            }\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n                            nodeIndent += indentSize;\n                        }\n                    }\n                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== \"MemberExpression\" && parent.type !== \"ExpressionStatement\" && parent.type !== \"AssignmentExpression\" && parent.type !== \"Property\") {\n                    nodeIndent = nodeIndent + indentSize;\n                }\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node).goodChar;\n            }\n\n            if (options[node.type] === \"first\") {\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n            } else {\n                elementsIndent = nodeIndent + indentSize * options[node.type];\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            checkNodesIndent(elements, elementsIndent);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                    node.parent.type === \"FunctionExpression\" ||\n                    node.parent.type === \"FunctionDeclaration\" ||\n                    node.parent.type === \"ArrowFunctionExpression\"\n            )) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            let indent;\n            let nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            const statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent).goodChar;\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\n                indent = getNodeIndent(node.parent.parent).goodChar;\n            } else {\n                indent = getNodeIndent(node).goodChar;\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (Array.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce((finalCollection, elem) => {\n                const lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            const elements = filterOutSameLineVars(node);\n            const nodeIndent = getNodeIndent(node).goodChar;\n            const lastElement = elements[elements.length - 1];\n\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            checkNodesIndent(elements, elementsIndent);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [switchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, switchIndent) {\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            let caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            }\n            if (typeof switchIndent === \"undefined\") {\n                switchIndent = getNodeIndent(switchNode).goodChar;\n            }\n\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                caseIndent = switchIndent;\n            } else {\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\n            }\n\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\n            return caseIndent;\n\n        }\n\n        /**\n         * Checks wether a return statement is wrapped in ()\n         * @param {ASTNode} node node to examine\n         * @returns {boolean} the result\n         */\n        function isWrappedInParenthesis(node) {\n            const regex = /^return\\s*?\\(\\s*?\\);*?/;\n\n            const statementWithoutArgument = sourceCode.getText(node).replace(\n                sourceCode.getText(node.argument), \"\");\n\n            return regex.test(statementWithoutArgument);\n        }\n\n        return {\n            Program(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            MemberExpression(node) {\n\n                if (typeof options.MemberExpression === \"undefined\") {\n                    return;\n                }\n\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                // The typical layout of variable declarations and assignments\n                // alter the expectation of correct indentation. Skip them.\n                // TODO: Add appropriate configuration options for variable\n                // declarations and assignments.\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    return;\n                }\n\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n                    return;\n                }\n\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n\n                const checkNodes = [node.property];\n\n                const dot = context.getTokenBefore(node.property);\n\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\n                    checkNodes.push(dot);\n                }\n\n                checkNodesIndent(checkNodes, propertyIndent);\n            },\n\n            SwitchStatement(node) {\n\n                // Switch is not a 'BlockStatement'\n                const switchIndent = getNodeIndent(node).goodChar;\n                const caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                const caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            },\n\n            FunctionDeclaration(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionDeclaration.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n                }\n            },\n\n            FunctionExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n                } else if (options.FunctionExpression.parameters !== null) {\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n                }\n            },\n\n            ReturnStatement(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n\n                const firstLineIndent = getNodeIndent(node).goodChar;\n\n                // in case if return statement is wrapped in parenthesis\n                if (isWrappedInParenthesis(node)) {\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\n                } else {\n                    checkNodeIndent(node, firstLineIndent);\n                }\n            },\n\n            CallExpression(node) {\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n                } else if (options.CallExpression.arguments !== null) {\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/init-declarations.js":"/**\n * @fileoverview A rule to control the style of variable initializations.\n * @author Colin Ihrig\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a for loop.\n * @param {ASTNode} block - A node to check.\n * @returns {boolean} `true` when the node is a for loop.\n */\nfunction isForLoop(block) {\n    return block.type === \"ForInStatement\" ||\n    block.type === \"ForOfStatement\" ||\n    block.type === \"ForStatement\";\n}\n\n/**\n * Checks whether or not a given declarator node has its initializer.\n * @param {ASTNode} node - A declarator node to check.\n * @returns {boolean} `true` when the node has its initializer.\n */\nfunction isInitialized(node) {\n    const declaration = node.parent;\n    const block = declaration.parent;\n\n    if (isForLoop(block)) {\n        if (block.type === \"ForStatement\") {\n            return block.init === declaration;\n        }\n        return block.left === declaration;\n    }\n    return Boolean(node.init);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow initialization in variable declarations\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreForLoopInit: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        const mode = context.options[0] || MODE_ALWAYS;\n        const params = context.options[1] || {};\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n\n                const kind = node.kind,\n                    declarations = node.declarations;\n\n                for (let i = 0; i < declarations.length; ++i) {\n                    const declaration = declarations[i],\n                        id = declaration.id,\n                        initialized = isInitialized(declaration),\n                        isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);\n\n                    if (id.type !== \"Identifier\") {\n                        continue;\n                    }\n\n                    if (mode === MODE_ALWAYS && !initialized) {\n                        context.report({\n                            node: declaration,\n                            message: \"Variable '{{idName}}' should be initialized on declaration.\",\n                            data: {\n                                idName: id.name\n                            }\n                        });\n                    } else if (mode === MODE_NEVER && kind !== \"const\" && initialized && !isIgnoredForLoop) {\n                        context.report({\n                            node: declaration,\n                            message: \"Variable '{{idName}}' should not be initialized on declaration.\",\n                            data: {\n                                idName: id.name\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/jsx-quotes.js":"/**\n * @fileoverview A rule to ensure consistent quotes used in jsx syntax.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    \"prefer-double\": {\n        quote: \"\\\"\",\n        description: \"singlequote\",\n        convert(str) {\n            return str.replace(/'/g, \"\\\"\");\n        }\n    },\n    \"prefer-single\": {\n        quote: \"'\",\n        description: \"doublequote\",\n        convert(str) {\n            return str.replace(/\"/g, \"'\");\n        }\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either double or single quotes in JSX attributes\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"prefer-single\", \"prefer-double\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const quoteOption = context.options[0] || \"prefer-double\",\n            setting = QUOTE_SETTINGS[quoteOption];\n\n        /**\n         * Checks if the given string literal node uses the expected quotes\n         * @param {ASTNode} node - A string literal node.\n         * @returns {boolean} Whether or not the string literal used the expected quotes.\n         * @public\n         */\n        function usesExpectedQuotes(node) {\n            return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);\n        }\n\n        return {\n            JSXAttribute(node) {\n                const attributeValue = node.value;\n\n                if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {\n                    context.report({\n                        node: attributeValue,\n                        message: \"Unexpected usage of {{description}}.\",\n                        data: {\n                            description: setting.description\n                        },\n                        fix(fixer) {\n                            return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/key-spacing.js":"/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return astUtils.LINEBREAK_MATCHER.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a property is a member of the property group it follows.\n * @param {ASTNode} lastMember The last Property known to be in the group.\n * @param {ASTNode} candidate The next Property that might be in the group.\n * @returns {boolean} True if the candidate property is part of the group.\n */\nfunction continuesPropertyGroup(lastMember, candidate) {\n    const groupEndLine = lastMember.loc.start.line,\n        candidateStartLine = candidate.loc.start.line;\n\n    if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n    }\n\n    // Check that the first comment is adjacent to the end of the group, the\n    // last comment is adjacent to the candidate property, and that successive\n    // comments are adjacent to each other.\n    const comments = candidate.leadingComments;\n\n    if (\n        comments &&\n        comments[0].loc.start.line - groupEndLine <= 1 &&\n        candidateStartLine - last(comments).loc.end.line <= 1\n    ) {\n        for (let i = 1; i < comments.length; i++) {\n            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptionProperty(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    // Set align if exists\n    if (typeof fromOptions.align !== \"undefined\") {\n        if (typeof fromOptions.align === \"object\") {\n            toOptions.align = fromOptions.align;\n        } else { // \"string\"\n            toOptions.align = {\n                on: fromOptions.align,\n                mode: toOptions.mode,\n                beforeColon: toOptions.beforeColon,\n                afterColon: toOptions.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    if (typeof fromOptions.align === \"object\") {\n\n        // Initialize the alignment configuration\n        toOptions.align = initOptionProperty({}, fromOptions.align);\n        toOptions.align.on = fromOptions.align.on || \"colon\";\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\n\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n    } else { // string or undefined\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n        if (toOptions.multiLine.align) {\n            toOptions.align = {\n                on: toOptions.multiLine.align.on,\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n                beforeColon: toOptions.multiLine.align.beforeColon,\n                afterColon: toOptions.multiLine.align.afterColon\n            };\n        }\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst messages = {\n    key: \"{{error}} space after {{computed}}key '{{key}}'.\",\n    value: \"{{error}} space before value for {{computed}}key '{{key}}'.\"\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            anyOf: [\n                                {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                {\n                                    type: \"object\",\n                                    properties: {\n                                        mode: {\n                                            enum: [\"strict\", \"minimum\"]\n                                        },\n                                        on: {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        beforeColon: {\n                                            type: \"boolean\"\n                                        },\n                                        afterColon: {\n                                            type: \"boolean\"\n                                        }\n                                    },\n                                    additionalProperties: false\n                                }\n                            ]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    anyOf: [\n                                        {\n                                            enum: [\"colon\", \"value\"]\n                                        },\n                                        {\n                                            type: \"object\",\n                                            properties: {\n                                                mode: {\n                                                    enum: [\"strict\", \"minimum\"]\n                                                },\n                                                on: {\n                                                    enum: [\"colon\", \"value\"]\n                                                },\n                                                beforeColon: {\n                                                    type: \"boolean\"\n                                                },\n                                                afterColon: {\n                                                    type: \"boolean\"\n                                                }\n                                            },\n                                            additionalProperties: false\n                                        }\n                                    ]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        align: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                on: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }]\n    },\n\n    create(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n        const options = context.options[0] || {},\n            ruleOptions = initOptions({}, options),\n            multiLineOptions = ruleOptions.multiLine,\n            singleLineOptions = ruleOptions.singleLine,\n            alignmentOptions = ruleOptions.align || null;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadProperty\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n\n            return sourceCode.getTokenBefore(colonToken);\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            const key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n\n            return property.key.name || property.key.value;\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            const diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\n                isKeySide = side === \"key\",\n                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \");\n            let fix;\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                if (isExtra) {\n                    let range;\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.end, tokenBeforeColon.end + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.start - diffAbs, tokenAfterColon.start];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                context.report({\n                    node: property[side],\n                    loc: locStart,\n                    message: messages[side],\n                    data: {\n                        error: isExtra ? \"Extra\" : \"Missing\",\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            const startToken = sourceCode.getFirstToken(property);\n            const endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            const whitespace = /(\\s*):(\\s*)/.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce((groups, property) => {\n                const currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            const length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                align = alignmentOptions.on; // \"value\" or \"colon\"\n            let targetWidth = Math.max.apply(null, widths),\n                beforeColon, afterColon, mode;\n\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\n                beforeColon = alignmentOptions.beforeColon;\n                afterColon = alignmentOptions.afterColon;\n                mode = alignmentOptions.mode;\n            } else {\n                beforeColon = multiLineOptions.beforeColon;\n                afterColon = multiLineOptions.afterColon;\n                mode = alignmentOptions.mode;\n            }\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (let i = 0; i < length; i++) {\n                const property = properties[i];\n                const whitespace = getPropertyWhitespace(property);\n\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    const width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(group => {\n                verifyGroupAlignment(group.filter(isKeyValueProperty));\n            });\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            const actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param  {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyListSpacing(properties) {\n            const length = properties.length;\n\n            for (let i = 0; i < length; i++) {\n                verifySpacing(properties[i], singleLineOptions);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (alignmentOptions) { // Verify vertical alignment\n\n            return {\n                ObjectExpression(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty));\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        }\n\n        // Obey beforeColon and afterColon in each property as configured\n        return {\n            Property(node) {\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n            }\n        };\n\n\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/keyword-spacing.js":"/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PREV_TOKEN = /^[)\\]}>]$/;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/;\nconst NEXT_TOKEN_M = /^[{*]$/;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (let i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after keywords\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: { type: \"boolean\" },\n                    after: { type: \"boolean\" },\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce((retv, key) => {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: { type: \"boolean\" },\n                                    after: { type: \"boolean\" }\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            pattern = pattern || PREV_TOKEN;\n\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Expected space(s) before \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            pattern = pattern || PREV_TOKEN;\n\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            pattern = pattern || NEXT_TOKEN;\n\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Expected space(s) after \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            pattern = pattern || NEXT_TOKEN;\n\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Unexpected space(s) after \\\"{{value}}\\\".\",\n                    data: token,\n                    fix(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         *\n         * @param {Object|undefined} options - The option object to parse.\n         * @returns {Object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options) {\n            const before = !options || options.before !== false;\n            const after = !options || options.after !== false;\n            const defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            const overrides = (options && options.overrides) || {};\n            const retv = Object.create(null);\n\n            for (let i = 0; i < KEYS.length; ++i) {\n                const key = KEYS[i];\n                const override = overrides[key];\n\n                if (override) {\n                    const thisBefore = (\"before\" in override) ? override.before : before;\n                    const thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        const checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `async` or `function` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForFunction(node) {\n            const firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken &&\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\n                firstToken.value === \"async\")\n            ) {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.right);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            const firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.source) {\n                const fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            const asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" ||\n                node.kind === \"set\" ||\n                (\n                    (node.method || node.type === \"MethodDefinition\") &&\n                    node.value.async\n                )\n            ) {\n                const token = sourceCode.getTokenBefore(\n                    node.key,\n                    tok => {\n                        switch (tok.value) {\n                            case \"get\":\n                            case \"set\":\n                            case \"async\":\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                );\n\n                if (!token) {\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\n                }\n\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `await` keyword of a given node if usage of spacing before\n         * this keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForAwaitExpression(node) {\n            checkSpacingBefore(sourceCode.getFirstToken(node));\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingAroundFirstToken,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingForFunction,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ArrowFunctionExpression: checkSpacingForFunction,\n            AwaitExpression: checkSpacingForAwaitExpression,\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingForFunction,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            Property: checkSpacingForProperty\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/line-comment-position.js":"/**\n * @fileoverview Rule to enforce the position of line comments\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce position of line comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"above\", \"beside\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            position: {\n                                enum: [\"above\", \"beside\"]\n                            },\n                            ignorePattern: {\n                                type: \"string\"\n                            },\n                            applyDefaultPatterns: {\n                                type: \"boolean\"\n                            },\n                            applyDefaultIgnorePatterns: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n\n        let above,\n            ignorePattern,\n            applyDefaultIgnorePatterns = true;\n\n        if (!options || typeof options === \"string\") {\n            above = !options || options === \"above\";\n\n        } else {\n            above = options.position === \"above\";\n            ignorePattern = options.ignorePattern;\n\n            if (options.hasOwnProperty(\"applyDefaultIgnorePatterns\")) {\n                applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n            } else {\n                applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;\n            }\n        }\n\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const fallThroughRegExp = /^\\s*falls?\\s?through/;\n        const customIgnoreRegExp = new RegExp(ignorePattern);\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            LineComment(node) {\n                if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {\n                    return;\n                }\n\n                if (ignorePattern && customIgnoreRegExp.test(node.value)) {\n                    return;\n                }\n\n                const previous = sourceCode.getTokenBefore(node, { includeComments: true });\n                const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;\n\n                if (above) {\n                    if (isOnSameLine) {\n                        context.report({\n                            node,\n                            message: \"Expected comment to be above code.\"\n                        });\n                    }\n                } else {\n                    if (!isOnSameLine) {\n                        context.report({\n                            node,\n                            message: \"Expected comment to be beside code.\"\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/linebreak-style.js":"/**\n * @fileoverview Rule to enforce a single linebreak style.\n * @author Erik Mueller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent linebreak style\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"unix\", \"windows\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const EXPECTED_LF_MSG = \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n            EXPECTED_CRLF_MSG = \"Expected linebreaks to be 'CRLF' but found 'LF'.\";\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Builds a fix function that replaces text at the specified range in the source text.\n         * @param {int[]} range The range to replace\n         * @param {string} text The text to insert.\n         * @returns {Function} Fixer function\n         * @private\n         */\n        function createFix(range, text) {\n            return function(fixer) {\n                return fixer.replaceTextRange(range, text);\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkForlinebreakStyle(node) {\n                const linebreakStyle = context.options[0] || \"unix\",\n                    expectedLF = linebreakStyle === \"unix\",\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n                    source = sourceCode.getText(),\n                    pattern = astUtils.createGlobalLinebreakMatcher();\n                let match;\n\n                let i = 0;\n\n                while ((match = pattern.exec(source)) !== null) {\n                    i++;\n                    if (match[0] === expectedLFChars) {\n                        continue;\n                    }\n\n                    const index = match.index;\n                    const range = [index, index + match[0].length];\n\n                    context.report({\n                        node,\n                        loc: {\n                            line: i,\n                            column: sourceCode.lines[i - 1].length\n                        },\n                        message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,\n                        fix: createFix(range, expectedLFChars)\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/lines-around-comment.js":"/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    const emptyLines = lines.map((line, i) => ({\n        code: line.trim(),\n        num: i + 1\n    })).filter(line => !line.code).map(line => line.num);\n\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment nodes.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    const lines = [];\n\n    comments.forEach(token => {\n        const start = token.loc.start.line;\n        const end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require empty lines around comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\"\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\"\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\"\n                    },\n                    afterLineComment: {\n                        type: \"boolean\"\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\"\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    },\n                    ignorePattern: {\n                        type: \"string\"\n                    },\n                    applyDefaultIgnorePatterns: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] ? Object.assign({}, context.options[0]) : {};\n        const ignorePattern = options.ignorePattern;\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n        const customIgnoreRegExp = new RegExp(ignorePattern);\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n\n\n        options.beforeLineComment = options.beforeLineComment || false;\n        options.afterLineComment = options.afterLineComment || false;\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n        options.afterBlockComment = options.afterBlockComment || false;\n        options.allowBlockStart = options.allowBlockStart || false;\n        options.allowBlockEnd = options.allowBlockEnd || false;\n\n        const sourceCode = context.getSourceCode();\n\n        const lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(node) {\n            let token;\n\n            token = node;\n            do {\n                token = sourceCode.getTokenBefore(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, node)) {\n                return true;\n            }\n\n            token = node;\n            do {\n                token = sourceCode.getTokenAfter(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(node, token)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} node The Comment node.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isCommentInsideNodeType(node, parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {ASTNode} node The Comment node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(node, nodeType) {\n            const ancestors = context.getAncestors();\n            let parent;\n\n            if (ancestors.length) {\n                parent = ancestors.pop();\n            }\n\n            return parent && isCommentInsideNodeType(node, parent, nodeType) &&\n                    node.loc.start.line - parent.loc.start.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {ASTNode} node The Comment node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(node, nodeType) {\n            const ancestors = context.getAncestors();\n            let parent;\n\n            if (ancestors.length) {\n                parent = ancestors.pop();\n            }\n\n            return parent && isCommentInsideNodeType(node, parent, nodeType) &&\n                    parent.loc.end.line - node.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(node) {\n            return isCommentAtParentStart(node, \"ClassBody\") || isCommentAtParentStart(node, \"BlockStatement\") || isCommentAtParentStart(node, \"SwitchCase\");\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(node) {\n            return isCommentAtParentEnd(node, \"ClassBody\") || isCommentAtParentEnd(node, \"BlockStatement\") || isCommentAtParentEnd(node, \"SwitchCase\") || isCommentAtParentEnd(node, \"SwitchStatement\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(node) {\n            return isCommentAtParentStart(node, \"ObjectExpression\") || isCommentAtParentStart(node, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(node) {\n            return isCommentAtParentEnd(node, \"ObjectExpression\") || isCommentAtParentEnd(node, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(node) {\n            return isCommentAtParentStart(node, \"ArrayExpression\") || isCommentAtParentStart(node, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(node) {\n            return isCommentAtParentEnd(node, \"ArrayExpression\") || isCommentAtParentEnd(node, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment node has lines around it (ignores inline comments)\n         * @param {ASTNode} node The Comment node.\n         * @param {Object} opts Options to determine the newline.\n         * @param {boolean} opts.after Should have a newline after this line.\n         * @param {boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(node, opts) {\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(node.value)) {\n                return;\n            }\n\n            if (ignorePattern && customIgnoreRegExp.test(node.value)) {\n                return;\n            }\n\n            let after = opts.after,\n                before = opts.before;\n\n            const prevLineNum = node.loc.start.line - 1,\n                nextLineNum = node.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(node);\n\n            const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(node),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(node),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(node),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(node);\n\n            const exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;\n            const exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            const previousTokenOrComment = sourceCode.getTokenBefore(node, { includeComments: true });\n            const nextTokenOrComment = sourceCode.getTokenAfter(node, { includeComments: true });\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) &&\n                    !(isCommentNodeType(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, node))) {\n                const lineStart = node.range[0] - node.loc.start.column;\n                const range = [lineStart, lineStart];\n\n                context.report({\n                    node,\n                    message: \"Expected line before comment.\",\n                    fix(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) &&\n                    !(isCommentNodeType(nextTokenOrComment) && astUtils.isTokenOnSameLine(node, nextTokenOrComment))) {\n                context.report({\n                    node,\n                    message: \"Expected line after comment.\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(node, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LineComment(node) {\n                if (options.beforeLineComment || options.afterLineComment) {\n                    checkForEmptyLine(node, {\n                        after: options.afterLineComment,\n                        before: options.beforeLineComment\n                    });\n                }\n            },\n\n            BlockComment(node) {\n                if (options.beforeBlockComment || options.afterBlockComment) {\n                    checkForEmptyLine(node, {\n                        after: options.afterBlockComment,\n                        before: options.beforeBlockComment\n                    });\n                }\n            }\n\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/lines-around-directive.js":"/**\n * @fileoverview Require or disallow newlines around directives.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow newlines around directives\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [{\n            oneOf: [\n                {\n                    enum: [\"always\", \"never\"]\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        before: {\n                            enum: [\"always\", \"never\"]\n                        },\n                        after: {\n                            enum: [\"always\", \"never\"]\n                        }\n                    },\n                    additionalProperties: false,\n                    minProperties: 2\n                }\n            ]\n        }],\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const config = context.options[0] || \"always\";\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if node is preceded by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\n         */\n        function hasNewlineBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n\n            return node.loc.start.line - tokenLineBefore >= 2;\n        }\n\n        /**\n        * Gets the last token of a node that is on the same line as the rest of the node.\n        * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\n        * semicolon on a different line.\n        * @param {ASTNode} node A directive node\n        * @returns {Token} The last token of the node on the line\n        */\n        function getLastTokenOnLine(node) {\n            const lastToken = sourceCode.getLastToken(node);\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\n                ? secondToLastToken\n                : lastToken;\n        }\n\n        /**\n         * Check if node is followed by a blank newline.\n         * @param {ASTNode} node Node to check.\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\n         */\n        function hasNewlineAfter(node) {\n            const lastToken = getLastTokenOnLine(node);\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\n\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n        }\n\n        /**\n         * Report errors for newlines around directives.\n         * @param {ASTNode} node Node to check.\n         * @param {string} location Whether the error was found before or after the directive.\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\n         * @returns {void}\n         */\n        function reportError(node, location, expected) {\n            context.report({\n                node,\n                message: \"{{expected}} newline {{location}} \\\"{{value}}\\\" directive.\",\n                data: {\n                    expected: expected ? \"Expected\" : \"Unexpected\",\n                    value: node.expression.value,\n                    location\n                },\n                fix(fixer) {\n                    const lastToken = getLastTokenOnLine(node);\n\n                    if (expected) {\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n                    }\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n                }\n            });\n        }\n\n        /**\n         * Check lines around directives in node\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkDirectives(node) {\n            const directives = astUtils.getDirectivePrologue(node);\n\n            if (!directives.length) {\n                return;\n            }\n\n            const firstDirective = directives[0];\n            const hasTokenOrCommentBefore = !!sourceCode.getTokenBefore(firstDirective, { includeComments: true });\n\n            // Only check before the first directive if it is preceded by a comment or if it is at the top of\n            // the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\n            // the file if there are no comments as well as for compatibility with padded-blocks.\n            if (\n                firstDirective.leadingComments && firstDirective.leadingComments.length ||\n\n                // Shebangs are not added to leading comments but are accounted for by the following.\n                node.type === \"Program\" && hasTokenOrCommentBefore\n            ) {\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", true);\n                }\n\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n                    reportError(firstDirective, \"before\", false);\n                }\n            } else if (\n                node.type === \"Program\" &&\n                expectLineBefore === \"never\" &&\n                !hasTokenOrCommentBefore &&\n                hasNewlineBefore(firstDirective)\n            ) {\n                reportError(firstDirective, \"before\", false);\n            }\n\n            const lastDirective = directives[directives.length - 1];\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            // Do not check after the last directive if the body only\n            // contains a directive prologue and isn't followed by a comment to ensure\n            // this rule behaves well with padded-blocks.\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n                return;\n            }\n\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", true);\n            }\n\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n                reportError(lastDirective, \"after\", false);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkDirectives,\n            FunctionDeclaration: checkDirectives,\n            FunctionExpression: checkDirectives,\n            ArrowFunctionExpression: checkDirectives\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-depth.js":"/**\n * @fileoverview A rule to set the maximum depth block can be nested in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum depth that blocks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0];\n        let maxDepth = 4;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            maxDepth = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            maxDepth = option.max;\n        }\n        if (typeof option === \"number\") {\n            maxDepth = option;\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * When parsing is done then pop out the reference\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n        }\n\n        /**\n         * Save the block and Evaluate the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function pushBlock(node) {\n            const len = ++functionStack[functionStack.length - 1];\n\n            if (len > maxDepth) {\n                context.report({ node, message: \"Blocks are nested too deeply ({{depth}}).\", data: { depth: len } });\n            }\n        }\n\n        /**\n         * Pop the saved block\n         * @returns {void}\n         * @private\n         */\n        function popBlock() {\n            functionStack[functionStack.length - 1]--;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            IfStatement(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    pushBlock(node);\n                }\n            },\n            SwitchStatement: pushBlock,\n            TryStatement: pushBlock,\n            DoWhileStatement: pushBlock,\n            WhileStatement: pushBlock,\n            WithStatement: pushBlock,\n            ForStatement: pushBlock,\n            ForInStatement: pushBlock,\n            ForOfStatement: pushBlock,\n\n            \"IfStatement:exit\": popBlock,\n            \"SwitchStatement:exit\": popBlock,\n            \"TryStatement:exit\": popBlock,\n            \"DoWhileStatement:exit\": popBlock,\n            \"WhileStatement:exit\": popBlock,\n            \"WithStatement:exit\": popBlock,\n            \"ForStatement:exit\": popBlock,\n            \"ForInStatement:exit\": popBlock,\n            \"ForOfStatement:exit\": popBlock,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n            \"Program:exit\": endFunction\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-len.js":"/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\"\n        },\n        ignoreStrings: {\n            type: \"boolean\"\n        },\n        ignoreUrls: {\n            type: \"boolean\"\n        },\n        ignoreTemplateLiterals: {\n            type: \"boolean\"\n        },\n        ignoreRegExpLiterals: {\n            type: \"boolean\"\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum line length\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ]\n    },\n\n    create(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            let extraCharacterCount = 0;\n\n            line.replace(/\\t/g, (match, offset) => {\n                const totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1;  // -1 for the replaced tab\n            });\n            return Array.from(line).length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specified…\n        const lastOption = context.options[context.options.length - 1];\n        const options = typeof lastOption === \"object\" ? Object.create(lastOption) : {};\n\n        // …but max code length…\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // …and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        const maxLength = options.code || 80,\n            tabWidth = options.tabWidth || 4,\n            ignoreComments = options.ignoreComments || false,\n            ignoreStrings = options.ignoreStrings || false,\n            ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,\n            ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,\n            ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,\n            ignoreUrls = options.ignoreUrls || false,\n            maxCommentLength = options.comments;\n        let ignorePattern = options.ignorePattern || null;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern);\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            const start = comment.loc.start,\n                end = comment.loc.end,\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitepace\n         */\n        function stripTrailingComment(line, lineNumber, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/, \"\");\n        }\n\n        /**\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\n         *\n         * @param {Object} object the object to mutate\n         * @param {string} key the object's key\n         * @param {*} value the value to add\n         * @returns {void}\n         * @private\n         */\n        function ensureArrayAndPush(object, key, value) {\n            if (!Array.isArray(object[key])) {\n                object[key] = [];\n            }\n            object[key].push(value);\n        }\n\n        /**\n         * Retrieves an array containing all strings (\" or ') in the source code.\n         *\n         * @returns {ASTNode[]} An array of string nodes.\n         */\n        function getAllStrings() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"String\");\n        }\n\n        /**\n         * Retrieves an array containing all template literals in the source code.\n         *\n         * @returns {ASTNode[]} An array of template literal nodes.\n         */\n        function getAllTemplateLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n        }\n\n\n        /**\n         * Retrieves an array containing all RegExp literals in the source code.\n         *\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\n         */\n        function getAllRegExpLiterals() {\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n        }\n\n\n        /**\n         * A reducer to group an AST node by line number, both start and end.\n         *\n         * @param {Object} acc the accumulator\n         * @param {ASTNode} node the AST node in question\n         * @returns {Object} the modified accumulator\n         * @private\n         */\n        function groupByLineNumber(acc, node) {\n            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n                ensureArrayAndPush(acc, i, node);\n            }\n            return acc;\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            const lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];\n\n                // we iterate over comments in parallel with the lines\n            let commentsIndex = 0;\n\n            const strings = getAllStrings(sourceCode);\n            const stringsByLine = strings.reduce(groupByLineNumber, {});\n\n            const templateLiterals = getAllTemplateLiterals(sourceCode);\n            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n\n            const regExpLiterals = getAllRegExpLiterals(sourceCode);\n            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n\n            lines.forEach((line, i) => {\n\n                // i is zero-indexed, line numbers are one-indexed\n                const lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                let lineIsComment = false;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n                    let comment = null;\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        line = stripTrailingComment(line, lineNumber, comment);\n                    }\n                }\n                if (ignorePattern && ignorePattern.test(line) ||\n                    ignoreUrls && URL_REGEXP.test(line) ||\n                    ignoreStrings && stringsByLine[lineNumber] ||\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\n                ) {\n\n                    // ignore this line\n                    return;\n                }\n\n                const lineLength = computeLineLength(line, tabWidth);\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                if (lineIsComment && lineLength > maxCommentLength) {\n                    context.report({\n                        node,\n                        loc: { line: lineNumber, column: 0 },\n                        message: \"Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.\",\n                        data: {\n                            lineNumber: i + 1,\n                            maxCommentLength\n                        }\n                    });\n                } else if (lineLength > maxLength) {\n                    context.report({\n                        node,\n                        loc: { line: lineNumber, column: 0 },\n                        message: \"Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.\",\n                        data: {\n                            lineNumber: i + 1,\n                            maxLength\n                        }\n                    });\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-lines.js":"/**\n * @fileoverview enforce a maximum file length\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of lines per file\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            skipComments: {\n                                type: \"boolean\"\n                            },\n                            skipBlankLines: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const option = context.options[0];\n        let max = 300;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            max = option.max;\n        }\n\n        if (typeof option === \"number\") {\n            max = option;\n        }\n\n        const skipComments = option && option.skipComments;\n        const skipBlankLines = option && option.skipBlankLines;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns the line numbers of a comment that don't have any code on the same line\n         * @param {Node} comment The comment node to check\n         * @returns {int[]} The line numbers\n         */\n        function getLinesWithoutCode(comment) {\n            let start = comment.loc.start.line;\n            let end = comment.loc.end.line;\n\n            let token;\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenBefore(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\n                start += 1;\n            }\n\n            token = comment;\n            do {\n                token = sourceCode.getTokenAfter(token, { includeComments: true });\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\n                end -= 1;\n            }\n\n            if (start <= end) {\n                return lodash.range(start, end + 1);\n            }\n            return [];\n        }\n\n        return {\n            \"Program:exit\"() {\n                let lines = sourceCode.lines.map((text, i) => ({ lineNumber: i + 1, text }));\n\n                if (skipBlankLines) {\n                    lines = lines.filter(l => l.text.trim() !== \"\");\n                }\n\n                if (skipComments) {\n                    const comments = sourceCode.getAllComments();\n\n                    const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));\n\n                    lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));\n                }\n\n                if (lines.length > max) {\n                    context.report({\n                        loc: { line: 1, column: 0 },\n                        message: \"File must be at most {{max}} lines long. It's {{actual}} lines long.\",\n                        data: {\n                            max,\n                            actual: lines.length\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-nested-callbacks.js":"/**\n * @fileoverview Rule to enforce a maximum number of nested callbacks.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum depth that callbacks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Constants\n        //--------------------------------------------------------------------------\n        const option = context.options[0];\n        let THRESHOLD = 10;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            THRESHOLD = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            THRESHOLD = option.max;\n        }\n        if (typeof option === \"number\") {\n            THRESHOLD = option;\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const callbackStack = [];\n\n        /**\n         * Checks a given function node for too many callbacks.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"CallExpression\") {\n                callbackStack.push(node);\n            }\n\n            if (callbackStack.length > THRESHOLD) {\n                const opts = { num: callbackStack.length, max: THRESHOLD };\n\n                context.report({ node, message: \"Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.\", data: opts });\n            }\n        }\n\n        /**\n         * Pops the call stack.\n         * @returns {void}\n         * @private\n         */\n        function popStack() {\n            callbackStack.pop();\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            \"ArrowFunctionExpression:exit\": popStack,\n\n            FunctionExpression: checkFunction,\n            \"FunctionExpression:exit\": popStack\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-params.js":"/**\n * @fileoverview Rule to flag when a function has too many parameters\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of parameters in function definitions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const option = context.options[0];\n        let numParams = 3;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            numParams = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            numParams = option.max;\n        }\n        if (typeof option === \"number\") {\n            numParams = option;\n        }\n\n        /**\n         * Checks a function to see if it has too many parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            if (node.params.length > numParams) {\n                context.report({\n                    node,\n                    message: \"{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.\",\n                    data: {\n                        name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),\n                        count: node.params.length,\n                        max: numParams\n                    }\n                });\n            }\n        }\n\n        return {\n            FunctionDeclaration: checkFunction,\n            ArrowFunctionExpression: checkFunction,\n            FunctionExpression: checkFunction\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-statements-per-line.js":"/**\n * @fileoverview Specify the maximum number of statements allowed per line.\n * @author Kenneth Williams\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of statements allowed per line\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 1\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            maxStatementsPerLine = typeof options.max !== \"undefined\" ? options.max : 1,\n            message = \"This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.\";\n\n        let lastStatementLine = 0,\n            numberOfStatementsOnThisLine = 0,\n            firstExtraStatement;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;\n\n        /**\n         * Reports with the first extra statement, and clears it.\n         *\n         * @returns {void}\n         */\n        function reportFirstExtraStatementAndClear() {\n            if (firstExtraStatement) {\n                context.report({\n                    node: firstExtraStatement,\n                    message,\n                    data: {\n                        numberOfStatementsOnThisLine,\n                        maxStatementsPerLine,\n                        statements: numberOfStatementsOnThisLine === 1 ? \"statement\" : \"statements\"\n                    }\n                });\n            }\n            firstExtraStatement = null;\n        }\n\n        /**\n         * Gets the actual last token of a given node.\n         *\n         * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.\n         * @returns {Token} The actual last token.\n         */\n        function getActualLastToken(node) {\n            return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n        }\n\n        /**\n         * Addresses a given node.\n         * It updates the state of this rule, then reports the node if the node violated this rule.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function enterStatement(node) {\n            const line = node.loc.start.line;\n\n            // Skip to allow non-block statements if this is direct child of control statements.\n            // `if (a) foo();` is counted as 1.\n            // But `if (a) foo(); else foo();` should be counted as 2.\n            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&\n                node.parent.alternate !== node\n            ) {\n                return;\n            }\n\n            // Update state.\n            if (line === lastStatementLine) {\n                numberOfStatementsOnThisLine += 1;\n            } else {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n\n            // Reports if the node violated this rule.\n            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {\n                firstExtraStatement = firstExtraStatement || node;\n            }\n        }\n\n        /**\n         * Updates the state of this rule with the end line of leaving node to check with the next statement.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function leaveStatement(node) {\n            const line = getActualLastToken(node).loc.end.line;\n\n            // Update state.\n            if (line !== lastStatementLine) {\n                reportFirstExtraStatementAndClear();\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BreakStatement: enterStatement,\n            ClassDeclaration: enterStatement,\n            ContinueStatement: enterStatement,\n            DebuggerStatement: enterStatement,\n            DoWhileStatement: enterStatement,\n            ExpressionStatement: enterStatement,\n            ForInStatement: enterStatement,\n            ForOfStatement: enterStatement,\n            ForStatement: enterStatement,\n            FunctionDeclaration: enterStatement,\n            IfStatement: enterStatement,\n            ImportDeclaration: enterStatement,\n            LabeledStatement: enterStatement,\n            ReturnStatement: enterStatement,\n            SwitchStatement: enterStatement,\n            ThrowStatement: enterStatement,\n            TryStatement: enterStatement,\n            VariableDeclaration: enterStatement,\n            WhileStatement: enterStatement,\n            WithStatement: enterStatement,\n            ExportNamedDeclaration: enterStatement,\n            ExportDefaultDeclaration: enterStatement,\n            ExportAllDeclaration: enterStatement,\n\n            \"BreakStatement:exit\": leaveStatement,\n            \"ClassDeclaration:exit\": leaveStatement,\n            \"ContinueStatement:exit\": leaveStatement,\n            \"DebuggerStatement:exit\": leaveStatement,\n            \"DoWhileStatement:exit\": leaveStatement,\n            \"ExpressionStatement:exit\": leaveStatement,\n            \"ForInStatement:exit\": leaveStatement,\n            \"ForOfStatement:exit\": leaveStatement,\n            \"ForStatement:exit\": leaveStatement,\n            \"FunctionDeclaration:exit\": leaveStatement,\n            \"IfStatement:exit\": leaveStatement,\n            \"ImportDeclaration:exit\": leaveStatement,\n            \"LabeledStatement:exit\": leaveStatement,\n            \"ReturnStatement:exit\": leaveStatement,\n            \"SwitchStatement:exit\": leaveStatement,\n            \"ThrowStatement:exit\": leaveStatement,\n            \"TryStatement:exit\": leaveStatement,\n            \"VariableDeclaration:exit\": leaveStatement,\n            \"WhileStatement:exit\": leaveStatement,\n            \"WithStatement:exit\": leaveStatement,\n            \"ExportNamedDeclaration:exit\": leaveStatement,\n            \"ExportDefaultDeclaration:exit\": leaveStatement,\n            \"ExportAllDeclaration:exit\": leaveStatement,\n            \"Program:exit\": reportFirstExtraStatementAndClear\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/max-statements.js":"/**\n * @fileoverview A rule to set the maximum number of statements in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of statements allowed in function blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    ignoreTopLevelFunctions: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [],\n            option = context.options[0],\n            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\n            topLevelFunctions = [];\n        let maxStatements = 10;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            maxStatements = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            maxStatements = option.max;\n        }\n        if (typeof option === \"number\") {\n            maxStatements = option;\n        }\n\n        /**\n         * Reports a node if it has too many statements\n         * @param {ASTNode} node node to evaluate\n         * @param {int} count Number of statements in node\n         * @param {int} max Maximum number of statements allowed\n         * @returns {void}\n         * @private\n         */\n        function reportIfTooManyStatements(node, count, max) {\n            if (count > max) {\n                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));\n\n                context.report({\n                    node,\n                    message: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\",\n                    data: { name, count, max }\n                });\n            }\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * Evaluate the node at the end of function\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function endFunction(node) {\n            const count = functionStack.pop();\n\n            if (ignoreTopLevelFunctions && functionStack.length === 0) {\n                topLevelFunctions.push({ node, count });\n            } else {\n                reportIfTooManyStatements(node, count, maxStatements);\n            }\n        }\n\n        /**\n         * Increment the count of the functions\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function countStatements(node) {\n            functionStack[functionStack.length - 1] += node.body.length;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            BlockStatement: countStatements,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n\n            \"Program:exit\"() {\n                if (topLevelFunctions.length === 1) {\n                    return;\n                }\n\n                topLevelFunctions.forEach(element => {\n                    const count = element.count;\n                    const node = element.node;\n\n                    reportIfTooManyStatements(node, count, maxStatements);\n                });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/multiline-ternary.js":"/**\n * @fileoverview Enforce newlines between operands of ternary expressions\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce newlines between operands of ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const multiline = context.options[0] !== \"never\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {ASTNode} parentNode - parent of node to report\n         * @param {boolean} expected - whether newline was expected or not\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, parentNode, expected) {\n            context.report({\n                node,\n                message: \"{{expected}} newline between {{typeOfError}} of ternary expression.\",\n                data: {\n                    expected: expected ? \"Expected\" : \"Unexpected\",\n                    typeOfError: node === parentNode.test ? \"test and consequent\" : \"consequent and alternate\"\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression(node) {\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);\n\n                if (!multiline) {\n                    if (!areTestAndConsequentOnSameLine) {\n                        reportError(node.test, node, false);\n                    }\n\n                    if (!areConsequentAndAlternateOnSameLine) {\n                        reportError(node.consequent, node, false);\n                    }\n                } else {\n                    if (areTestAndConsequentOnSameLine) {\n                        reportError(node.test, node, true);\n                    }\n\n                    if (areConsequentAndAlternateOnSameLine) {\n                        reportError(node.consequent, node, true);\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/new-cap.js":"/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst CAPS_ALLOWED = [\n    \"Array\",\n    \"Boolean\",\n    \"Date\",\n    \"Error\",\n    \"Function\",\n    \"Number\",\n    \"Object\",\n    \"RegExp\",\n    \"String\",\n    \"Symbol\"\n];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n\n    /* istanbul ignore if */\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n        throw new TypeError(`${key}, if provided, must be an Array`);\n    }\n    return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n    map[key] = true;\n    return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n    let capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n    if (capIsNewExceptions !== CAPS_ALLOWED) {\n        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n    }\n\n    return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require constructor names to begin with a capital letter\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    newIsCap: {\n                        type: \"boolean\"\n                    },\n                    capIsNew: {\n                        type: \"boolean\"\n                    },\n                    newIsCapExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    newIsCapExceptionPattern: {\n                        type: \"string\"\n                    },\n                    capIsNewExceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    capIsNewExceptionPattern: {\n                        type: \"string\"\n                    },\n                    properties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};\n\n        config.newIsCap = config.newIsCap !== false;\n        config.capIsNew = config.capIsNew !== false;\n        const skipProperties = config.properties === false;\n\n        const newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null;\n\n        const capIsNewExceptions = calculateCapIsNewExceptions(config);\n        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null;\n\n        const listeners = {};\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get exact callee name from expression\n         * @param {ASTNode} node CallExpression or NewExpression node\n         * @returns {string} name\n         */\n        function extractNameFromExpression(node) {\n\n            let name = \"\";\n\n            if (node.callee.type === \"MemberExpression\") {\n                const property = node.callee.property;\n\n                if (property.type === \"Literal\" && (typeof property.value === \"string\")) {\n                    name = property.value;\n                } else if (property.type === \"Identifier\" && !node.callee.computed) {\n                    name = property.name;\n                }\n            } else {\n                name = node.callee.name;\n            }\n            return name;\n        }\n\n        /**\n         * Returns the capitalization state of the string -\n         * Whether the first character is uppercase, lowercase, or non-alphabetic\n         * @param {string} str String\n         * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n         */\n        function getCap(str) {\n            const firstChar = str.charAt(0);\n\n            const firstCharLower = firstChar.toLowerCase();\n            const firstCharUpper = firstChar.toUpperCase();\n\n            if (firstCharLower === firstCharUpper) {\n\n                // char has no uppercase variant, so it's non-alphabetic\n                return \"non-alpha\";\n            } else if (firstChar === firstCharLower) {\n                return \"lower\";\n            }\n            return \"upper\";\n\n        }\n\n        /**\n         * Check if capitalization is allowed for a CallExpression\n         * @param {Object} allowedMap Object mapping calleeName to a Boolean\n         * @param {ASTNode} node CallExpression node\n         * @param {string} calleeName Capitalized callee name from a CallExpression\n         * @param {Object} pattern RegExp object from options pattern\n         * @returns {boolean} Returns true if the callee may be capitalized\n         */\n        function isCapAllowed(allowedMap, node, calleeName, pattern) {\n            const sourceText = sourceCode.getText(node.callee);\n\n            if (allowedMap[calleeName] || allowedMap[sourceText]) {\n                return true;\n            }\n\n            if (pattern && pattern.test(sourceText)) {\n                return true;\n            }\n\n            if (calleeName === \"UTC\" && node.callee.type === \"MemberExpression\") {\n\n                // allow if callee is Date.UTC\n                return node.callee.object.type === \"Identifier\" &&\n                    node.callee.object.name === \"Date\";\n            }\n\n            return skipProperties && node.callee.type === \"MemberExpression\";\n        }\n\n        /**\n         * Reports the given message for the given node. The location will be the start of the property or the callee.\n         * @param {ASTNode} node CallExpression or NewExpression node.\n         * @param {string} message The message to report.\n         * @returns {void}\n         */\n        function report(node, message) {\n            let callee = node.callee;\n\n            if (callee.type === \"MemberExpression\") {\n                callee = callee.property;\n            }\n\n            context.report({ node, loc: callee.loc.start, message });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        if (config.newIsCap) {\n            listeners.NewExpression = function(node) {\n\n                const constructorName = extractNameFromExpression(node);\n\n                if (constructorName) {\n                    const capitalization = getCap(constructorName);\n                    const isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"A constructor name should not start with a lowercase letter.\");\n                    }\n                }\n            };\n        }\n\n        if (config.capIsNew) {\n            listeners.CallExpression = function(node) {\n\n                const calleeName = extractNameFromExpression(node);\n\n                if (calleeName) {\n                    const capitalization = getCap(calleeName);\n                    const isAllowed = capitalization !== \"upper\" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);\n\n                    if (!isAllowed) {\n                        report(node, \"A function with a name starting with an uppercase letter should only be used as a constructor.\");\n                    }\n                }\n            };\n        }\n\n        return listeners;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/new-parens.js":"/**\n * @fileoverview Rule to flag when using constructor without parentheses\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses when invoking a constructor with no arguments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            NewExpression(node) {\n                if (node.arguments.length !== 0) {\n                    return;  // shortcut: if there are arguments, there have to be parens\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n                const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);\n                const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));\n\n                if (!hasParens) {\n                    context.report({\n                        node,\n                        message: \"Missing '()' invoking a constructor.\",\n                        fix: fixer => fixer.insertTextAfter(node, \"()\")\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/newline-after-var.js":"/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow an empty line after variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n\n        const ALWAYS_MESSAGE = \"Expected blank line after variable declarations.\",\n            NEVER_MESSAGE = \"Unexpected blank line after variable declarations.\";\n\n        const sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a token from the given node to compare line to the next statement.\n         *\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\n         *\n         * - The last token is semicolon.\n         * - The semicolon is on a different line from the previous token of the semicolon.\n         *\n         * This behavior would address semicolon-less style code. e.g.:\n         *\n         *     var foo = 1\n         *\n         *     ;(a || b).doSomething()\n         *\n         * @param {ASTNode} node - The node to get.\n         * @returns {Token} The token to compare line to the next statement.\n         */\n        function getLastToken(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n                const prevToken = sourceCode.getTokenBefore(lastToken);\n\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n                    return prevToken;\n                }\n            }\n\n            return lastToken;\n        }\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType - nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node - node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            const token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n        * Gets the last line of a group of consecutive comments\n        * @param {number} commentStartLine The starting line of the group\n        * @returns {number} The number of the last comment line of the group\n        */\n        function getLastCommentLineOfBlock(commentStartLine) {\n            const currentCommentEnd = commentEndLine[commentStartLine];\n\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n\n            /*\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\n             * sometimes be second-last if there is a semicolon on a different line.\n             */\n            const lastToken = getLastToken(node),\n\n                /*\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\n                 * is the last token of the node.\n                 */\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n                nextLineNum = lastToken.loc.end.line + 1;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Some coding styles use multiple `var` statements, so do nothing if\n            // the next token is a `var` statement.\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report({\n                    node,\n                    message: NEVER_MESSAGE,\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n                    }\n                });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report({\n                    node,\n                    message: ALWAYS_MESSAGE,\n                    data: { identifier: node.name },\n                    fix(fixer) {\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n                        }\n\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/newline-before-return.js":"/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require an empty line before `return` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {array} testTokens - array of tokens to test against\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n         * @private\n         */\n        function isPrecededByTokens(node, testTokens) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            return testTokens.some(token => tokenBefore.value === token);\n        }\n\n        /**\n         * Checks whether node is the first node after statement or in block\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\n         * @private\n         */\n        function isFirstNode(node) {\n            const parentType = node.parent.type;\n\n            if (node.parent.body) {\n                return Array.isArray(node.parent.body)\n                  ? node.parent.body[0] === node\n                  : node.parent.body === node;\n            }\n\n            if (parentType === \"IfStatement\") {\n                return isPrecededByTokens(node, [\"else\", \")\"]);\n            } else if (parentType === \"DoWhileStatement\") {\n                return isPrecededByTokens(node, [\"do\"]);\n            } else if (parentType === \"SwitchCase\") {\n                return isPrecededByTokens(node, [\":\"]);\n            }\n            return isPrecededByTokens(node, [\")\"]);\n\n        }\n\n        /**\n         * Returns the number of lines of comments that precede the node\n         * @param {ASTNode} node - node to check for overlapping comments\n         * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments\n         * @returns {number} Number of lines of comments that precede the node\n         * @private\n         */\n        function calcCommentLines(node, lineNumTokenBefore) {\n            const comments = sourceCode.getComments(node).leading;\n            let numLinesComments = 0;\n\n            if (!comments.length) {\n                return numLinesComments;\n            }\n\n            comments.forEach(comment => {\n                numLinesComments++;\n\n                if (comment.type === \"Block\") {\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\n                }\n\n                // avoid counting lines with inline comments twice\n                if (comment.loc.start.line === lineNumTokenBefore) {\n                    numLinesComments--;\n                }\n\n                if (comment.loc.end.line === node.loc.start.line) {\n                    numLinesComments--;\n                }\n            });\n\n            return numLinesComments;\n        }\n\n        /**\n         * Returns the line number of the token before the node that is passed in as an argument\n         * @param {ASTNode} node - The node to use as the start of the calculation\n         * @returns {number} Line number of the token before `node`\n         * @private\n         */\n        function getLineNumberOfTokenBefore(node) {\n            const tokenBefore = sourceCode.getTokenBefore(node);\n            let lineNumTokenBefore;\n\n            /**\n             * Global return (at the beginning of a script) is a special case.\n             * If there is no token before `return`, then we expect no line\n             * break before the return. Comments are allowed to occupy lines\n             * before the global return, just no blank lines.\n             * Setting lineNumTokenBefore to zero in that case results in the\n             * desired behavior.\n             */\n            if (tokenBefore) {\n                lineNumTokenBefore = tokenBefore.loc.end.line;\n            } else {\n                lineNumTokenBefore = 0;     // global return at beginning of script\n            }\n\n            return lineNumTokenBefore;\n        }\n\n        /**\n         * Checks whether node is preceded by a newline\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is preceded by a newline\n         * @private\n         */\n        function hasNewlineBefore(node) {\n            const lineNumNode = node.loc.start.line;\n            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n            const commentLines = calcCommentLines(node, lineNumTokenBefore);\n\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\n        }\n\n        /**\n         * Checks whether it is safe to apply a fix to a given return statement.\n         *\n         * The fix is not considered safe if the given return statement has leading comments,\n         * as we cannot safely determine if the newline should be added before or after the comments.\n         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\n         *\n         * @param {ASTNode} node - The return statement node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         * @private\n         */\n        function canFix(node) {\n            const leadingComments = sourceCode.getComments(node).leading;\n            const lastLeadingComment = leadingComments[leadingComments.length - 1];\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (leadingComments.length === 0) {\n                return true;\n            }\n\n            // if the last leading comment ends in the same line as the previous token and\n            // does not share a line with the `return` node, we can consider it safe to fix.\n            // Example:\n            // function a() {\n            //     var b; //comment\n            //     return;\n            // }\n            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\n                lastLeadingComment.loc.end.line !== node.loc.start.line) {\n                return true;\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ReturnStatement(node) {\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n                    context.report({\n                        node,\n                        message: \"Expected newline before return statement.\",\n                        fix(fixer) {\n                            if (canFix(node)) {\n                                const tokenBefore = sourceCode.getTokenBefore(node);\n                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n\n                                return fixer.insertTextBefore(node, newlines);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/newline-per-chained-call.js":"/**\n * @fileoverview Rule to ensure newline per method call when chaining calls\n * @author Rajendra Patil\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require a newline after each call in a method chain\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                ignoreChainWithDepth: {\n                    type: \"integer\",\n                    minimum: 1,\n                    maximum: 10\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the property text of a given MemberExpression node.\n         * If the text is multiline, this returns only the first line.\n         *\n         * @param {ASTNode} node - A MemberExpression node to get.\n         * @returns {string} The property text of the node.\n         */\n        function getPropertyText(node) {\n            const prefix = node.computed ? \"[\" : \".\";\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n\n            return prefix + lines[0] + suffix;\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                if (!node.callee || node.callee.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                const callee = node.callee;\n                let parent = callee.object;\n                let depth = 1;\n\n                while (parent && parent.callee) {\n                    depth += 1;\n                    parent = parent.callee.object;\n                }\n\n                if (depth > ignoreChainWithDepth && callee.property.loc.start.line === callee.object.loc.end.line) {\n                    context.report({\n                        node: callee.property,\n                        loc: callee.property.loc.start,\n                        message: \"Expected line break before `{{callee}}`.\",\n                        data: {\n                            callee: getPropertyText(callee)\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-alert.js":"/**\n * @fileoverview Rule to flag use of alert, confirm, prompt\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst getPropertyName = require(\"../ast-utils\").getStaticPropertyName;\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given name is a prohibited identifier.\n * @param {string} name The name to check\n * @returns {boolean} Whether or not the name is prohibited.\n */\nfunction isProhibitedIdentifier(name) {\n    return /^(alert|confirm|prompt)$/.test(name);\n}\n\n/**\n * Reports the given node and identifier name.\n * @param {RuleContext} context The ESLint rule context.\n * @param {ASTNode} node The node to report on.\n * @param {string} identifierName The name of the identifier.\n * @returns {void}\n */\nfunction report(context, node, identifierName) {\n    context.report(node, \"Unexpected {{name}}.\", { name: identifierName });\n}\n\n/**\n * Finds the escope reference in the given scope.\n * @param {Object} scope The scope to search.\n * @param {ASTNode} node The identifier node.\n * @returns {Reference|null} Returns the found reference or null if none were found.\n */\nfunction findReference(scope, node) {\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\n            reference.identifier.range[1] === node.range[1]);\n\n    if (references.length === 1) {\n        return references[0];\n    }\n    return null;\n}\n\n/**\n * Checks if the given identifier node is shadowed in the given scope.\n * @param {Object} scope The current scope.\n * @param {Object} globalScope The global scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the name is shadowed.\n */\nfunction isShadowed(scope, globalScope, node) {\n    const reference = findReference(scope, node);\n\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n\n/**\n * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.\n * @param {Object} scope The current scope.\n * @param {Object} globalScope The global scope.\n * @param {string} node The identifier node to check\n * @returns {boolean} Whether or not the node is a reference to the global object.\n */\nfunction isGlobalThisReferenceOrGlobalWindow(scope, globalScope, node) {\n    if (scope.type === \"global\" && node.type === \"ThisExpression\") {\n        return true;\n    } else if (node.name === \"window\") {\n        return !isShadowed(scope, globalScope, node);\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let globalScope;\n\n        return {\n\n            Program() {\n                globalScope = context.getScope();\n            },\n\n            CallExpression(node) {\n                const callee = node.callee,\n                    currentScope = context.getScope();\n\n                // without window.\n                if (callee.type === \"Identifier\") {\n                    const identifierName = callee.name;\n\n                    if (!isShadowed(currentScope, globalScope, callee) && isProhibitedIdentifier(callee.name)) {\n                        report(context, node, identifierName);\n                    }\n\n                } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, globalScope, callee.object)) {\n                    const identifierName = getPropertyName(callee);\n\n                    if (isProhibitedIdentifier(identifierName)) {\n                        report(context, node, identifierName);\n                    }\n                }\n\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-array-constructor.js":"/**\n * @fileoverview Disallow construction of dense arrays using the Array constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `Array` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Disallow construction of dense arrays using the Array constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (\n                node.arguments.length !== 1 &&\n                node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Array\"\n            ) {\n                context.report({ node, message: \"The array literal notation [] is preferrable.\" });\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-await-in-loop.js":"/**\n * @fileoverview Rule to disallow uses of await inside of loops.\n * @author Nat Mote (nmote)\n */\n\"use strict\";\n\n// Node types which are considered loops.\nconst loopTypes = new Set([\n    \"ForStatement\",\n    \"ForOfStatement\",\n    \"ForInStatement\",\n    \"WhileStatement\",\n    \"DoWhileStatement\"\n]);\n\n// Node types at which we should stop looking for loops. For example, it is fine to declare an async\n// function within a loop, and use await inside of that.\nconst boundaryTypes = new Set([\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"ArrowFunctionExpression\"\n]);\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `await` inside of loops\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n        schema: []\n    },\n    create(context) {\n        return {\n            AwaitExpression(node) {\n                const ancestors = context.getAncestors();\n\n                // Reverse so that we can traverse from the deepest node upwards.\n                ancestors.reverse();\n\n                // Create a set of all the ancestors plus this node so that we can check\n                // if this use of await appears in the body of the loop as opposed to\n                // the right-hand side of a for...of, for example.\n                const ancestorSet = new Set(ancestors).add(node);\n\n                for (let i = 0; i < ancestors.length; i++) {\n                    const ancestor = ancestors[i];\n\n                    if (boundaryTypes.has(ancestor.type)) {\n\n                        // Short-circuit out if we encounter a boundary type. Loops above\n                        // this do not matter.\n                        return;\n                    }\n                    if (loopTypes.has(ancestor.type)) {\n\n                        // Only report if we are actually in the body or another part that gets executed on\n                        // every iteration.\n                        if (\n                            ancestorSet.has(ancestor.body) ||\n                            ancestorSet.has(ancestor.test) ||\n                            ancestorSet.has(ancestor.update)\n                        ) {\n                            context.report({\n                                node,\n                                message: \"Unexpected `await` inside a loop.\"\n                            });\n                            return;\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-bitwise.js":"/**\n * @fileoverview Rule to flag bitwise identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//\n// Set of bitwise operators.\n//\nconst BITWISE_OPERATORS = [\n    \"^\", \"|\", \"&\", \"<<\", \">>\", \">>>\",\n    \"^=\", \"|=\", \"&=\", \"<<=\", \">>=\", \">>>=\",\n    \"~\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow bitwise operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            enum: BITWISE_OPERATORS\n                        },\n                        uniqueItems: true\n                    },\n                    int32Hint: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n        const int32Hint = options.int32Hint === true;\n\n        /**\n         * Reports an unexpected use of a bitwise operator.\n         * @param   {ASTNode} node Node which contains the bitwise operator.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, message: \"Unexpected use of '{{operator}}'.\", data: { operator: node.operator } });\n        }\n\n        /**\n         * Checks if the given node has a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function hasBitwiseOperator(node) {\n            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function allowedOperator(node) {\n            return allowed.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if the given bitwise operator is used for integer typecasting, i.e. \"|0\"\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is used in integer typecasting.\n         */\n        function isInt32Hint(node) {\n            return int32Hint && node.operator === \"|\" && node.right &&\n              node.right.type === \"Literal\" && node.right.value === 0;\n        }\n\n        /**\n         * Report if the given node contains a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNodeForBitwiseOperator(node) {\n            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            AssignmentExpression: checkNodeForBitwiseOperator,\n            BinaryExpression: checkNodeForBitwiseOperator,\n            UnaryExpression: checkNodeForBitwiseOperator\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-caller.js":"/**\n * @fileoverview Rule to flag use of arguments.callee and arguments.caller.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `arguments.caller` or `arguments.callee`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"arguments\" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {\n                    context.report({ node, message: \"Avoid arguments.{{property}}.\", data: { property: propertyName } });\n                }\n\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-case-declarations.js":"/**\n * @fileoverview Rule to flag use of an lexical declarations inside a case clause\n * @author Erik Arvidsson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow lexical declarations in case clauses\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether or not a node is a lexical declaration.\n         * @param {ASTNode} node A direct child statement of a switch case.\n         * @returns {boolean} Whether or not the node is a lexical declaration.\n         */\n        function isLexicalDeclaration(node) {\n            switch (node.type) {\n                case \"FunctionDeclaration\":\n                case \"ClassDeclaration\":\n                    return true;\n                case \"VariableDeclaration\":\n                    return node.kind !== \"var\";\n                default:\n                    return false;\n            }\n        }\n\n        return {\n            SwitchCase(node) {\n                for (let i = 0; i < node.consequent.length; i++) {\n                    const statement = node.consequent[i];\n\n                    if (isLexicalDeclaration(statement)) {\n                        context.report({\n                            node,\n                            message: \"Unexpected lexical declaration in case block.\"\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-catch-shadow.js":"/**\n * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `catch` clause parameters from shadowing variables in the outer scope\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the parameters are been shadowed\n         * @param {Object} scope current scope\n         * @param {string} name parameter name\n         * @returns {boolean} True is its been shadowed\n         */\n        function paramIsShadowing(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            CatchClause(node) {\n                let scope = context.getScope();\n\n                // When blockBindings is enabled, CatchClause creates its own scope\n                // so start from one upper scope to exclude the current node\n                if (scope.block === node) {\n                    scope = scope.upper;\n                }\n\n                if (paramIsShadowing(scope, node.param.name)) {\n                    context.report({ node, message: \"Value of '{{name}}' may be overwritten in IE 8 and earlier.\", data: { name: node.param.name } });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-class-assign.js":"/**\n * @fileoverview A rule to disallow modifying variables of class declarations\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning class members\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is a class.\", data: { name: reference.identifier.name } });\n\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.\n         * @returns {void}\n         */\n        function checkForClass(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            ClassDeclaration: checkForClass,\n            ClassExpression: checkForClass\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-compare-neg-zero.js":"/**\n * @fileoverview The rule should warn against code that tries to compare against -0.\n * @author Aladdin-ADD <hh_2013@foxmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comparing against -0\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n        fixable: null,\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks a given node is -0\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is -0.\n         */\n        function isNegZero(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.argument.type === \"Literal\" && node.argument.value === 0;\n        }\n        const OPERATORS_TO_CHECK = new Set([\">\", \">=\", \"<\", \"<=\", \"==\", \"===\", \"!=\", \"!==\"]);\n\n        return {\n            BinaryExpression(node) {\n                if (OPERATORS_TO_CHECK.has(node.operator)) {\n                    if (isNegZero(node.left) || isNegZero(node.right)) {\n                        context.report({\n                            node,\n                            message: \"Do not use the '{{operator}}' operator to compare against -0.\",\n                            data: { operator: node.operator }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-cond-assign.js":"/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                node.parent.test &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                // must match JSHint's error message\n                context.report({\n                    node,\n                    loc: node.test.loc.start,\n                    message: \"Expected a conditional expression and instead saw an assignment.\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({ node: ancestor, message: \"Unexpected assignment within {{type}}.\", data: {\n                    type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                } });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-confusing-arrow.js":"/**\n * @fileoverview A rule to warn against using arrow functions when they could be\n * confused with comparisions\n * @author Jxck <https://github.com/Jxck>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a conditional expression.\n * @param {ASTNode} node - node to test\n * @returns {boolean} `true` if the node is a conditional expression.\n */\nfunction isConditional(node) {\n    return node && node.type === \"ConditionalExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow arrow functions where they could be confused with comparisons\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowParens: { type: \"boolean\" }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const config = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports if an arrow function contains an ambiguous conditional.\n         * @param {ASTNode} node - A node to check and report.\n         * @returns {void}\n         */\n        function checkArrowFunc(node) {\n            const body = node.body;\n\n            if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {\n                context.report({ node, message: \"Arrow function used ambiguously with a conditional expression.\" });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkArrowFunc\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-console.js":"/**\n * @fileoverview Rule to flag use of console object\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `console`\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        /**\n         * Checks whether the given reference is 'console' or not.\n         *\n         * @param {escope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is 'console'.\n         */\n        function isConsole(reference) {\n            const id = reference.identifier;\n\n            return id && id.name === \"console\";\n        }\n\n        /**\n         * Checks whether the property name of the given MemberExpression node\n         * is allowed by options or not.\n         *\n         * @param {ASTNode} node - The MemberExpression node to check.\n         * @returns {boolean} `true` if the property name of the node is allowed.\n         */\n        function isAllowed(node) {\n            const propertyName = astUtils.getStaticPropertyName(node);\n\n            return propertyName && allowed.indexOf(propertyName) !== -1;\n        }\n\n        /**\n         * Checks whether the given reference is a member access which is not\n         * allowed by options or not.\n         *\n         * @param {escope.Reference} reference - The reference to check.\n         * @returns {boolean} `true` if the reference is a member access which\n         *      is not allowed by options.\n         */\n        function isMemberAccessExceptAllowed(reference) {\n            const node = reference.identifier;\n            const parent = node.parent;\n\n            return (\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                !isAllowed(parent)\n            );\n        }\n\n        /**\n         * Reports the given reference as a violation.\n         *\n         * @param {escope.Reference} reference - The reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            const node = reference.identifier.parent;\n\n            context.report({\n                node,\n                loc: node.loc,\n                message: \"Unexpected console statement.\"\n            });\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const consoleVar = astUtils.getVariableByName(scope, \"console\");\n                const shadowed = consoleVar && consoleVar.defs.length > 0;\n\n                /* 'scope.through' includes all references to undefined\n                 * variables. If the variable 'console' is not defined, it uses\n                 * 'scope.through'.\n                 */\n                const references = consoleVar\n                    ? consoleVar.references\n                    : scope.through.filter(isConsole);\n\n                if (!shadowed) {\n                    references\n                        .filter(isMemberAccessExceptAllowed)\n                        .forEach(report);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-const-assign.js":"/**\n * @fileoverview A rule to disallow modifying variables that are declared using `const`\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `const` variables\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is constant.\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        return {\n            VariableDeclaration(node) {\n                if (node.kind === \"const\") {\n                    context.getDeclaredVariables(node).forEach(checkVariable);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-constant-condition.js":"/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && node.value === true) ||\n                           (operator === \"&&\" && node.value === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n                    return isLogicalIdentity(node.left, node.operator) ||\n                             isLogicalIdentity(node.right, node.operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                    return true;\n\n                case \"UnaryExpression\":\n                    if (node.operator === \"void\") {\n                        return true;\n                    }\n\n                    return (node.operator === \"typeof\" && inBooleanPosition) ||\n                        isConstant(node.argument, true);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) || isLeftShortCircuit || isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    return (node.operator === \"=\") && isConstant(node.right, inBooleanPosition);\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantCondition(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node, message: \"Unexpected constant condition.\" });\n            }\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                checkConstantCondition(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: checkConstantCondition,\n            IfStatement: checkConstantCondition,\n            WhileStatement: checkLoop,\n            DoWhileStatement: checkLoop,\n            ForStatement: checkLoop\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-continue.js":"/**\n * @fileoverview Rule to flag use of continue statement\n * @author Borislav Zhivkov\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `continue` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            ContinueStatement(node) {\n                context.report({ node, message: \"Unexpected use of continue statement.\" });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-control-regex.js":"/**\n * @fileoverview Rule to forbid control charactes from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow control characters in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node node to evaluate\n         * @returns {*} Regex if found else null\n         * @private\n         */\n        function getRegExp(node) {\n            if (node.value instanceof RegExp) {\n                return node.value;\n            } else if (typeof node.value === \"string\") {\n\n                const parent = context.getAncestors().pop();\n\n                if ((parent.type === \"NewExpression\" || parent.type === \"CallExpression\") &&\n                    parent.callee.type === \"Identifier\" && parent.callee.name === \"RegExp\"\n                ) {\n\n                    // there could be an invalid regular expression string\n                    try {\n                        return new RegExp(node.value);\n                    } catch (ex) {\n                        return null;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n\n        const controlChar = /[\\x00-\\x1f]/g; // eslint-disable-line no-control-regex\n        const consecutiveSlashes = /\\\\+/g;\n        const consecutiveSlashesAtEnd = /\\\\+$/g;\n        const stringControlChar = /\\\\x[01][0-9a-f]/ig;\n        const stringControlCharWithoutSlash = /x[01][0-9a-f]/ig;\n\n        /**\n         * Return a list of the control characters in the given regex string\n         * @param {string} regexStr regex as string to check\n         * @returns {array} returns a list of found control characters on given string\n         * @private\n         */\n        function getControlCharacters(regexStr) {\n\n            // check control characters, if RegExp object used\n            const controlChars = regexStr.match(controlChar) || [];\n\n            let stringControlChars = [];\n\n            // check substr, if regex literal used\n            const subStrIndex = regexStr.search(stringControlChar);\n\n            if (subStrIndex > -1) {\n\n                // is it escaped, check backslash count\n                const possibleEscapeCharacters = regexStr.slice(0, subStrIndex).match(consecutiveSlashesAtEnd);\n\n                const hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);\n\n                if (hasControlChars) {\n                    stringControlChars = regexStr.slice(subStrIndex, -1)\n                        .split(consecutiveSlashes)\n                        .filter(Boolean)\n                        .map(x => {\n                            const match = x.match(stringControlCharWithoutSlash) || [x];\n\n                            return `\\\\${match[0]}`;\n                        });\n                }\n            }\n\n            return controlChars.map(x => {\n                const hexCode = `0${x.charCodeAt(0).toString(16)}`.slice(-2);\n\n                return `\\\\x${hexCode}`;\n            }).concat(stringControlChars);\n        }\n\n        return {\n            Literal(node) {\n                const regex = getRegExp(node);\n\n                if (regex) {\n                    const computedValue = regex.toString();\n\n                    const controlCharacters = getControlCharacters(computedValue);\n\n                    if (controlCharacters.length > 0) {\n                        context.report({\n                            node,\n                            message: \"Unexpected control character(s) in regular expression: {{controlChars}}.\",\n                            data: {\n                                controlChars: controlCharacters.join(\", \")\n                            }\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-debugger.js":"/**\n * @fileoverview Rule to flag use of a debugger statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `debugger`\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            DebuggerStatement(node) {\n                context.report({ node, message: \"Unexpected 'debugger' statement.\" });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-delete-var.js":"/**\n * @fileoverview Rule to flag when deleting variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow deleting variables\",\n            category: \"Variables\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            UnaryExpression(node) {\n                if (node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n                    context.report({ node, message: \"Variables should not be deleted.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-div-regex.js":"/**\n * @fileoverview Rule to check for ambiguous div operator in regexes\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow division operators explicitly at the beginning of regular expressions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && token.value[1] === \"=\") {\n                    context.report({ node, message: \"A regular expression literal can be confused with '/='.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-dupe-args.js":"/**\n * @fileoverview Rule to flag duplicate arguments\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate arguments in `function` definitions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whether or not a given definition is a parameter's.\n         * @param {escope.DefEntry} def - A definition to check.\n         * @returns {boolean} `true` if the definition is a parameter's.\n         */\n        function isParameter(def) {\n            return def.type === \"Parameter\";\n        }\n\n        /**\n         * Determines if a given node has duplicate parameters.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkParams(node) {\n            const variables = context.getDeclaredVariables(node);\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Checks and reports duplications.\n                const defs = variable.defs.filter(isParameter);\n\n                if (defs.length >= 2) {\n                    context.report({\n                        node,\n                        message: \"Duplicate param '{{name}}'.\",\n                        data: { name: variable.name }\n                    });\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkParams,\n            FunctionExpression: checkParams\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-dupe-class-members.js":"/**\n * @fileoverview A rule to disallow duplicate name in class members.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate class members\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let stack = [];\n\n        /**\n         * Gets state of a given member name.\n         * @param {string} name - A name of a member.\n         * @param {boolean} isStatic - A flag which specifies that is a static member.\n         * @returns {Object} A state of a given member name.\n         *   - retv.init {boolean} A flag which shows the name is declared as normal member.\n         *   - retv.get {boolean} A flag which shows the name is declared as getter.\n         *   - retv.set {boolean} A flag which shows the name is declared as setter.\n         */\n        function getState(name, isStatic) {\n            const stateMap = stack[stack.length - 1];\n            const key = `$${name}`; // to avoid \"__proto__\".\n\n            if (!stateMap[key]) {\n                stateMap[key] = {\n                    nonStatic: { init: false, get: false, set: false },\n                    static: { init: false, get: false, set: false }\n                };\n            }\n\n            return stateMap[key][isStatic ? \"static\" : \"nonStatic\"];\n        }\n\n        /**\n         * Gets the name text of a given node.\n         *\n         * @param {ASTNode} node - A node to get the name.\n         * @returns {string} The name text of the node.\n         */\n        function getName(node) {\n            switch (node.type) {\n                case \"Identifier\": return node.name;\n                case \"Literal\": return String(node.value);\n\n                /* istanbul ignore next: syntax error */\n                default: return \"\";\n            }\n        }\n\n        return {\n\n            // Initializes the stack of state of member declarations.\n            Program() {\n                stack = [];\n            },\n\n            // Initializes state of member declarations for the class.\n            ClassBody() {\n                stack.push(Object.create(null));\n            },\n\n            // Disposes the state for the class.\n            \"ClassBody:exit\"() {\n                stack.pop();\n            },\n\n            // Reports the node if its name has been declared already.\n            MethodDefinition(node) {\n                if (node.computed) {\n                    return;\n                }\n\n                const name = getName(node.key);\n                const state = getState(name, node.static);\n                let isDuplicate = false;\n\n                if (node.kind === \"get\") {\n                    isDuplicate = (state.init || state.get);\n                    state.get = true;\n                } else if (node.kind === \"set\") {\n                    isDuplicate = (state.init || state.set);\n                    state.set = true;\n                } else {\n                    isDuplicate = (state.init || state.get || state.set);\n                    state.init = true;\n                }\n\n                if (isDuplicate) {\n                    context.report({ node, message: \"Duplicate name '{{name}}'.\", data: { name } });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-dupe-keys.js":"/**\n * @fileoverview Rule to flag use of duplicate keys in an object.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst GET_KIND = /^(?:init|get)$/;\nconst SET_KIND = /^(?:init|set)$/;\n\n/**\n * The class which stores properties' information of an object.\n */\nclass ObjectInfo {\n\n    /**\n     * @param {ObjectInfo|null} upper - The information of the outer object.\n     * @param {ASTNode} node - The ObjectExpression node of this information.\n     */\n    constructor(upper, node) {\n        this.upper = upper;\n        this.node = node;\n        this.properties = new Map();\n    }\n\n    /**\n     * Gets the information of the given Property node.\n     * @param {ASTNode} node - The Property node to get.\n     * @returns {{get: boolean, set: boolean}} The information of the property.\n     */\n    getPropertyInfo(node) {\n        const name = astUtils.getStaticPropertyName(node);\n\n        if (!this.properties.has(name)) {\n            this.properties.set(name, { get: false, set: false });\n        }\n        return this.properties.get(name);\n    }\n\n    /**\n     * Checks whether the given property has been defined already or not.\n     * @param {ASTNode} node - The Property node to check.\n     * @returns {boolean} `true` if the property has been defined.\n     */\n    isPropertyDefined(node) {\n        const entry = this.getPropertyInfo(node);\n\n        return (\n            (GET_KIND.test(node.kind) && entry.get) ||\n            (SET_KIND.test(node.kind) && entry.set)\n        );\n    }\n\n    /**\n     * Defines the given property.\n     * @param {ASTNode} node - The Property node to define.\n     * @returns {void}\n     */\n    defineProperty(node) {\n        const entry = this.getPropertyInfo(node);\n\n        if (GET_KIND.test(node.kind)) {\n            entry.get = true;\n        }\n        if (SET_KIND.test(node.kind)) {\n            entry.set = true;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate keys in object literals\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let info = null;\n\n        return {\n            ObjectExpression(node) {\n                info = new ObjectInfo(info, node);\n            },\n            \"ObjectExpression:exit\"() {\n                info = info.upper;\n            },\n\n            Property(node) {\n                const name = astUtils.getStaticPropertyName(node);\n\n                // Skip destructuring.\n                if (node.parent.type !== \"ObjectExpression\") {\n                    return;\n                }\n\n                // Skip if the name is not static.\n                if (!name) {\n                    return;\n                }\n\n                // Reports if the name is defined already.\n                if (info.isPropertyDefined(node)) {\n                    context.report({\n                        node: info.node,\n                        loc: node.key.loc,\n                        message: \"Duplicate key '{{name}}'.\",\n                        data: { name }\n                    });\n                }\n\n                // Update info.\n                info.defineProperty(node);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-duplicate-case.js":"/**\n * @fileoverview Rule to disallow a duplicate case label.\n * @author Dieter Oberkofler\n * @author Burak Yigit Kaya\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate case labels\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            SwitchStatement(node) {\n                const mapping = {};\n\n                node.cases.forEach(switchCase => {\n                    const key = sourceCode.getText(switchCase.test);\n\n                    if (mapping[key]) {\n                        context.report({ node: switchCase, message: \"Duplicate case label.\" });\n                    } else {\n                        mapping[key] = switchCase;\n                    }\n                });\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-duplicate-imports.js":"/**\n * @fileoverview Restrict usage of duplicate imports.\n * @author Simen Bekkhus\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Returns the name of the module imported or re-exported.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string} the name of the module, or empty string if no name.\n */\nfunction getValue(node) {\n    if (node && node.source && node.source.value) {\n        return node.source.value.trim();\n    }\n\n    return \"\";\n}\n\n/**\n * Checks if the name of the import or export exists in the given array, and reports if so.\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {ASTNode} node - A node to get.\n * @param {string} value - The name of the imported or exported module.\n * @param {string[]} array - The array containing other imports or exports in the file.\n * @param {string} message - A message to be reported after the name of the module\n *\n * @returns {void} No return value\n */\nfunction checkAndReport(context, node, value, array, message) {\n    if (array.indexOf(value) !== -1) {\n        context.report({\n            node,\n            message: \"'{{module}}' {{message}}\",\n            data: {\n                module: value,\n                message\n            }\n        });\n    }\n}\n\n/**\n * @callback nodeCallback\n * @param {ASTNode} node - A node to handle.\n */\n\n/**\n * Returns a function handling the imports of a given file\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {boolean} includeExports - Whether or not to check for exports in addition to imports.\n * @param {string[]} importsInFile - The array containing other imports in the file.\n * @param {string[]} exportsInFile - The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleImports(context, includeExports, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, importsInFile, \"import is duplicated.\");\n\n            if (includeExports) {\n                checkAndReport(context, node, value, exportsInFile, \"import is duplicated as export.\");\n            }\n\n            importsInFile.push(value);\n        }\n    };\n}\n\n/**\n * Returns a function handling the exports of a given file\n *\n * @param {RuleContext} context - The ESLint rule context object.\n * @param {string[]} importsInFile - The array containing other imports in the file.\n * @param {string[]} exportsInFile - The array containing other exports in the file.\n *\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\n */\nfunction handleExports(context, importsInFile, exportsInFile) {\n    return function(node) {\n        const value = getValue(node);\n\n        if (value) {\n            checkAndReport(context, node, value, exportsInFile, \"export is duplicated.\");\n            checkAndReport(context, node, value, importsInFile, \"export is duplicated as import.\");\n\n            exportsInFile.push(value);\n        }\n    };\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow duplicate module imports\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                includeExports: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const includeExports = (context.options[0] || {}).includeExports,\n            importsInFile = [],\n            exportsInFile = [];\n\n        const handlers = {\n            ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)\n        };\n\n        if (includeExports) {\n            handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);\n            handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);\n        }\n\n        return handlers;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-else-return.js":"/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst FixTracker = require(\"../util/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Display the context report if rule is violated\n         *\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            context.report({\n                node,\n                message: \"Unnecessary 'else' after 'return'.\",\n                fix: fixer => {\n                    const sourceCode = context.getSourceCode();\n                    const startToken = sourceCode.getFirstToken(node);\n                    const elseToken = sourceCode.getTokenBefore(startToken);\n                    const source = sourceCode.getText(node);\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\n                    let fixedSource, firstTokenOfElseBlock;\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n                    } else {\n                        firstTokenOfElseBlock = startToken;\n                    }\n\n                    // If the if block does not have curly braces and does not end in a semicolon\n                    // and the else block starts with (, [, /, +, ` or -, then it is not\n                    // safe to remove the else keyword, because ASI will not add a semicolon\n                    // after the if block\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n                    const elseBlockUnsafe = /^[([/+`-]/.test(firstTokenOfElseBlock.value);\n\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n                        return null;\n                    }\n\n                    const endToken = sourceCode.getLastToken(node);\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n                    if (lastTokenOfElseBlock.value !== \";\") {\n                        const nextToken = sourceCode.getTokenAfter(endToken);\n\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/.test(nextToken.value);\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n\n                        // If the else block contents does not end in a semicolon,\n                        // and the else block starts with (, [, /, +, ` or -, then it is not\n                        // safe to remove the else block, because ASI will not add a semicolon\n                        // after the remaining else block contents\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\n                            return null;\n                        }\n                    }\n\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n                        fixedSource = source.slice(1, -1);\n                    } else {\n                        fixedSource = source;\n                    }\n\n                    // Extend the replacement range to include the entire\n                    // function to avoid conflicting with no-useless-return.\n                    // https://github.com/eslint/eslint/issues/8026\n                    return new FixTracker(fixer, sourceCode)\n                        .retainEnclosingFunction(node)\n                        .replaceTextRange([elseToken.start, node.end], fixedSource);\n                }\n            });\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         *\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                const body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else and not an else-if\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         *\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         *\n         * @param {Node} node The consequent or body node\n         * @param {Node} alternate The alternate node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            }\n\n            /*\n             * If not a block statement, make sure the consequent isn't a\n             * ReturnStatement or an IfStatement with returns on both paths.\n             */\n            return checkForReturnOrIf(node);\n        }\n\n        /**\n         * Check the if statement\n         * @returns {void}\n         * @param {Node} node The node for the if statement to check\n         * @private\n         */\n        function IfStatement(node) {\n            const parent = context.getAncestors().pop();\n            let consequents,\n                alternate;\n\n            /*\n             * Fixing this would require splitting one statement into two, so no error should\n             * be reported if this node is in a position where only one statement is allowed.\n             */\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n                return;\n            }\n\n            for (consequents = []; node.type === \"IfStatement\"; node = node.alternate) {\n                if (!node.alternate) {\n                    return;\n                }\n                consequents.push(node.consequent);\n                alternate = node.alternate;\n            }\n\n            if (consequents.every(alwaysReturns)) {\n                displayReport(alternate);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            \"IfStatement:exit\": IfStatement\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/fix-tracker.js":"/**\n * @fileoverview Helper class to aid in constructing fix commands.\n * @author Alan Pierce\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A helper class to combine fix options into a fix command. Currently, it\n * exposes some \"retain\" methods that extend the range of the text being\n * replaced so that other fixes won't touch that region in the same pass.\n */\nclass FixTracker {\n\n    /**\n     * Create a new FixTracker.\n     *\n     * @param {ruleFixer} fixer A ruleFixer instance.\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\n     */\n    constructor(fixer, sourceCode) {\n        this.fixer = fixer;\n        this.sourceCode = sourceCode;\n        this.retainedRange = null;\n    }\n\n    /**\n     * Mark the given range as \"retained\", meaning that other fixes may not\n     * may not modify this region in the same pass.\n     *\n     * @param {int[]} range The range to retain.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainRange(range) {\n        this.retainedRange = range;\n        return this;\n    }\n\n    /**\n     * Given a node, find the function containing it (or the entire program) and\n     * mark it as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that modify control\n     * flow.\n     *\n     * @param {ASTNode} node The node to use as a starting point.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainEnclosingFunction(node) {\n        const functionNode = astUtils.getUpperFunction(node);\n\n        return this.retainRange(\n            functionNode ? functionNode.range : this.sourceCode.ast.range);\n    }\n\n    /**\n     * Given a node or token, find the token before and afterward, and mark that\n     * range as retained, meaning that other fixes may not modify it in this\n     * pass. This is useful for avoiding conflicts in fixes that make a small\n     * change to the code where the AST should not be changed.\n     *\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\n     *      point. The token to the left and right are use in the range.\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\n     */\n    retainSurroundingTokens(nodeOrToken) {\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n    }\n\n    /**\n     * Create a fix command that replaces the given range with the given text,\n     * accounting for any retained ranges.\n     *\n     * @param {int[]} range The range to remove in the fix.\n     * @param {string} text The text to insert in place of the range.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        let actualRange;\n\n        if (this.retainedRange) {\n            actualRange = [\n                Math.min(this.retainedRange[0], range[0]),\n                Math.max(this.retainedRange[1], range[1])\n            ];\n        } else {\n            actualRange = range;\n        }\n\n        return this.fixer.replaceTextRange(\n            actualRange,\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\n                text +\n                this.sourceCode.text.slice(range[1], actualRange[1])\n        );\n    }\n\n    /**\n     * Create a fix command that removes the given node or token, accounting for\n     * any retained ranges.\n     *\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.replaceTextRange(nodeOrToken.range, \"\");\n    }\n}\n\nmodule.exports = FixTracker;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-empty-character-class.js":"/**\n * @fileoverview Rule to flag the use of empty character classes in regular expressions\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/*\nplain-English description of the following regexp:\n0. `^` fix the match at the beginning of the string\n1. `\\/`: the `/` that begins the regexp\n2. `([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+\\])*`: regexp contents; 0 or more of the following\n  2.0. `[^\\\\[]`: any character that's not a `\\` or a `[` (anything but escape sequences and character classes)\n  2.1. `\\\\.`: an escape sequence\n  2.2. `\\[([^\\\\\\]]|\\\\.)+\\]`: a character class that isn't empty\n3. `\\/` the `/` that ends the regexp\n4. `[gimuy]*`: optional regexp flags\n5. `$`: fix the match at the end of the string\n*/\nconst regex = /^\\/([^\\\\[]|\\\\.|\\[([^\\\\\\]]|\\\\.)+])*\\/[gimuy]*$/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty character classes in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                if (token.type === \"RegularExpression\" && !regex.test(token.value)) {\n                    context.report({ node, message: \"Empty class.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-empty-function.js":"/**\n * @fileoverview Rule to disallow empty functions.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ALLOW_OPTIONS = Object.freeze([\n    \"functions\",\n    \"arrowFunctions\",\n    \"generatorFunctions\",\n    \"methods\",\n    \"generatorMethods\",\n    \"getters\",\n    \"setters\",\n    \"constructors\"\n]);\n\n/**\n * Gets the kind of a given function node.\n *\n * @param {ASTNode} node - A function node to get. This is one of\n *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n *      FunctionExpression.\n * @returns {string} The kind of the function. This is one of \"functions\",\n *      \"arrowFunctions\", \"generatorFunctions\", \"asyncFunctions\", \"methods\",\n *      \"generatorMethods\", \"asyncMethods\", \"getters\", \"setters\", and\n *      \"constructors\".\n */\nfunction getKind(node) {\n    const parent = node.parent;\n    let kind = \"\";\n\n    if (node.type === \"ArrowFunctionExpression\") {\n        return \"arrowFunctions\";\n    }\n\n    // Detects main kind.\n    if (parent.type === \"Property\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        kind = parent.method ? \"methods\" : \"functions\";\n\n    } else if (parent.type === \"MethodDefinition\") {\n        if (parent.kind === \"get\") {\n            return \"getters\";\n        }\n        if (parent.kind === \"set\") {\n            return \"setters\";\n        }\n        if (parent.kind === \"constructor\") {\n            return \"constructors\";\n        }\n        kind = \"methods\";\n\n    } else {\n        kind = \"functions\";\n    }\n\n    // Detects prefix.\n    let prefix = \"\";\n\n    if (node.generator) {\n        prefix = \"generator\";\n    } else if (node.async) {\n        prefix = \"async\";\n    } else {\n        return kind;\n    }\n    return prefix + kind[0].toUpperCase() + kind.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty functions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: { enum: ALLOW_OPTIONS },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const allowed = options.allow || [];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given function node if the node matches the following patterns.\n         *\n         * - Not allowed by options.\n         * - The body is empty.\n         * - The body doesn't have any comments.\n         *\n         * @param {ASTNode} node - A function node to report. This is one of\n         *      an ArrowFunctionExpression, a FunctionDeclaration, or a\n         *      FunctionExpression.\n         * @returns {void}\n         */\n        function reportIfEmpty(node) {\n            const kind = getKind(node);\n            const name = astUtils.getFunctionNameWithKind(node);\n\n            if (allowed.indexOf(kind) === -1 &&\n                node.body.type === \"BlockStatement\" &&\n                node.body.body.length === 0 &&\n                sourceCode.getComments(node.body).trailing.length === 0\n            ) {\n                context.report({\n                    node,\n                    loc: node.body.loc.start,\n                    message: \"Unexpected empty {{name}}.\",\n                    data: { name }\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: reportIfEmpty,\n            FunctionDeclaration: reportIfEmpty,\n            FunctionExpression: reportIfEmpty\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-empty-pattern.js":"/**\n * @fileoverview Rule to disallow an empty pattern\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty destructuring patterns\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            ObjectPattern(node) {\n                if (node.properties.length === 0) {\n                    context.report({ node, message: \"Unexpected empty object pattern.\" });\n                }\n            },\n            ArrayPattern(node) {\n                if (node.elements.length === 0) {\n                    context.report({ node, message: \"Unexpected empty array pattern.\" });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-empty.js":"/**\n * @fileoverview Rule to flag use of an empty block statement\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow empty block statements\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyCatch: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            allowEmptyCatch = options.allowEmptyCatch || false;\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BlockStatement(node) {\n\n                // if the body is not empty, we can just return immediately\n                if (node.body.length !== 0) {\n                    return;\n                }\n\n                // a function is generally allowed to be empty\n                if (astUtils.isFunction(node.parent)) {\n                    return;\n                }\n\n                if (allowEmptyCatch && node.parent.type === \"CatchClause\") {\n                    return;\n                }\n\n                // any other block is only allowed to be empty, if it contains a comment\n                if (sourceCode.getComments(node).trailing.length > 0) {\n                    return;\n                }\n\n                context.report({ node, message: \"Empty block statement.\" });\n            },\n\n            SwitchStatement(node) {\n\n                if (typeof node.cases === \"undefined\" || node.cases.length === 0) {\n                    context.report({ node, message: \"Empty switch statement.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-eq-null.js":"/**\n * @fileoverview Rule to flag comparisons to null without a type-checking\n * operator.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `null` comparisons without type-checking operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                const badOperator = node.operator === \"==\" || node.operator === \"!=\";\n\n                if (node.right.type === \"Literal\" && node.right.raw === \"null\" && badOperator ||\n                        node.left.type === \"Literal\" && node.left.raw === \"null\" && badOperator) {\n                    context.report({ node, message: \"Use ‘===’ to compare with ‘null’.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-eval.js":"/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\"\n]);\n\n/**\n * Checks a given node is a Identifier node of the specified name.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Identifier node of the name.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks a given node is a Literal node of the specified string value.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Literal node of the name.\n */\nfunction isConstant(node, name) {\n    switch (node.type) {\n        case \"Literal\":\n            return node.value === name;\n\n        case \"TemplateLiteral\":\n            return (\n                node.expressions.length === 0 &&\n                node.quasis[0].value.cooked === name\n            );\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return (\n        node.type === \"MemberExpression\" &&\n        (node.computed ? isConstant : isIdentifier)(node.property, name)\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        const sourceCode = context.getSourceCode();\n        let funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         *\n         * @param {ASTNode} node - A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            const strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node,\n                strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         *\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            let locationNode = node;\n            const parent = node.parent;\n\n            if (node.type === \"MemberExpression\") {\n                locationNode = node.property;\n            }\n            if (parent.type === \"CallExpression\" && parent.callee === node) {\n                node = parent;\n            }\n\n            context.report({\n                node,\n                loc: locationNode.loc.start,\n                message: \"eval can be harmful.\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         *\n         * @param {escope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                const name = candidatesOfGlobalObject[i];\n                const variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                const references = variable.references;\n\n                for (let j = 0; j < references.length; ++j) {\n                    const identifier = references[j].identifier;\n                    let node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         *\n         * @param {escope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            const references = variable.references;\n\n            for (let i = 0; i < references.length; ++i) {\n                const reference = references[i];\n                const id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\"(node) {\n                    const callee = node.callee;\n\n                    if (isIdentifier(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\"(node) {\n                const callee = node.callee;\n\n                if (isIdentifier(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node,\n                    strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-ex-assign.js":"/**\n * @fileoverview Rule to flag assignment of the exception parameter\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning exceptions in `catch` clauses\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            astUtils.getModifyingReferences(variable.references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"Do not assign to the exception parameter.\" });\n            });\n        }\n\n        return {\n            CatchClause(node) {\n                context.getDeclaredVariables(node).forEach(checkVariable);\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-extend-native.js":"/**\n * @fileoverview Rule to flag adding properties to native object's prototypes.\n * @author David Nelson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow extending native types\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0] || {};\n        const exceptions = config.exceptions || [];\n        let modifiedBuiltins = Object.keys(globals.builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]);\n\n        if (exceptions.length) {\n            modifiedBuiltins = modifiedBuiltins.filter(builtIn => exceptions.indexOf(builtIn) === -1);\n        }\n\n        return {\n\n            // handle the Array.prototype.extra style case\n            AssignmentExpression(node) {\n                const lhs = node.left;\n\n                if (lhs.type !== \"MemberExpression\" || lhs.object.type !== \"MemberExpression\") {\n                    return;\n                }\n\n                const affectsProto = lhs.object.computed\n                    ? lhs.object.property.type === \"Literal\" && lhs.object.property.value === \"prototype\"\n                    : lhs.object.property.name === \"prototype\";\n\n                if (!affectsProto) {\n                    return;\n                }\n\n                modifiedBuiltins.forEach(builtin => {\n                    if (lhs.object.object.name === builtin) {\n                        context.report({\n                            node,\n                            message: \"{{builtin}} prototype is read only, properties should not be added.\",\n                            data: {\n                                builtin\n                            }\n                        });\n                    }\n                });\n            },\n\n            // handle the Object.definePropert[y|ies](Array.prototype) case\n            CallExpression(node) {\n\n                const callee = node.callee;\n\n                // only worry about Object.definePropert[y|ies]\n                if (callee.type === \"MemberExpression\" &&\n                    callee.object.name === \"Object\" &&\n                    (callee.property.name === \"defineProperty\" || callee.property.name === \"defineProperties\")) {\n\n                    // verify the object being added to is a native prototype\n                    const subject = node.arguments[0];\n                    const object = subject && subject.object;\n\n                    if (object &&\n                        object.type === \"Identifier\" &&\n                        (modifiedBuiltins.indexOf(object.name) > -1) &&\n                        subject.property.name === \"prototype\") {\n\n                        context.report({\n                            node,\n                            message: \"{{objectName}} prototype is read only, properties should not be added.\",\n                            data: {\n                                objectName: object.name\n                            }\n                        });\n                    }\n                }\n\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-extra-bind.js":"/**\n * @fileoverview Rule to flag unnecessary bind calls\n * @author Bence Dányi <bence@danyi.me>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary calls to `.bind()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        let scopeInfo = null;\n\n        /**\n         * Reports a given function node.\n         *\n         * @param {ASTNode} node - A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node: node.parent.parent,\n                message: \"The function binding is unnecessary.\",\n                loc: node.parent.property.loc.start,\n                fix(fixer) {\n                    const firstTokenToRemove = context.getSourceCode()\n                        .getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);\n\n                    return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);\n                }\n            });\n        }\n\n        /**\n         * Checks whether or not a given function node is the callee of `.bind()`\n         * method.\n         *\n         * e.g. `(function() {}.bind(foo))`\n         *\n         * @param {ASTNode} node - A node to report. This is a FunctionExpression or\n         *      an ArrowFunctionExpression.\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\n         */\n        function isCalleeOfBindMethod(node) {\n            const parent = node.parent;\n            const grandparent = parent.parent;\n\n            return (\n                grandparent &&\n                grandparent.type === \"CallExpression\" &&\n                grandparent.callee === parent &&\n                grandparent.arguments.length === 1 &&\n                parent.type === \"MemberExpression\" &&\n                parent.object === node &&\n                astUtils.getStaticPropertyName(parent) === \"bind\"\n            );\n        }\n\n        /**\n         * Adds a scope information object to the stack.\n         *\n         * @param {ASTNode} node - A node to add. This node is a FunctionExpression\n         *      or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            scopeInfo = {\n                isBound: isCalleeOfBindMethod(node),\n                thisFound: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the scope information object from the top of the stack.\n         * At the same time, this reports the function node if the function has\n         * `.bind()` and the `this` keywords found.\n         *\n         * @param {ASTNode} node - A node to remove. This node is a\n         *      FunctionExpression or a FunctionDeclaration node.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\n                report(node);\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Reports a given arrow function if the function is callee of `.bind()`\n         * method.\n         *\n         * @param {ASTNode} node - A node to report. This node is an\n         *      ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function exitArrowFunction(node) {\n            if (isCalleeOfBindMethod(node)) {\n                report(node);\n            }\n        }\n\n        /**\n         * Set the mark as the `this` keyword was found in this scope.\n         *\n         * @returns {void}\n         */\n        function markAsThisFound() {\n            if (scopeInfo) {\n                scopeInfo.thisFound = true;\n            }\n        }\n\n        return {\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            ThisExpression: markAsThisFound\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-extra-boolean-cast.js":"/**\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary boolean casts\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        // Node types which have a test which will coerce values to booleans.\n        const BOOLEAN_NODE_TYPES = [\n            \"IfStatement\",\n            \"DoWhileStatement\",\n            \"WhileStatement\",\n            \"ConditionalExpression\",\n            \"ForStatement\"\n        ];\n\n        /**\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\n         *\n         * @param {Object} node The node\n         * @param {Object} parent Its parent\n         * @returns {boolean} If it is in a boolean context\n         */\n        function isInBooleanContext(node, parent) {\n            return (\n                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&\n                    node === parent.test) ||\n\n                // !<bool>\n                (parent.type === \"UnaryExpression\" &&\n                    parent.operator === \"!\")\n            );\n        }\n\n\n        return {\n            UnaryExpression(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                // Exit early if it's guaranteed not to match\n                if (node.operator !== \"!\" ||\n                        parent.type !== \"UnaryExpression\" ||\n                        parent.operator !== \"!\") {\n                    return;\n                }\n\n                if (isInBooleanContext(parent, grandparent) ||\n\n                    // Boolean(<bool>) and new Boolean(<bool>)\n                    ((grandparent.type === \"CallExpression\" || grandparent.type === \"NewExpression\") &&\n                        grandparent.callee.type === \"Identifier\" &&\n                        grandparent.callee.name === \"Boolean\")\n                ) {\n                    context.report({\n                        node,\n                        message: \"Redundant double negation.\",\n                        fix: fixer => fixer.replaceText(parent, sourceCode.getText(node.argument))\n                    });\n                }\n            },\n            CallExpression(node) {\n                const parent = node.parent;\n\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n                    return;\n                }\n\n                if (isInBooleanContext(node, parent)) {\n                    context.report({\n                        node,\n                        message: \"Redundant Boolean call.\",\n                        fix: fixer => {\n                            if (!node.arguments.length) {\n                                return fixer.replaceText(parent, \"true\");\n                            }\n\n                            if (node.arguments.length > 1 || node.arguments[0].type === \"SpreadElement\") {\n                                return null;\n                            }\n\n                            const argument = node.arguments[0];\n\n                            if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {\n                                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                            }\n                            return fixer.replaceText(node, sourceCode.getText(argument));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-extra-label.js":"/**\n * @fileoverview Rule to disallow unnecessary labels\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary labels\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Creates a new scope with a breakable statement.\n         *\n         * @param {ASTNode} node - A node to create. This is a BreakableStatement.\n         * @returns {void}\n         */\n        function enterBreakableStatement(node) {\n            scopeInfo = {\n                label: node.parent.type === \"LabeledStatement\" ? node.parent.label : null,\n                breakable: true,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * @returns {void}\n         */\n        function exitBreakableStatement() {\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Creates a new scope with a labeled statement.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `enterBreakableStatement` function.\n         *\n         * @param {ASTNode} node - A node to create. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = {\n                    label: node.label,\n                    breakable: false,\n                    upper: scopeInfo\n                };\n            }\n        }\n\n        /**\n         * Removes the top scope of the stack.\n         *\n         * This ignores it if the body is a breakable statement.\n         * In this case it's handled in the `exitBreakableStatement` function.\n         *\n         * @param {ASTNode} node - A node. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledStatement(node) {\n            if (!astUtils.isBreakableStatement(node.body)) {\n                scopeInfo = scopeInfo.upper;\n            }\n        }\n\n        /**\n         * Reports a given control node if it's unnecessary.\n         *\n         * @param {ASTNode} node - A node. This is a BreakStatement or a\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function reportIfUnnecessary(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const labelNode = node.label;\n\n            for (let info = scopeInfo; info !== null; info = info.upper) {\n                if (info.breakable || info.label && info.label.name === labelNode.name) {\n                    if (info.breakable && info.label && info.label.name === labelNode.name) {\n                        context.report({\n                            node: labelNode,\n                            message: \"This label '{{name}}' is unnecessary.\",\n                            data: labelNode,\n                            fix: fixer => fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]])\n                        });\n                    }\n                    return;\n                }\n            }\n        }\n\n        return {\n            WhileStatement: enterBreakableStatement,\n            \"WhileStatement:exit\": exitBreakableStatement,\n            DoWhileStatement: enterBreakableStatement,\n            \"DoWhileStatement:exit\": exitBreakableStatement,\n            ForStatement: enterBreakableStatement,\n            \"ForStatement:exit\": exitBreakableStatement,\n            ForInStatement: enterBreakableStatement,\n            \"ForInStatement:exit\": exitBreakableStatement,\n            ForOfStatement: enterBreakableStatement,\n            \"ForOfStatement:exit\": exitBreakableStatement,\n            SwitchStatement: enterBreakableStatement,\n            \"SwitchStatement:exit\": exitBreakableStatement,\n            LabeledStatement: enterLabeledStatement,\n            \"LabeledStatement:exit\": exitLabeledStatement,\n            BreakStatement: reportIfUnnecessary,\n            ContinueStatement: reportIfUnnecessary\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-extra-parens.js":"/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils.js\");\nconst esUtils = require(\"esutils\");\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary parentheses\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: { type: \"boolean\" },\n                                nestedBinaryExpressions: { type: \"boolean\" },\n                                returnAssign: { type: \"boolean\" },\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const tokensToIgnore = new WeakSet();\n        const isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);\n        const precedence = astUtils.getPrecedence;\n        const ALL_NODES = context.options[0] !== \"functions\";\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            if (node.type === \"JSXElement\") {\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n                switch (IGNORE_JSX) {\n\n                    // Exclude this JSX element from linting\n                    case \"all\":\n                        return false;\n\n                    // Exclude this JSX element if it is multi-line element\n                    case \"multi-line\":\n                        return isSingleLine;\n\n                    // Exclude this JSX element if it is single-line element\n                    case \"single-line\":\n                        return !isSingleLine;\n\n                    // Nothing special to be done for JSX elements\n                    case \"none\":\n                        break;\n\n                    // no default\n                }\n            }\n\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            while (node) {\n                if (node.type === \"ReturnStatement\" ||\n                        (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\")) {\n                    return true;\n                }\n                node = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a constructor function is newed-up with parens\n         * @param {ASTNode} newExpression - The NewExpression node to be checked.\n         * @returns {boolean} True if the constructor is called with parens.\n         * @private\n         */\n        function isNewExpressionWithParens(newExpression) {\n            const lastToken = sourceCode.getLastToken(newExpression);\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\n\n            return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            } else if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            } else if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            } else if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            }\n            return containsAssignment(node);\n\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token - The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Determines whether a node should be preceded by an additional space when removing parens\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\n         * @returns {boolean} `true` if a space should be inserted before the node\n         * @private\n         */\n        function requiresLeadingSpace(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);\n            const firstToken = sourceCode.getFirstToken(node);\n\n            // If there is already whitespace before the previous token, don't add more.\n            if (!tokenBeforeLeftParen || tokenBeforeLeftParen.end !== leftParenToken.start) {\n                return false;\n            }\n\n            // If the parens are preceded by a keyword (e.g. `typeof(0)`), a space should be inserted (`typeof 0`)\n            const precededByIdentiferPart = esUtils.code.isIdentifierPartES6(tokenBeforeLeftParen.value.slice(-1).charCodeAt(0));\n\n            // However, a space should not be inserted unless the first character of the token is an identifier part\n            // e.g. `typeof([])` should be fixed to `typeof[]`\n            const startsWithIdentifierPart = esUtils.code.isIdentifierPartES6(firstToken.value.charCodeAt(0));\n\n            // If the parens are preceded by and start with a unary plus/minus (e.g. `+(+foo)`), a space should be inserted (`+ +foo`)\n            const precededByUnaryPlus = tokenBeforeLeftParen.type === \"Punctuator\" && tokenBeforeLeftParen.value === \"+\";\n            const precededByUnaryMinus = tokenBeforeLeftParen.type === \"Punctuator\" && tokenBeforeLeftParen.value === \"-\";\n\n            const startsWithUnaryPlus = firstToken.type === \"Punctuator\" && firstToken.value === \"+\";\n            const startsWithUnaryMinus = firstToken.type === \"Punctuator\" && firstToken.value === \"-\";\n\n            return (precededByIdentiferPart && startsWithIdentifierPart) ||\n                (precededByUnaryPlus && startsWithUnaryPlus) ||\n                (precededByUnaryMinus && startsWithUnaryMinus);\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            const leftParenToken = sourceCode.getTokenBefore(node);\n            const rightParenToken = sourceCode.getTokenAfter(node);\n\n            if (tokensToIgnore.has(sourceCode.getFirstToken(node)) && !isParenthesisedTwice(node)) {\n                return;\n            }\n\n            context.report({\n                node,\n                loc: leftParenToken.loc.start,\n                message: \"Gratuitous parentheses around expression.\",\n                fix(fixer) {\n                    const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n\n                    return fixer.replaceTextRange([\n                        leftParenToken.range[0],\n                        rightParenToken.range[1]\n                    ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource);\n                }\n            });\n        }\n\n        /**\n         * Evaluate Unary update\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkUnaryUpdate(node) {\n            if (node.type === \"UnaryExpression\" && node.argument.type === \"BinaryExpression\" && node.argument.operator === \"**\") {\n                return;\n            }\n\n            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkCallNew(node) {\n            if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(\n                node.type === \"CallExpression\" &&\n                (node.callee.type === \"FunctionExpression\" ||\n                  node.callee.type === \"NewExpression\" && !isNewExpressionWithParens(node.callee)) &&\n\n                // One set of parentheses are allowed for a function expression\n                !hasDoubleExcessParens(node.callee)\n            )) {\n                report(node.callee);\n            }\n            if (node.arguments.length === 1) {\n                if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.arguments[0]);\n                }\n            } else {\n                [].forEach.call(node.arguments, arg => {\n                    if (hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(arg);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinaryLogical(node) {\n            const prec = precedence(node);\n            const leftPrecedence = precedence(node.left);\n            const rightPrecedence = precedence(node.right);\n            const isExponentiation = node.operator === \"**\";\n            const shouldSkipLeft = (NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\")) ||\n              node.left.type === \"UnaryExpression\" && isExponentiation;\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n            if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation))) {\n                report(node.left);\n            }\n            if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation))) {\n                report(node.right);\n            }\n        }\n\n        /**\n         * Check the parentheses around the super class of the given class definition.\n         * @param {ASTNode} node The node of class declarations to check.\n         * @returns {void}\n         */\n        function checkClass(node) {\n            if (!node.superClass) {\n                return;\n            }\n\n            // If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\n            // Otherwise, parentheses are needed.\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\n                ? hasExcessParens(node.superClass)\n                : hasDoubleExcessParens(node.superClass);\n\n            if (hasExtraParens) {\n                report(node.superClass);\n            }\n        }\n\n        /**\n         * Check the parentheses around the argument of the given spread operator.\n         * @param {ASTNode} node The node of spread elements/properties to check.\n         * @returns {void}\n         */\n        function checkSpreadOperator(node) {\n            const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR\n                ? hasExcessParens(node.argument)\n                : hasDoubleExcessParens(node.argument);\n\n            if (hasExtraParens) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\n         * @returns {void}\n         */\n        function checkExpressionOrExportStatement(node) {\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n\n            if (\n                astUtils.isOpeningParenToken(firstToken) &&\n                (\n                    astUtils.isOpeningBraceToken(secondToken) ||\n                    secondToken.type === \"Keyword\" && (\n                        secondToken.value === \"function\" ||\n                        secondToken.value === \"class\" ||\n                        secondToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(secondToken))\n                    )\n                )\n            ) {\n                tokensToIgnore.add(secondToken);\n            }\n\n            if (hasExcessParens(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            ArrayExpression(node) {\n                [].forEach.call(node.elements, e => {\n                    if (e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(e);\n                    }\n                });\n            },\n\n            ArrowFunctionExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n                        tokensToIgnore.add(firstBodyToken);\n                    }\n                    if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(node.body);\n                    }\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression: checkBinaryLogical,\n            CallExpression: checkCallNew,\n\n            ConditionalExpression(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: \"LogicalExpression\", operator: \"||\" })) {\n                    report(node.test);\n                }\n\n                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.consequent);\n                }\n\n                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n            ForInStatement(node) {\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForOfStatement(node) {\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForStatement(node) {\n                if (node.init && hasExcessParens(node.init)) {\n                    report(node.init);\n                }\n\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n            },\n\n            IfStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            LogicalExpression: checkBinaryLogical,\n\n            MemberExpression(node) {\n                if (\n                    hasExcessParens(node.object) &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            astUtils.isDecimalInteger(node.object) ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    )\n                ) {\n                    report(node.object);\n                }\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            NewExpression: checkCallNew,\n\n            ObjectExpression(node) {\n                [].forEach.call(node.properties, e => {\n                    const v = e.value;\n\n                    if (v && hasExcessParens(v) && precedence(v) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n                        report(v);\n                    }\n                });\n            },\n\n            ReturnStatement(node) {\n                const returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression(node) {\n                [].forEach.call(node.expressions, e => {\n                    if (hasExcessParens(e) && precedence(e) >= precedence(node)) {\n                        report(e);\n                    }\n                });\n            },\n\n            SwitchCase(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement(node) {\n                if (hasDoubleExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement(node) {\n                const throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: checkUnaryUpdate,\n            UpdateExpression: checkUnaryUpdate,\n            AwaitExpression: checkUnaryUpdate,\n\n            VariableDeclarator(node) {\n                if (node.init && hasExcessParens(node.init) &&\n                        precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.init.type === \"Literal\" && node.init.regex)) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement(node) {\n                if (hasDoubleExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression(node) {\n                if (node.argument) {\n                    const yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            },\n\n            ClassDeclaration: checkClass,\n            ClassExpression: checkClass,\n\n            SpreadElement: checkSpreadOperator,\n            SpreadProperty: checkSpreadOperator,\n            ExperimentalSpreadProperty: checkSpreadOperator\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-extra-semi.js":"/**\n * @fileoverview Rule to flag use of unnecessary semicolons\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"../util/fix-tracker\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary semicolons\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports an unnecessary semicolon error.\n         * @param {Node|Token} nodeOrToken - A node or a token to be reported.\n         * @returns {void}\n         */\n        function report(nodeOrToken) {\n            context.report({\n                node: nodeOrToken,\n                message: \"Unnecessary semicolon.\",\n                fix(fixer) {\n\n                    // Expand the replacement range to include the surrounding\n                    // tokens to avoid conflicting with semi.\n                    // https://github.com/eslint/eslint/issues/7928\n                    return new FixTracker(fixer, context.getSourceCode())\n                        .retainSurroundingTokens(nodeOrToken)\n                        .remove(nodeOrToken);\n                }\n            });\n        }\n\n        /**\n         * Checks for a part of a class body.\n         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.\n         *\n         * @param {Token} firstToken - The first token to check.\n         * @returns {void}\n         */\n        function checkForPartOfClassBody(firstToken) {\n            for (let token = firstToken;\n                token.type === \"Punctuator\" && !astUtils.isClosingBraceToken(token);\n                token = sourceCode.getTokenAfter(token)\n            ) {\n                if (astUtils.isSemicolonToken(token)) {\n                    report(token);\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Reports this empty statement, except if the parent node is a loop.\n             * @param {Node} node - A EmptyStatement node to be reported.\n             * @returns {void}\n             */\n            EmptyStatement(node) {\n                const parent = node.parent,\n                    allowedParentTypes = [\n                        \"ForStatement\",\n                        \"ForInStatement\",\n                        \"ForOfStatement\",\n                        \"WhileStatement\",\n                        \"DoWhileStatement\",\n                        \"IfStatement\",\n                        \"LabeledStatement\",\n                        \"WithStatement\"\n                    ];\n\n                if (allowedParentTypes.indexOf(parent.type) === -1) {\n                    report(node);\n                }\n            },\n\n            /**\n             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.\n             * @param {Node} node - A ClassBody node to check.\n             * @returns {void}\n             */\n            ClassBody(node) {\n                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.\n            },\n\n            /**\n             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.\n             * @param {Node} node - A MethodDefinition node of the start point.\n             * @returns {void}\n             */\n            MethodDefinition(node) {\n                checkForPartOfClassBody(sourceCode.getTokenAfter(node));\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-fallthrough.js":"/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/i;\n\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node - A SwitchCase node to get comments.\n * @param {RuleContext} context - A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n    const sourceCode = context.getSourceCode();\n    const comment = lodash.last(sourceCode.getComments(node).leading);\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node - The node to check\n * @param {Token} token - The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        let currentCodePath = null;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        let fallthroughCase = null;\n        let fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern);\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        message: \"Expected a 'break' statement before '{{type}}'.\",\n                        data: { type: node.test ? \"case\" : \"default\" },\n                        node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\"(node) {\n                const nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    lodash.last(node.parent.cases) !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-floating-decimal.js":"/**\n * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow leading or trailing decimal points in numeric literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        return {\n            Literal(node) {\n\n                if (typeof node.value === \"number\") {\n                    if (node.raw.indexOf(\".\") === 0) {\n                        context.report({\n                            node,\n                            message: \"A leading decimal point can be confused with a dot.\",\n                            fix: fixer => fixer.insertTextBefore(node, \"0\")\n                        });\n                    }\n                    if (node.raw.indexOf(\".\") === node.raw.length - 1) {\n                        context.report({\n                            node,\n                            message: \"A trailing decimal point can be confused with a dot.\",\n                            fix: fixer => fixer.insertTextAfter(node, \"0\")\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-func-assign.js":"/**\n * @fileoverview Rule to flag use of function declaration identifiers as variables.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `function` declarations\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {References} references - Collection of reference to check.\n         * @returns {void}\n         */\n        function checkReference(references) {\n            astUtils.getModifyingReferences(references).forEach(reference => {\n                context.report({ node: reference.identifier, message: \"'{{name}}' is a function.\", data: { name: reference.identifier.name } });\n            });\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"FunctionName\") {\n                checkReference(variable.references);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n            FunctionDeclaration: checkForFunction,\n            FunctionExpression: checkForFunction\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-global-assign.js":"/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    message: \"Read-only global '{{name}}' should not be modified.\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-implicit-coercion.js":"/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\nconst esUtils = require(\"esutils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {Object} options - An option object to parse.\n * @returns {Object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    options = options || {};\n    return {\n        boolean: \"boolean\" in options ? Boolean(options.boolean) : true,\n        number: \"number\" in options ? Boolean(options.number) : true,\n        string: \"string\" in options ? Boolean(options.string) : true,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    return (\n        node.operator === \"~\" &&\n        node.argument.type === \"CallExpression\" &&\n        node.argument.callee.type === \"MemberExpression\" &&\n        node.argument.callee.property.type === \"Identifier\" &&\n        INDEX_OF_PATTERN.test(node.argument.callee.property.name)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    const left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether a node is an empty string literal or not.\n * @param {ASTNode} node The node to check.\n * @returns {boolean} Whether or not the passed in node is an\n * empty string literal or not.\n */\nfunction isEmptyString(node) {\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||\n        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node - An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && isEmptyString(node.right);\n}\n\n/**\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\n * @param {ASTNode} node - The flagged BinaryExpression node to check.\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\n */\nfunction getNonEmptyOperand(node) {\n    return isEmptyString(node.left) ? node.right : node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\"\n                },\n                number: {\n                    type: \"boolean\"\n                },\n                string: {\n                    type: \"boolean\"\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n        const sourceCode = context.getSourceCode();\n\n        /**\n        * Reports an error and autofixes the node\n        * @param {ASTNode} node - An ast node to report the error on.\n        * @param {string} recommendation - The recommended code for the issue\n        * @param {bool} shouldFix - Whether this report should fix the node\n        * @returns {void}\n        */\n        function report(node, recommendation, shouldFix) {\n            shouldFix = typeof shouldFix === \"undefined\" ? true : shouldFix;\n\n            context.report({\n                node,\n                message: \"use `{{recommendation}}` instead.\",\n                data: {\n                    recommendation\n                },\n                fix(fixer) {\n                    if (!shouldFix) {\n                        return null;\n                    }\n\n                    const tokenBefore = sourceCode.getTokenBefore(node);\n\n                    if (\n                        tokenBefore &&\n                        tokenBefore.range[1] === node.range[0] &&\n                        esUtils.code.isIdentifierPartES6(tokenBefore.value.slice(-1).charCodeAt(0)) &&\n                        esUtils.code.isIdentifierPartES6(recommendation.charCodeAt(0))\n                    ) {\n                        return fixer.replaceText(node, ` ${recommendation}`);\n                    }\n                    return fixer.replaceText(node, recommendation);\n                }\n            });\n        }\n\n        return {\n            UnaryExpression(node) {\n                let operatorAllowed;\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n\n                    report(node, recommendation);\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n                    const recommendation = `${sourceCode.getText(node.argument)} !== -1`;\n\n                    report(node, recommendation, false);\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n\n                    report(node, recommendation);\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\"(node) {\n                let operatorAllowed;\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n\n                    report(node, recommendation);\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n\n                    report(node, recommendation);\n                }\n            },\n\n            AssignmentExpression(node) {\n\n                // foo += \"\"\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\n                    const recommendation = `${code} = String(${code})`;\n\n                    report(node, recommendation);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-implicit-globals.js":"/**\n * @fileoverview Rule to check for implicit global variables and functions.\n * @author Joshua Peek\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable and `function` declarations in the global scope\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                scope.variables.forEach(variable => {\n                    if (variable.writeable) {\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        if (def.type === \"FunctionName\" || (def.type === \"Variable\" && def.parent.kind === \"var\")) {\n                            context.report({ node: def.node, message: \"Implicit global variable, assign as global property instead.\" });\n                        }\n                    });\n                });\n\n                scope.implicit.variables.forEach(variable => {\n                    const scopeVariable = scope.set.get(variable.name);\n\n                    if (scopeVariable && scopeVariable.writeable) {\n                        return;\n                    }\n\n                    variable.defs.forEach(def => {\n                        context.report({ node: def.node, message: \"Implicit global variable, assign as global property instead.\" });\n                    });\n                });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-implied-eval.js":"/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/;\n\n        /*\n         * Figures out if we should inspect a given binary expression. Is a stack\n         * of stacks, where the first element in each substack is a CallExpression.\n         */\n        const impliedEvalAncestorsStack = [];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n         * @param {array} arr What to inspect\n         * @returns {*} The last element of arr\n         * @private\n         */\n        function last(arr) {\n            return arr ? arr[arr.length - 1] : null;\n        }\n\n        /**\n         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} Whether or not the given node is potentially an implied eval.\n         * @private\n         */\n        function isImpliedEvalMemberExpression(node) {\n            const object = node.object,\n                property = node.property,\n                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n\n            return object.name === \"window\" && hasImpliedEvalName;\n        }\n\n        /**\n         * Determines if a node represents a call to a potentially implied eval.\n         *\n         * This checks the callee name and that there's an argument, but not the type of the argument.\n         *\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function isImpliedEvalCallExpression(node) {\n            const isMemberExpression = (node.callee.type === \"MemberExpression\"),\n                isIdentifier = (node.callee.type === \"Identifier\"),\n                isImpliedEvalCallee =\n                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||\n                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));\n\n            return isImpliedEvalCallee && node.arguments.length;\n        }\n\n        /**\n         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n         * @param {ASTNode} node The node to inspect the parent of.\n         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n         * @private\n         */\n        function hasImpliedEvalParent(node) {\n\n            // make sure our parent is marked\n            return node.parent === last(last(impliedEvalAncestorsStack)) &&\n\n                // if our parent is a CallExpression, make sure we're the first argument\n                (node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n        }\n\n        /**\n         * Checks if our parent is marked as part of an implied eval argument. If\n         * so, collapses the top of impliedEvalAncestorsStack and reports on the\n         * original CallExpression.\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function checkString(node) {\n            if (hasImpliedEvalParent(node)) {\n\n                // remove the entire substack, to avoid duplicate reports\n                const substack = impliedEvalAncestorsStack.pop();\n\n                context.report({ node: substack[0], message: \"Implied eval. Consider passing a function instead of a string.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression(node) {\n                if (isImpliedEvalCallExpression(node)) {\n\n                    // call expressions create a new substack\n                    impliedEvalAncestorsStack.push([node]);\n                }\n            },\n\n            \"CallExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n\n                    /* Destroys the entire sub-stack, rather than just using\n                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n                     * always the bottom of a impliedEvalAncestorsStack substack.\n                     */\n                    impliedEvalAncestorsStack.pop();\n                }\n            },\n\n            BinaryExpression(node) {\n                if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n                    last(impliedEvalAncestorsStack).push(node);\n                }\n            },\n\n            \"BinaryExpression:exit\"(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n                    last(impliedEvalAncestorsStack).pop();\n                }\n            },\n\n            Literal(node) {\n                if (typeof node.value === \"string\") {\n                    checkString(node);\n                }\n            },\n\n            TemplateLiteral(node) {\n                checkString(node);\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-inline-comments.js":"/**\n * @fileoverview Enforces or disallows inline comments.\n * @author Greg Cochard\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow inline comments after code\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Will check that comments are not on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check\n         * @private\n         * @returns {void}\n         */\n        function testCodeAroundComment(node) {\n\n            // Get the whole line and cut it off at the start of the comment\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]);\n            const endLine = String(sourceCode.lines[node.loc.end.line - 1]);\n\n            const preamble = startLine.slice(0, node.loc.start.column).trim();\n\n            // Also check after the comment\n            const postamble = endLine.slice(node.loc.end.column).trim();\n\n            // Check that this comment isn't an ESLint directive\n            const isDirective = astUtils.isDirectiveComment(node);\n\n            // Should be empty if there was only whitespace around the comment\n            if (!isDirective && (preamble || postamble)) {\n                context.report({ node, message: \"Unexpected comment inline with code.\" });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LineComment: testCodeAroundComment,\n            BlockComment: testCodeAroundComment\n\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-inner-declarations.js":"/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable or `function` declarations in nested blocks\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"functions\", \"both\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Find the nearest Program or Function ancestor node.\n         * @returns {Object} Ancestor's type and distance from node.\n         */\n        function nearestBody() {\n            const ancestors = context.getAncestors();\n            let ancestor = ancestors.pop(),\n                generation = 1;\n\n            while (ancestor && [\"Program\", \"FunctionDeclaration\",\n                \"FunctionExpression\", \"ArrowFunctionExpression\"\n            ].indexOf(ancestor.type) < 0) {\n                generation += 1;\n                ancestor = ancestors.pop();\n            }\n\n            return {\n\n                // Type of containing ancestor\n                type: ancestor.type,\n\n                // Separation between ancestor and node\n                distance: generation\n            };\n        }\n\n        /**\n         * Ensure that a given node is at a program or function body's root.\n         * @param {ASTNode} node Declaration node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const body = nearestBody(node),\n                valid = ((body.type === \"Program\" && body.distance === 1) ||\n                    body.distance === 2);\n\n            if (!valid) {\n                context.report({ node, message: \"Move {{type}} declaration to {{body}} root.\", data: {\n                    type: (node.type === \"FunctionDeclaration\"\n                            ? \"function\" : \"variable\"),\n                    body: (body.type === \"Program\"\n                            ? \"program\" : \"function body\")\n                } });\n            }\n        }\n\n        return {\n\n            FunctionDeclaration: check,\n            VariableDeclaration(node) {\n                if (context.options[0] === \"both\" && node.kind === \"var\") {\n                    check(node);\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-invalid-regexp.js":"/**\n * @fileoverview Validate strings passed to the RegExp constructor\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                allowConstructorFlags: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\"\n                    }\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let allowedFlags = \"\";\n\n        if (options && options.allowConstructorFlags) {\n            allowedFlags = options.allowConstructorFlags.join(\"\");\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function check(node) {\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(node.arguments[0])) {\n                let flags = isString(node.arguments[1]) ? node.arguments[1].value : \"\";\n\n                if (allowedFlags) {\n                    flags = flags.replace(new RegExp(`[${allowedFlags}]`, \"gi\"), \"\");\n                }\n\n                try {\n                    void new RegExp(node.arguments[0].value);\n                } catch (e) {\n                    context.report({\n                        node,\n                        message: \"{{message}}.\",\n                        data: e\n                    });\n                }\n\n                if (flags) {\n\n                    try {\n                        espree.parse(`/./${flags}`, context.parserOptions);\n                    } catch (ex) {\n                        context.report({\n                            node,\n                            message: \"Invalid flags supplied to RegExp constructor '{{flags}}'.\",\n                            data: {\n                                flags\n                            }\n                        });\n                    }\n                }\n\n            }\n        }\n\n        return {\n            CallExpression: check,\n            NewExpression: check\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-invalid-this.js":"/**\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `this` keywords outside of classes or class-like objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [],\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the current checking context.\n         *\n         * The return value has a flag that whether or not `this` keyword is valid.\n         * The flag is initialized when got at the first time.\n         *\n         * @returns {{valid: boolean}}\n         *   an object which has a flag that whether or not `this` keyword is valid.\n         */\n        stack.getCurrent = function() {\n            const current = this[this.length - 1];\n\n            if (!current.init) {\n                current.init = true;\n                current.valid = !astUtils.isDefaultThisBinding(\n                    current.node,\n                    sourceCode);\n            }\n            return current;\n        };\n\n        /**\n         * Pushs new checking context into the stack.\n         *\n         * The checking context is not initialized yet.\n         * Because most functions don't have `this` keyword.\n         * When `this` keyword was found, the checking context is initialized.\n         *\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n\n            // `this` can be invalid only under strict mode.\n            stack.push({\n                init: !context.getScope().isStrict,\n                node,\n                valid: true\n            });\n        }\n\n        /**\n         * Pops the current checking context from the stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            stack.pop();\n        }\n\n        return {\n\n            /*\n             * `this` is invalid only under strict mode.\n             * Modules is always strict mode.\n             */\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {};\n\n                stack.push({\n                    init: true,\n                    node,\n                    valid: !(\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict)\n                    )\n                });\n            },\n\n            \"Program:exit\"() {\n                stack.pop();\n            },\n\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            // Reports if `this` of the current context is invalid.\n            ThisExpression(node) {\n                const current = stack.getCurrent();\n\n                if (current && !current.valid) {\n                    context.report({ node, message: \"Unexpected 'this'.\" });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-irregular-whitespace.js":"/**\n * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\u00A0\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\u00A0\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mg;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mg;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow irregular whitespace outside of strings and comments\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\"\n                    },\n                    skipStrings: {\n                        type: \"boolean\"\n                    },\n                    skipTemplates: {\n                        type: \"boolean\"\n                    },\n                    skipRegExps: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Module store of errors that we have found\n        let errors = [];\n\n        // Comment nodes.  We accumulate these as we go, so we can be sure to trigger them after the whole `Program` entity is parsed, even for top-of-file comments.\n        const commentNodes = [];\n\n        // Lookup the `skipComments` option, which defaults to `false`.\n        const options = context.options[0] || {};\n        const skipComments = !!options.skipComments;\n        const skipStrings = options.skipStrings !== false;\n        const skipRegExps = !!options.skipRegExps;\n        const skipTemplates = !!options.skipTemplates;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Removes errors that occur inside a string node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            const locStart = node.loc.start;\n            const locEnd = node.loc.end;\n\n            errors = errors.filter(error => {\n                const errorLoc = error[1];\n\n                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {\n                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        /**\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            const shouldCheckRegExps = skipRegExps && (node.value instanceof RegExp);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            const sourceLines = sourceCode.lines;\n\n            sourceLines.forEach((sourceLine, lineIndex) => {\n                const lineNumber = lineIndex + 1;\n                let match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    const location = {\n                        line: lineNumber,\n                        column: match.index\n                    };\n\n                    errors.push([node, location, \"Irregular whitespace not allowed.\"]);\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            const source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK);\n            let lastLineIndex = -1,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n                const location = {\n                    line: lineIndex + 1,\n                    column: sourceLines[lineIndex].length\n                };\n\n                errors.push([node, location, \"Irregular whitespace not allowed.\"]);\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * Stores a comment node (`LineComment` or `BlockComment`) for later stripping of errors within; a necessary deferring of processing to deal with top-of-file comments.\n         * @param {ASTNode} node The comment node\n         * @returns {void}\n         * @private\n         */\n        function rememberCommentNode(node) {\n            commentNodes.push(node);\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        const nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes.LineComment = skipComments ? rememberCommentNode : noop;\n            nodes.BlockComment = skipComments ? rememberCommentNode : noop;\n            nodes[\"Program:exit\"] = function() {\n\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.  We have to do this post-`Program` to deal with top-of-file comments.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(error => {\n                    context.report.apply(context, error);\n                });\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-iterator.js":"/**\n * @fileoverview Rule to flag usage of __iterator__ property\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of the `__iterator__` property\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (node.property &&\n                        (node.property.type === \"Identifier\" && node.property.name === \"__iterator__\" && !node.computed) ||\n                        (node.property.type === \"Literal\" && node.property.value === \"__iterator__\")) {\n                    context.report({ node, message: \"Reserved name '__iterator__'.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-label-var.js":"/**\n * @fileoverview Rule to flag labels that are the same as an identifier\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow labels that share a name with a variable\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Check if the identifier is present inside current scope\n         * @param {Object} scope current scope\n         * @param {string} name To evaluate\n         * @returns {boolean} True if its present\n         * @private\n         */\n        function findIdentifier(scope, name) {\n            return astUtils.getVariableByName(scope, name) !== null;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LabeledStatement(node) {\n\n                // Fetch the innermost scope.\n                const scope = context.getScope();\n\n                // Recursively find the identifier walking up the scope, starting\n                // with the innermost scope.\n                if (findIdentifier(scope, node.label.name)) {\n                    context.report({ node, message: \"Found identifier with same name as label.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-labels.js":"/**\n * @fileoverview Disallow Labeled Statements\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow labeled statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowLoop: {\n                        type: \"boolean\"\n                    },\n                    allowSwitch: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const allowLoop = Boolean(options && options.allowLoop);\n        const allowSwitch = Boolean(options && options.allowSwitch);\n        let scopeInfo = null;\n\n        /**\n         * Gets the kind of a given node.\n         *\n         * @param {ASTNode} node - A node to get.\n         * @returns {string} The kind of the node.\n         */\n        function getBodyKind(node) {\n            if (astUtils.isLoop(node)) {\n                return \"loop\";\n            }\n            if (node.type === \"SwitchStatement\") {\n                return \"switch\";\n            }\n            return \"other\";\n        }\n\n        /**\n         * Checks whether the label of a given kind is allowed or not.\n         *\n         * @param {string} kind - A kind to check.\n         * @returns {boolean} `true` if the kind is allowed.\n         */\n        function isAllowed(kind) {\n            switch (kind) {\n                case \"loop\": return allowLoop;\n                case \"switch\": return allowSwitch;\n                default: return false;\n            }\n        }\n\n        /**\n         * Checks whether a given name is a label of a loop or not.\n         *\n         * @param {string} label - A name of a label to check.\n         * @returns {boolean} `true` if the name is a label of a loop.\n         */\n        function getKind(label) {\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    return info.kind;\n                }\n                info = info.upper;\n            }\n\n            /* istanbul ignore next: syntax error */\n            return \"other\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            LabeledStatement(node) {\n                scopeInfo = {\n                    label: node.label.name,\n                    kind: getBodyKind(node.body),\n                    upper: scopeInfo\n                };\n            },\n\n            \"LabeledStatement:exit\"(node) {\n                if (!isAllowed(scopeInfo.kind)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected labeled statement.\"\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            BreakStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        message: \"Unexpected label in break statement.\"\n                    });\n                }\n            },\n\n            ContinueStatement(node) {\n                if (node.label && !isAllowed(getKind(node.label.name))) {\n                    context.report({\n                        node,\n                        message: \"Unexpected label in continue statement.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-lone-blocks.js":"/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary nested blocks\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        const loneBlocks = [];\n        let ruleDef;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node - The node to be reported.\n         * @returns {void}\n        */\n        function report(node) {\n            const message = node.parent.type === \"BlockStatement\" ? \"Nested block is redundant.\" : \"Block is redundant.\";\n\n            context.report({ node, message });\n        }\n\n        /**\n         * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} True if the node is a lone block.\n        */\n        function isLoneBlock(node) {\n            return node.parent.type === \"BlockStatement\" ||\n                node.parent.type === \"Program\" ||\n\n                // Don't report blocks in switch cases if the block is the only statement of the case.\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @returns {void}\n        */\n        function markLoneBlock() {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            const block = context.getAncestors().pop();\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDef = {\n                BlockStatement(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\"(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function(node) {\n                if (context.getScope().isStrict) {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-lonely-if.js":"/**\n * @fileoverview Rule to disallow if as the only statmenet in an else block\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `if` statements as the only statement in `else` blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            IfStatement(node) {\n                const ancestors = context.getAncestors(),\n                    parent = ancestors.pop(),\n                    grandparent = ancestors.pop();\n\n                if (parent && parent.type === \"BlockStatement\" &&\n                        parent.body.length === 1 && grandparent &&\n                        grandparent.type === \"IfStatement\" &&\n                        parent === grandparent.alternate) {\n                    context.report({\n                        node,\n                        message: \"Unexpected if as the only statement in an else block.\",\n                        fix(fixer) {\n                            const openingElseCurly = sourceCode.getFirstToken(parent);\n                            const closingElseCurly = sourceCode.getLastToken(parent);\n                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);\n                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);\n                            const lastIfToken = sourceCode.getLastToken(node.consequent);\n                            const sourceText = sourceCode.getText();\n\n                            if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {\n\n                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)\n                                return null;\n                            }\n\n                            if (\n                                node.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\" && tokenAfterElseBlock &&\n                                (\n                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||\n                                    /^[([/+`-]/.test(tokenAfterElseBlock.value) ||\n                                    lastIfToken.value === \"++\" ||\n                                    lastIfToken.value === \"--\"\n                                )\n                            ) {\n\n                                /*\n                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing\n                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.\n                                 */\n                                return null;\n                            }\n\n                            return fixer.replaceTextRange(\n                                [openingElseCurly.range[0], closingElseCurly.range[1]],\n                                (elseKeyword.range[1] === openingElseCurly.range[0] ? \" \" : \"\") + sourceCode.getText(node)\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-loop-func.js":"/**\n * @fileoverview Rule to flag creation of function inside a loop\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n *\n * @param {ASTNode} node - An AST node to get.\n * @returns {ASTNode|null} The containing loop node of the specified node, or\n *      `null`.\n */\nfunction getContainingLoopNode(node) {\n    let parent = node.parent;\n\n    while (parent) {\n        switch (parent.type) {\n            case \"WhileStatement\":\n            case \"DoWhileStatement\":\n                return parent;\n\n            case \"ForStatement\":\n\n                // `init` is outside of the loop.\n                if (parent.init !== node) {\n                    return parent;\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n\n                // `right` is outside of the loop.\n                if (parent.right !== node) {\n                    return parent;\n                }\n                break;\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n            case \"FunctionDeclaration\":\n\n                // We don't need to check nested functions.\n                return null;\n\n            default:\n                break;\n        }\n\n        node = parent;\n        parent = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n *\n * @param {ASTNode} node - A node to get. This is a loop node.\n * @param {ASTNode|null} excludedNode - A node that the result node should not\n *      include.\n * @returns {ASTNode} The most outer loop node.\n */\nfunction getTopLoopNode(node, excludedNode) {\n    let retv = node;\n    const border = excludedNode ? excludedNode.range[1] : 0;\n\n    while (node && node.range[0] >= border) {\n        retv = node;\n        node = getContainingLoopNode(node);\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n *\n * @param {ASTNode} funcNode - A target function node.\n * @param {ASTNode} loopNode - A containing loop node.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is safe or not.\n */\nfunction isSafe(funcNode, loopNode, reference) {\n    const variable = reference.resolved;\n    const definition = variable && variable.defs[0];\n    const declaration = definition && definition.parent;\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\n        ? declaration.kind\n        : \"\";\n\n    // Variables which are declared by `const` is safe.\n    if (kind === \"const\") {\n        return true;\n    }\n\n    // Variables which are declared by `let` in the loop is safe.\n    // It's a different instance from the next loop step's.\n    if (kind === \"let\" &&\n        declaration.range[0] > loopNode.range[0] &&\n        declaration.range[1] < loopNode.range[1]\n    ) {\n        return true;\n    }\n\n    // WriteReferences which exist after this border are unsafe because those\n    // can modify the variable.\n    const border = getTopLoopNode(\n        loopNode,\n        (kind === \"let\") ? declaration : null\n    ).range[0];\n\n    /**\n     * Checks whether a given reference is safe or not.\n     * The reference is every reference of the upper scope's variable we are\n     * looking now.\n     *\n     * It's safeafe if the reference matches one of the following condition.\n     * - is readonly.\n     * - doesn't exist inside a local function and after the border.\n     *\n     * @param {escope.Reference} upperRef - A reference to check.\n     * @returns {boolean} `true` if the reference is safe.\n     */\n    function isSafeReference(upperRef) {\n        const id = upperRef.identifier;\n\n        return (\n            !upperRef.isWrite() ||\n            variable.scope.variableScope === upperRef.from.variableScope &&\n            id.range[0] < border\n        );\n    }\n\n    return Boolean(variable) && variable.references.every(isSafeReference);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `function` declarations and expressions inside loop statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports functions which match the following condition:\n         *\n         * - has a loop node in ancestors.\n         * - has any references which refers to an unsafe variable.\n         *\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} Whether or not the node is within a loop.\n         */\n        function checkForLoops(node) {\n            const loopNode = getContainingLoopNode(node);\n\n            if (!loopNode) {\n                return;\n            }\n\n            const references = context.getScope().through;\n\n            if (references.length > 0 &&\n                !references.every(isSafe.bind(null, node, loopNode))\n            ) {\n                context.report({ node, message: \"Don't make functions within a loop.\" });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkForLoops,\n            FunctionExpression: checkForLoops,\n            FunctionDeclaration: checkForLoops\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-magic-numbers.js":"/**\n * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)\n * @author Vincent Lemeunier\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow magic numbers\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                detectObjects: {\n                    type: \"boolean\"\n                },\n                enforceConst: {\n                    type: \"boolean\"\n                },\n                ignore: {\n                    type: \"array\",\n                    items: {\n                        type: \"number\"\n                    },\n                    uniqueItems: true\n                },\n                ignoreArrayIndexes: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            detectObjects = !!config.detectObjects,\n            enforceConst = !!config.enforceConst,\n            ignore = config.ignore || [],\n            ignoreArrayIndexes = !!config.ignoreArrayIndexes;\n\n        /**\n         * Returns whether the node is number literal\n         * @param {Node} node - the node literal being evaluated\n         * @returns {boolean} true if the node is a number literal\n         */\n        function isNumber(node) {\n            return typeof node.value === \"number\";\n        }\n\n        /**\n         * Returns whether the number should be ignored\n         * @param {number} num - the number\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreNumber(num) {\n            return ignore.indexOf(num) !== -1;\n        }\n\n        /**\n         * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent\n         * @param {ASTNode} node - the node literal being evaluated\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreParseInt(parent, node) {\n            return parent.type === \"CallExpression\" && node === parent.arguments[1] &&\n                (parent.callee.name === \"parseInt\" ||\n                parent.callee.type === \"MemberExpression\" &&\n                parent.callee.object.name === \"Number\" &&\n                parent.callee.property.name === \"parseInt\");\n        }\n\n        /**\n         * Returns whether the number should be ignored when used to define a JSX prop\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreJSXNumbers(parent) {\n            return parent.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.\n         * @param {ASTNode} parent - the non-\"UnaryExpression\" parent.\n         * @returns {boolean} true if the number should be ignored\n         */\n        function shouldIgnoreArrayIndexes(parent) {\n            return parent.type === \"MemberExpression\" && ignoreArrayIndexes;\n        }\n\n        return {\n            Literal(node) {\n                let parent = node.parent,\n                    value = node.value,\n                    raw = node.raw;\n                const okTypes = detectObjects ? [] : [\"ObjectExpression\", \"Property\", \"AssignmentExpression\"];\n\n                if (!isNumber(node)) {\n                    return;\n                }\n\n                // For negative magic numbers: update the value and parent node\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"-\") {\n                    node = parent;\n                    parent = node.parent;\n                    value = -value;\n                    raw = `-${raw}`;\n                }\n\n                if (shouldIgnoreNumber(value) ||\n                    shouldIgnoreParseInt(parent, node) ||\n                    shouldIgnoreArrayIndexes(parent) ||\n                    shouldIgnoreJSXNumbers(parent)) {\n                    return;\n                }\n\n                if (parent.type === \"VariableDeclarator\") {\n                    if (enforceConst && parent.parent.kind !== \"const\") {\n                        context.report({\n                            node,\n                            message: \"Number constants declarations must use 'const'.\"\n                        });\n                    }\n                } else if (\n                    okTypes.indexOf(parent.type) === -1 ||\n                    (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\")\n                ) {\n                    context.report({\n                        node,\n                        message: \"No magic number: {{raw}}.\",\n                        data: {\n                            raw\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-mixed-operators.js":"/**\n * @fileoverview Rule to disallow mixed binary operators.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst ALL_OPERATORS = [].concat(\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n);\nconst DEFAULT_GROUPS = [\n    ARITHMETIC_OPERATORS,\n    BITWISE_OPERATORS,\n    COMPARISON_OPERATORS,\n    LOGICAL_OPERATORS,\n    RELATIONAL_OPERATORS\n];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;\n\n/**\n * Normalizes options.\n *\n * @param {Object|undefined} options - A options object to normalize.\n * @returns {Object} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    const hasGroups = (options && options.groups && options.groups.length > 0);\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n    const allowSamePrecedence = (options && options.allowSamePrecedence) !== false;\n\n    return {\n        groups,\n        allowSamePrecedence\n    };\n}\n\n/**\n * Checks whether any group which includes both given operator exists or not.\n *\n * @param {Array.<string[]>} groups - A list of groups to check.\n * @param {string} left - An operator.\n * @param {string} right - Another operator.\n * @returns {boolean} `true` if such group existed.\n */\nfunction includesBothInAGroup(groups, left, right) {\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow mixed binary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    groups: {\n                        type: \"array\",\n                        items: {\n                            type: \"array\",\n                            items: { enum: ALL_OPERATORS },\n                            minItems: 2,\n                            uniqueItems: true\n                        },\n                        uniqueItems: true\n                    },\n                    allowSamePrecedence: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = normalizeOptions(context.options[0]);\n\n        /**\n         * Checks whether a given node should be ignored by options or not.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node should be ignored.\n         */\n        function shouldIgnore(node) {\n            const a = node;\n            const b = node.parent;\n\n            return (\n                !includesBothInAGroup(options.groups, a.operator, b.operator) ||\n                (\n                    options.allowSamePrecedence &&\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\n                )\n            );\n        }\n\n        /**\n         * Checks whether the operator of a given node is mixed with parent\n         * node's operator or not.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {boolean} `true` if the node was mixed.\n         */\n        function isMixedWithParent(node) {\n            return (\n                node.operator !== node.parent.operator &&\n                !astUtils.isParenthesised(sourceCode, node)\n            );\n        }\n\n        /**\n         * Gets the operator token of a given node.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node.\n         * @returns {Token} The operator token of the node.\n         */\n        function getOperatorToken(node) {\n            return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);\n        }\n\n        /**\n         * Reports both the operator of a given node and the operator of the\n         * parent node.\n         *\n         * @param {ASTNode} node - A node to check. This is a BinaryExpression\n         *      node or a LogicalExpression node. This parent node is one of\n         *      them, too.\n         * @returns {void}\n         */\n        function reportBothOperators(node) {\n            const parent = node.parent;\n            const left = (parent.left === node) ? node : parent;\n            const right = (parent.left !== node) ? node : parent;\n            const message =\n                \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.\";\n            const data = {\n                leftOperator: left.operator,\n                rightOperator: right.operator\n            };\n\n            context.report({\n                node: left,\n                loc: getOperatorToken(left).loc.start,\n                message,\n                data\n            });\n            context.report({\n                node: right,\n                loc: getOperatorToken(right).loc.start,\n                message,\n                data\n            });\n        }\n\n        /**\n         * Checks between the operator of this node and the operator of the\n         * parent node.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (TARGET_NODE_TYPE.test(node.parent.type) &&\n                isMixedWithParent(node) &&\n                !shouldIgnore(node)\n            ) {\n                reportBothOperators(node);\n            }\n        }\n\n        return {\n            BinaryExpression: check,\n            LogicalExpression: check\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-mixed-requires.js":"/**\n * @fileoverview Rule to enforce grouped require statements for Node.JS\n * @author Raphael Pigulla\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `require` calls to be mixed with regular variable declarations\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"boolean\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            grouping: {\n                                type: \"boolean\"\n                            },\n                            allowCall: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0];\n        let grouping = false,\n            allowCall = false;\n\n        if (typeof options === \"object\") {\n            grouping = options.grouping;\n            allowCall = options.allowCall;\n        } else {\n            grouping = !!options;\n        }\n\n        /**\n         * Returns the list of built-in modules.\n         *\n         * @returns {string[]} An array of built-in Node.js modules.\n         */\n        function getBuiltinModules() {\n\n            /*\n             * This list is generated using:\n             * `require(\"repl\")._builtinLibs.concat('repl').sort()`\n             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\n             */\n            return [\n                \"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\",\n                \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\",\n                \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\",\n                \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\",\n                \"url\", \"util\", \"v8\", \"vm\", \"zlib\"\n            ];\n        }\n\n        const BUILTIN_MODULES = getBuiltinModules();\n\n        const DECL_REQUIRE = \"require\",\n            DECL_UNINITIALIZED = \"uninitialized\",\n            DECL_OTHER = \"other\";\n\n        const REQ_CORE = \"core\",\n            REQ_FILE = \"file\",\n            REQ_MODULE = \"module\",\n            REQ_COMPUTED = \"computed\";\n\n        /**\n         * Determines the type of a declaration statement.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The type of declaration represented by the expression.\n         */\n        function getDeclarationType(initExpression) {\n            if (!initExpression) {\n\n                // \"var x;\"\n                return DECL_UNINITIALIZED;\n            }\n\n            if (initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"Identifier\" &&\n                initExpression.callee.name === \"require\"\n            ) {\n\n                // \"var x = require('util');\"\n                return DECL_REQUIRE;\n            } else if (allowCall &&\n                initExpression.type === \"CallExpression\" &&\n                initExpression.callee.type === \"CallExpression\"\n            ) {\n\n                // \"var x = require('diagnose')('sub-module');\"\n                return getDeclarationType(initExpression.callee);\n            } else if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return getDeclarationType(initExpression.object);\n            }\n\n            // \"var x = 42;\"\n            return DECL_OTHER;\n        }\n\n        /**\n         * Determines the type of module that is loaded via require.\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\n         * @returns {string} The module type.\n         */\n        function inferModuleType(initExpression) {\n            if (initExpression.type === \"MemberExpression\") {\n\n                // \"var x = require('glob').Glob;\"\n                return inferModuleType(initExpression.object);\n            } else if (initExpression.arguments.length === 0) {\n\n                // \"var x = require();\"\n                return REQ_COMPUTED;\n            }\n\n            const arg = initExpression.arguments[0];\n\n            if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n\n                // \"var x = require(42);\"\n                return REQ_COMPUTED;\n            }\n\n            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n\n                // \"var fs = require('fs');\"\n                return REQ_CORE;\n            } else if (/^\\.{0,2}\\//.test(arg.value)) {\n\n                // \"var utils = require('./utils');\"\n                return REQ_FILE;\n            }\n\n            // \"var async = require('async');\"\n            return REQ_MODULE;\n\n        }\n\n        /**\n         * Check if the list of variable declarations is mixed, i.e. whether it\n         * contains both require and other declarations.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are mixed, false if not.\n         */\n        function isMixed(declarations) {\n            const contains = {};\n\n            declarations.forEach(declaration => {\n                const type = getDeclarationType(declaration.init);\n\n                contains[type] = true;\n            });\n\n            return !!(\n                contains[DECL_REQUIRE] &&\n                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])\n            );\n        }\n\n        /**\n         * Check if all require declarations in the given list are of the same\n         * type.\n         * @param {ASTNode} declarations The list of VariableDeclarators.\n         * @returns {boolean} True if the declarations are grouped, false if not.\n         */\n        function isGrouped(declarations) {\n            const found = {};\n\n            declarations.forEach(declaration => {\n                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n                    found[inferModuleType(declaration.init)] = true;\n                }\n            });\n\n            return Object.keys(found).length <= 1;\n        }\n\n\n        return {\n\n            VariableDeclaration(node) {\n\n                if (isMixed(node.declarations)) {\n                    context.report({ node, message: \"Do not mix 'require' and other declarations.\" });\n                } else if (grouping && !isGrouped(node.declarations)) {\n                    context.report({ node, message: \"Do not mix core, module, file and computed requires.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js":"/**\n * @fileoverview Disallow mixed spaces and tabs for indentation\n * @author Jary Niebur\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow mixed spaces and tabs for indentation\",\n            category: \"Stylistic Issues\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"smart-tabs\", true, false]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        let smartTabs;\n        const ignoredLocs = [];\n\n        switch (context.options[0]) {\n            case true: // Support old syntax, maybe add deprecation warning here\n            case \"smart-tabs\":\n                smartTabs = true;\n                break;\n            default:\n                smartTabs = false;\n        }\n\n        /**\n         * Determines if a given line and column are before a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are before the location, false if not.\n         * @private\n         */\n        function beforeLoc(loc, line, column) {\n            if (line < loc.start.line) {\n                return true;\n            }\n            return line === loc.start.line && column < loc.start.column;\n        }\n\n        /**\n         * Determines if a given line and column are after a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are after the location, false if not.\n         * @private\n         */\n        function afterLoc(loc, line, column) {\n            if (line > loc.end.line) {\n                return true;\n            }\n            return line === loc.end.line && column > loc.end.column;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            TemplateElement(node) {\n                ignoredLocs.push(node.loc);\n            },\n\n            \"Program:exit\"(node) {\n\n                /*\n                 * At least one space followed by a tab\n                 * or the reverse before non-tab/-space\n                 * characters begin.\n                 */\n                let regex = /^(?=[\\t ]*(\\t | \\t))/;\n                const lines = sourceCode.lines,\n                    comments = sourceCode.getAllComments();\n\n                comments.forEach(comment => {\n                    ignoredLocs.push(comment.loc);\n                });\n\n                ignoredLocs.sort((first, second) => {\n                    if (beforeLoc(first, second.start.line, second.start.column)) {\n                        return 1;\n                    }\n\n                    if (beforeLoc(second, first.start.line, second.start.column)) {\n                        return -1;\n                    }\n\n                    return 0;\n                });\n\n                if (smartTabs) {\n\n                    /*\n                     * At least one space followed by a tab\n                     * before non-tab/-space characters begin.\n                     */\n                    regex = /^(?=[\\t ]* \\t)/;\n                }\n\n                lines.forEach((line, i) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        const lineNumber = i + 1,\n                            column = match.index + 1;\n\n                        for (let j = 0; j < ignoredLocs.length; j++) {\n                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n\n                            return;\n                        }\n\n                        context.report({ node, loc: { line: lineNumber, column }, message: \"Mixed spaces and tabs.\" });\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-multi-assign.js":"/**\n * @fileoverview Rule to check use of chained assignment expressions\n * @author Stewart Rand\n */\n\n\"use strict\";\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow use of chained assignment expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            AssignmentExpression(node) {\n                if ([\"AssignmentExpression\", \"VariableDeclarator\"].indexOf(node.parent.type) !== -1) {\n                    context.report({\n                        node,\n                        message: \"Unexpected chained assignment.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-multi-spaces.js":"/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // the index of the last comment that was checked\n        const exceptions = { Property: true },\n            options = context.options[0];\n        let hasExceptions = true,\n            lastCommentIndex = 0;\n\n        if (options && options.exceptions) {\n            Object.keys(options.exceptions).forEach(key => {\n                if (options.exceptions[key]) {\n                    exceptions[key] = true;\n                } else {\n                    delete exceptions[key];\n                }\n            });\n            hasExceptions = Object.keys(exceptions).length > 0;\n        }\n\n        /**\n         * Determines if a given source index is in a comment or not by checking\n         * the index against the comment range. Since the check goes straight\n         * through the file, once an index is passed a certain comment, we can\n         * go to the next comment to check that.\n         * @param {int} index The source index to check.\n         * @param {ASTNode[]} comments An array of comment nodes.\n         * @returns {boolean} True if the index is within a comment, false if not.\n         * @private\n         */\n        function isIndexInComment(index, comments) {\n            while (lastCommentIndex < comments.length) {\n                const comment = comments[lastCommentIndex];\n\n                if (comment.range[0] <= index && index < comment.range[1]) {\n                    return true;\n                } else if (index > comment.range[1]) {\n                    lastCommentIndex++;\n                } else {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program() {\n\n                const sourceCode = context.getSourceCode(),\n                    source = sourceCode.getText(),\n                    allComments = sourceCode.getAllComments(),\n                    JOINED_LINEBEAKS = Array.from(astUtils.LINEBREAKS).join(\"\"),\n                    pattern = new RegExp(String.raw`[^ \\t${JOINED_LINEBEAKS}].? {2,}`, \"g\");  // note: repeating space\n                let parent;\n\n\n                /**\n                 * Creates a fix function that removes the multiple spaces between the two tokens\n                 * @param {RuleFixer} leftToken left token\n                 * @param {RuleFixer} rightToken right token\n                 * @returns {Function} fix function\n                 * @private\n                 */\n                function createFix(leftToken, rightToken) {\n                    return function(fixer) {\n                        return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \");\n                    };\n                }\n\n                while (pattern.test(source)) {\n\n                    // do not flag anything inside of comments\n                    if (!isIndexInComment(pattern.lastIndex, allComments)) {\n\n                        const token = sourceCode.getTokenByRangeStart(pattern.lastIndex);\n\n                        if (token) {\n                            const previousToken = sourceCode.getTokenBefore(token);\n\n                            if (hasExceptions) {\n                                parent = sourceCode.getNodeByRangeIndex(pattern.lastIndex - 1);\n                            }\n\n                            if (!parent || !exceptions[parent.type]) {\n                                context.report({\n                                    node: token,\n                                    loc: token.loc.start,\n                                    message: \"Multiple spaces found before '{{value}}'.\",\n                                    data: { value: token.value },\n                                    fix: createFix(previousToken, token)\n                                });\n                            }\n                        }\n\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-multi-str.js":"/**\n * @fileoverview Rule to flag when using multiline strings\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiline strings\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a JSX node, false if not.\n         * @private\n         */\n        function isJSXElement(node) {\n            return node.type.indexOf(\"JSX\") === 0;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Literal(node) {\n                if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {\n                    context.report({ node, message: \"Multiline support is limited to browsers supporting ES5 only.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-multiple-empty-lines.js":"/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let message, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            message = \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            message = \"Too many blank lines at the end of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            message = \"More than {{max}} blank {{pluralizedLines}} not allowed.\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },\n                                message,\n                                data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\" },\n                                fix(fixer) {\n                                    return fixer.removeRange([\n                                        sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 }),\n                                        sourceCode.getIndexFromLoc({ line: lineNumber - maxAllowed, column: 0 })\n                                    ]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-native-reassign.js":"/**\n * @fileoverview Rule to disallow assignments to native objects or read-only global variables\n * @author Ilya Volodin\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignments to native objects or read-only global variables\",\n            category: \"Best Practices\",\n            recommended: false,\n            replacedBy: [\"no-global-assign\"]\n        },\n\n        deprecated: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: { type: \"string\" },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0];\n        const exceptions = (config && config.exceptions) || [];\n\n        /**\n         * Reports write references.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (reference.init === false &&\n                reference.isWrite() &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                context.report({\n                    node: identifier,\n                    message: \"Read-only global '{{name}}' should not be modified.\",\n                    data: identifier\n                });\n            }\n        }\n\n        /**\n         * Reports write references if a given variable is read-only builtin.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        return {\n            Program() {\n                const globalScope = context.getScope();\n\n                globalScope.variables.forEach(checkVariable);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-negated-condition.js":"/**\n * @fileoverview Rule to disallow a negated condition\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow negated conditions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Determines if a given node is an if-else without a condition on the else\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has an else without an if.\n         * @private\n         */\n        function hasElseWithoutCondition(node) {\n            return node.alternate && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * Determines if a given node is a negated unary expression\n         * @param {Object} test The test object to check.\n         * @returns {boolean} True if the node is a negated unary expression.\n         * @private\n         */\n        function isNegatedUnaryExpression(test) {\n            return test.type === \"UnaryExpression\" && test.operator === \"!\";\n        }\n\n        /**\n         * Determines if a given node is a negated binary expression\n         * @param {Test} test The test to check.\n         * @returns {boolean} True if the node is a negated binary expression.\n         * @private\n         */\n        function isNegatedBinaryExpression(test) {\n            return test.type === \"BinaryExpression\" &&\n                (test.operator === \"!=\" || test.operator === \"!==\");\n        }\n\n        /**\n         * Determines if a given node has a negated if expression\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node has a negated if expression.\n         * @private\n         */\n        function isNegatedIf(node) {\n            return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);\n        }\n\n        return {\n            IfStatement(node) {\n                if (!hasElseWithoutCondition(node)) {\n                    return;\n                }\n\n                if (isNegatedIf(node)) {\n                    context.report({ node, message: \"Unexpected negated condition.\" });\n                }\n            },\n            ConditionalExpression(node) {\n                if (isNegatedIf(node)) {\n                    context.report({ node, message: \"Unexpected negated condition.\" });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-negated-in-lhs.js":"/**\n * @fileoverview A rule to disallow negated left operands of the `in` operator\n * @author Michael Ficarra\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow negating the left operand in `in` expressions\",\n            category: \"Possible Errors\",\n            recommended: false,\n            replacedBy: [\"no-unsafe-negation\"]\n        },\n        deprecated: true,\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                if (node.operator === \"in\" && node.left.type === \"UnaryExpression\" && node.left.operator === \"!\") {\n                    context.report({ node, message: \"The 'in' expression's left operand is negated.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-nested-ternary.js":"/**\n * @fileoverview Rule to flag nested ternary expressions\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow nested ternary expressions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            ConditionalExpression(node) {\n                if (node.alternate.type === \"ConditionalExpression\" ||\n                        node.consequent.type === \"ConditionalExpression\") {\n                    context.report({ node, message: \"Do not nest ternary expressions.\" });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-new-func.js":"/**\n * @fileoverview Rule to flag when using new Function\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with the `Function` object\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a node.\n         * @param {ASTNode} node The node to report\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report({ node, message: \"The Function constructor is eval.\" });\n        }\n\n        return {\n            \"NewExpression[callee.name = 'Function']\": report,\n            \"CallExpression[callee.name = 'Function']\": report\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-new-object.js":"/**\n * @fileoverview A rule to disallow calls to the Object constructor\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `Object` constructors\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.name === \"Object\") {\n                    context.report({ node, message: \"The object literal notation {} is preferrable.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-new-require.js":"/**\n * @fileoverview Rule to disallow use of new operator with the `require` function\n * @author Wil Moore III\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with calls to `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                if (node.callee.type === \"Identifier\" && node.callee.name === \"require\") {\n                    context.report({ node, message: \"Unexpected use of new with require.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-new-symbol.js":"/**\n * @fileoverview Rule to disallow use of the new operator with the `Symbol` object\n * @author Alberto Rodríguez\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with the `Symbol` object\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const variable = globalScope.set.get(\"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(ref => {\n                        const node = ref.identifier;\n\n                        if (node.parent && node.parent.type === \"NewExpression\") {\n                            context.report({ node, message: \"`Symbol` cannot be called as a constructor.\" });\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-new-wrappers.js":"/**\n * @fileoverview Rule to flag when using constructor for wrapper objects\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators with the `String`, `Number`, and `Boolean` objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            NewExpression(node) {\n                const wrapperObjects = [\"String\", \"Number\", \"Boolean\", \"Math\", \"JSON\"];\n\n                if (wrapperObjects.indexOf(node.callee.name) > -1) {\n                    context.report({ node, message: \"Do not use {{fn}} as a constructor.\", data: { fn: node.callee.name } });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-new.js":"/**\n * @fileoverview Rule to flag statements with function invocation preceded by\n * \"new\" and not part of assignment\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `new` operators outside of assignments or comparisons\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            \"ExpressionStatement > NewExpression\"(node) {\n                context.report({ node: node.parent, message: \"Do not use 'new' for side effects.\" });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-obj-calls.js":"/**\n * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow calling global object properties as functions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            CallExpression(node) {\n\n                if (node.callee.type === \"Identifier\") {\n                    const name = node.callee.name;\n\n                    if (name === \"Math\" || name === \"JSON\" || name === \"Reflect\") {\n                        context.report({ node, message: \"'{{name}}' is not a function.\", data: { name } });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-octal-escape.js":"/**\n * @fileoverview Rule to flag octal escape sequences in string literals.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow octal escape sequences in string literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value !== \"string\") {\n                    return;\n                }\n\n                const match = node.raw.match(/^([^\\\\]|\\\\[^0-7])*\\\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/);\n\n                if (match) {\n                    const octalDigit = match[2];\n\n                    // \\0 is actually not considered an octal\n                    if (match[2] !== \"0\" || typeof match[3] !== \"undefined\") {\n                        context.report({ node, message: \"Don't use octal: '\\\\{{octalDigit}}'. Use '\\\\u....' instead.\", data: { octalDigit } });\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-octal.js":"/**\n * @fileoverview Rule to flag when initializing octal literal\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow octal literals\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (typeof node.value === \"number\" && /^0[0-7]/.test(node.raw)) {\n                    context.report({ node, message: \"Octal literals should not be used.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-param-reassign.js":"/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [false]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            props: {\n                                enum: [true]\n                            },\n                            ignorePropertyModificationsFor: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                },\n                                uniqueItems: true\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const props = context.options[0] && Boolean(context.options[0].props);\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference - A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            let node = reference.identifier;\n            let parent = node.parent;\n\n            while (parent && !stopNodePattern.test(parent.type)) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n                    case \"Property\":\n                        if (parent.key === node) {\n                            return false;\n                        }\n\n                        break;\n\n                    // no default\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            const identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report({ node: identifier, message: \"Assignment to function parameter '{{name}}'.\", data: { name: identifier.name } });\n                } else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {\n                    context.report({ node: identifier, message: \"Assignment to property of function parameter '{{name}}'.\", data: { name: identifier.name } });\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-path-concat.js":"/**\n * @fileoverview Disallow string concatenation when using __dirname and __filename\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow string concatenation with `__dirname` and `__filename`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const MATCHER = /^__(?:dir|file)name$/;\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            BinaryExpression(node) {\n\n                const left = node.left,\n                    right = node.right;\n\n                if (node.operator === \"+\" &&\n                        ((left.type === \"Identifier\" && MATCHER.test(left.name)) ||\n                        (right.type === \"Identifier\" && MATCHER.test(right.name)))\n                ) {\n\n                    context.report({ node, message: \"Use path.join() or path.resolve() instead of + to create paths.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-plusplus.js":"/**\n * @fileoverview Rule to flag use of unary increment and decrement operators.\n * @author Ian Christian Myers\n * @author Brody McKee (github.com/mrmckeb)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the unary operators `++` and `--`\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowForLoopAfterthoughts: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0];\n        let allowInForAfterthought = false;\n\n        if (typeof config === \"object\") {\n            allowInForAfterthought = config.allowForLoopAfterthoughts === true;\n        }\n\n        return {\n\n            UpdateExpression(node) {\n                if (allowInForAfterthought && node.parent.type === \"ForStatement\") {\n                    return;\n                }\n                context.report({\n                    node,\n                    message: \"Unary operator '{{operator}}' used.\",\n                    data: {\n                        operator: node.operator\n                    }\n                });\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-process-env.js":"/**\n * @fileoverview Disallow the use of process.env()\n * @author Vignesh Anand\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `process.env`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n                const objectName = node.object.name,\n                    propertyName = node.property.name;\n\n                if (objectName === \"process\" && !node.computed && propertyName && propertyName === \"env\") {\n                    context.report({ node, message: \"Unexpected use of process.env.\" });\n                }\n\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-process-exit.js":"/**\n * @fileoverview Disallow the use of process.exit()\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `process.exit()`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']\"(node) {\n                context.report({ node: node.parent, message: \"Don't use process.exit(); throw an error instead.\" });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-proto.js":"/**\n * @fileoverview Rule to flag usage of __proto__ property\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of the `__proto__` property\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            MemberExpression(node) {\n\n                if (node.property &&\n                        (node.property.type === \"Identifier\" && node.property.name === \"__proto__\" && !node.computed) ||\n                        (node.property.type === \"Literal\" && node.property.value === \"__proto__\")) {\n                    context.report({ node, message: \"The '__proto__' property is deprecated.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-prototype-builtins.js":"/**\n * @fileoverview Rule to disallow use of Object.prototype builtins on objects\n * @author Andrew Levine\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow calling some `Object.prototype` methods directly on objects\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const DISALLOWED_PROPS = [\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\"\n        ];\n\n        /**\n         * Reports if a disallowed property is used in a CallExpression\n         * @param {ASTNode} node The CallExpression node.\n         * @returns {void}\n         */\n        function disallowBuiltIns(node) {\n            if (node.callee.type !== \"MemberExpression\" || node.callee.computed) {\n                return;\n            }\n            const propName = node.callee.property.name;\n\n            if (DISALLOWED_PROPS.indexOf(propName) > -1) {\n                context.report({\n                    message: \"Do not access Object.prototype method '{{prop}}' from target object.\",\n                    loc: node.callee.property.loc.start,\n                    data: { prop: propName },\n                    node\n                });\n            }\n        }\n\n        return {\n            CallExpression: disallowBuiltIns\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-redeclare.js":"/**\n * @fileoverview Rule to flag when the same variable is declared more then once.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable redeclaration\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {\n            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)\n        };\n\n        /**\n         * Find variables in a given scope and flag redeclared ones.\n         * @param {Scope} scope - An escope scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.variables.forEach(variable => {\n                const hasBuiltin = options.builtinGlobals && \"writeable\" in variable;\n                const count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;\n\n                if (count >= 2) {\n                    variable.identifiers.sort((a, b) => a.range[1] - b.range[1]);\n\n                    for (let i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {\n                        context.report({ node: variable.identifiers[i], message: \"'{{a}}' is already defined.\", data: { a: variable.name } });\n                    }\n                }\n            });\n\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @param {ASTNode} node - The Program node.\n         * @returns {void}\n         * @private\n         */\n        function checkForGlobal(node) {\n            const scope = context.getScope(),\n                parserOptions = context.parserOptions,\n                ecmaFeatures = parserOptions.ecmaFeatures || {};\n\n            // Nodejs env or modules has a special scope.\n            if (ecmaFeatures.globalReturn || node.sourceType === \"module\") {\n                findVariablesInScope(scope.childScopes[0]);\n            } else {\n                findVariablesInScope(scope);\n            }\n        }\n\n        /**\n         * Find variables in the current scope.\n         * @returns {void}\n         * @private\n         */\n        function checkForBlock() {\n            findVariablesInScope(context.getScope());\n        }\n\n        if (context.parserOptions.ecmaVersion >= 6) {\n            return {\n                Program: checkForGlobal,\n                BlockStatement: checkForBlock,\n                SwitchStatement: checkForBlock\n            };\n        }\n        return {\n            Program: checkForGlobal,\n            FunctionDeclaration: checkForBlock,\n            FunctionExpression: checkForBlock,\n            ArrowFunctionExpression: checkForBlock\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-regex-spaces.js":"/**\n * @fileoverview Rule to count multiple spaces in regular expressions\n * @author Matt DuVall <http://www.mattduvall.com/>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple spaces in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Validate regular expressions\n         * @param {ASTNode} node node to validate\n         * @param {string} value regular expression to validate\n         * @param {number} valueStart The start location of the regex/string literal. It will always be the case that\n         `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`\n         * @returns {void}\n         * @private\n         */\n        function checkRegex(node, value, valueStart) {\n            const multipleSpacesRegex = /( {2,})+?/,\n                regexResults = multipleSpacesRegex.exec(value);\n\n            if (regexResults !== null) {\n                const count = regexResults[0].length;\n\n                context.report({\n                    node,\n                    message: \"Spaces are hard to count. Use {{{count}}}.\",\n                    data: { count },\n                    fix(fixer) {\n                        return fixer.replaceTextRange(\n                            [valueStart + regexResults.index, valueStart + regexResults.index + count],\n                            ` {${count}}`\n                        );\n                    }\n                });\n\n                /*\n                 * TODO: (platinumazure) Fix message to use rule message\n                 * substitution when api.report is fixed in lib/eslint.js.\n                 */\n            }\n        }\n\n        /**\n         * Validate regular expression literals\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkLiteral(node) {\n            const token = sourceCode.getFirstToken(node),\n                nodeType = token.type,\n                nodeValue = token.value;\n\n            if (nodeType === \"RegularExpression\") {\n                checkRegex(node, nodeValue, token.start);\n            }\n        }\n\n        /**\n         * Check if node is a string\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if its a string\n         * @private\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Validate strings passed to the RegExp constructor\n         * @param {ASTNode} node node to validate\n         * @returns {void}\n         * @private\n         */\n        function checkFunction(node) {\n            const scope = context.getScope();\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\n\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(node.arguments[0]) && !shadowed) {\n                checkRegex(node, node.arguments[0].value, node.arguments[0].start + 1);\n            }\n        }\n\n        return {\n            Literal: checkLiteral,\n            CallExpression: checkFunction,\n            NewExpression: checkFunction\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-restricted-globals.js":"/**\n * @fileoverview Restrict usage of specified globals.\n * @author Benoît Zugmeyer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified global variables\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n        const restrictedGlobals = context.options;\n\n        // if no globals are restricted we don't need to check\n        if (restrictedGlobals.length === 0) {\n            return {};\n        }\n\n        /**\n         * Report a variable to be used as a restricted global.\n         * @param {Reference} reference the variable reference\n         * @returns {void}\n         * @private\n         */\n        function reportReference(reference) {\n            context.report({ node: reference.identifier, message: \"Unexpected use of '{{name}}'.\", data: {\n                name: reference.identifier.name\n            } });\n        }\n\n        /**\n         * Check if the given name is a restricted global name.\n         * @param {string} name name of a variable\n         * @returns {boolean} whether the variable is a restricted global or not\n         * @private\n         */\n        function isRestricted(name) {\n            return restrictedGlobals.indexOf(name) >= 0;\n        }\n\n        return {\n            Program() {\n                const scope = context.getScope();\n\n                // Report variables declared elsewhere (ex: variables defined as \"global\" by eslint)\n                scope.variables.forEach(variable => {\n                    if (!variable.defs.length && isRestricted(variable.name)) {\n                        variable.references.forEach(reportReference);\n                    }\n                });\n\n                // Report variables not declared at all\n                scope.through.forEach(reference => {\n                    if (isRestricted(reference.identifier.name)) {\n                        reportReference(reference);\n                    }\n                });\n\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-restricted-imports.js":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: {\n        type: \"string\"\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified modules when loaded by `import`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStrings,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStrings,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isStringArray = typeof options[0] !== \"object\";\n        const restrictedPaths = new Set(isStringArray ? context.options : options[0].paths || []);\n        const restrictedPatterns = isStringArray ? [] : options[0].patterns || [];\n\n        // if no imports are restricted we don\"t need to check\n        if (restrictedPaths.size === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n        return {\n            ImportDeclaration(node) {\n                if (node && node.source && node.source.value) {\n\n                    const importName = node.source.value.trim();\n\n                    if (restrictedPaths.has(importName)) {\n                        context.report({\n                            node,\n                            message: \"'{{importName}}' import is restricted from being used.\",\n                            data: { importName }\n                        });\n                    }\n                    if (restrictedPatterns.length > 0 && ig.ignores(importName)) {\n                        context.report({\n                            node,\n                            message: \"'{{importName}}' import is restricted from being used by a pattern.\",\n                            data: { importName }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-restricted-modules.js":"/**\n * @fileoverview Restrict usage of specified node modules.\n * @author Christian Schulz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n    type: \"array\",\n    items: {\n        type: \"string\"\n    },\n    uniqueItems: true\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified modules when loaded by `require`\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStrings,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStrings,\n                            patterns: arrayOfStrings\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isStringArray = typeof options[0] !== \"object\";\n        const restrictedPaths = new Set(isStringArray ? context.options : options[0].paths || []);\n        const restrictedPatterns = isStringArray ? [] : options[0].patterns || [];\n\n        // if no imports are restricted we don\"t need to check\n        if (restrictedPaths.size === 0 && restrictedPatterns.length === 0) {\n            return {};\n        }\n\n        const ig = ignore().add(restrictedPatterns);\n\n        /**\n         * Function to check if a node is a string literal.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a string literal.\n         */\n        function isString(node) {\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Function to check if a node is a require call.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} If the node is a require call.\n         */\n        function isRequireCall(node) {\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n        }\n\n        return {\n            CallExpression(node) {\n                if (isRequireCall(node)) {\n\n                    // node has arguments and first argument is string\n                    if (node.arguments.length && isString(node.arguments[0])) {\n                        const moduleName = node.arguments[0].value.trim();\n\n                        // check if argument value is in restricted modules array\n                        if (restrictedPaths.has(moduleName)) {\n                            context.report({\n                                node,\n                                message: \"'{{moduleName}}' module is restricted from being used.\",\n                                data: { moduleName }\n                            });\n                        }\n\n                        if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {\n                            context.report({\n                                node,\n                                message: \"'{{moduleName}}' module is restricted from being used by a pattern.\",\n                                data: { moduleName }\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-restricted-properties.js":"/**\n * @fileoverview Rule to disallow certain object properties\n * @author Will Klein & Eli White\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow certain properties on certain objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                anyOf: [ // `object` and `property` are both optional, but at least one of them must be provided.\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"object\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            object: {\n                                type: \"string\"\n                            },\n                            property: {\n                                type: \"string\"\n                            },\n                            message: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false,\n                        required: [\"property\"]\n                    }\n                ]\n            },\n            uniqueItems: true\n        }\n    },\n\n    create(context) {\n        const restrictedCalls = context.options;\n\n        if (restrictedCalls.length === 0) {\n            return {};\n        }\n\n        const restrictedProperties = new Map();\n        const globallyRestrictedObjects = new Map();\n        const globallyRestrictedProperties = new Map();\n\n        restrictedCalls.forEach(option => {\n            const objectName = option.object;\n            const propertyName = option.property;\n\n            if (typeof objectName === \"undefined\") {\n                globallyRestrictedProperties.set(propertyName, { message: option.message });\n            } else if (typeof propertyName === \"undefined\") {\n                globallyRestrictedObjects.set(objectName, { message: option.message });\n            } else {\n                if (!restrictedProperties.has(objectName)) {\n                    restrictedProperties.set(objectName, new Map());\n                }\n\n                restrictedProperties.get(objectName).set(propertyName, {\n                    message: option.message\n                });\n            }\n        });\n\n        /**\n        * Checks to see whether a property access is restricted, and reports it if so.\n        * @param {ASTNode} node The node to report\n        * @param {string} objectName The name of the object\n        * @param {string} propertyName The name of the property\n        * @returns {undefined}\n        */\n        function checkPropertyAccess(node, objectName, propertyName) {\n            if (propertyName === null) {\n                return;\n            }\n            const matchedObject = restrictedProperties.get(objectName);\n            const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);\n            const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);\n\n            if (matchedObjectProperty) {\n                const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : \"\";\n\n                // eslint-disable-next-line eslint-plugin/report-message-format\n                context.report({ node, message: \"'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}\", data: {\n                    objectName,\n                    propertyName,\n                    message\n                } });\n            } else if (globalMatchedProperty) {\n                const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : \"\";\n\n                // eslint-disable-next-line eslint-plugin/report-message-format\n                context.report({ node, message: \"'{{propertyName}}' is restricted from being used.{{message}}\", data: {\n                    propertyName,\n                    message\n                } });\n            }\n        }\n\n        /**\n        * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`\n        * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node\n        * @returns {undefined}\n        */\n        function checkDestructuringAssignment(node) {\n            if (node.right.type === \"Identifier\") {\n                const objectName = node.right.name;\n\n                if (node.left.type === \"ObjectPattern\") {\n                    node.left.properties.forEach(property => {\n                        checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));\n                    });\n                }\n            }\n        }\n\n        return {\n            MemberExpression(node) {\n                checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));\n            },\n            VariableDeclarator(node) {\n                if (node.init && node.init.type === \"Identifier\") {\n                    const objectName = node.init.name;\n\n                    if (node.id.type === \"ObjectPattern\") {\n                        node.id.properties.forEach(property => {\n                            checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));\n                        });\n                    }\n                }\n            },\n            AssignmentExpression: checkDestructuringAssignment,\n            AssignmentPattern: checkDestructuringAssignment\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-restricted-syntax.js":"/**\n * @fileoverview Rule to flag use of certain node types\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified syntax\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: [{\n                oneOf: [\n                    {\n                        type: \"string\"\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            selector: { type: \"string\" },\n                            message: { type: \"string\" }\n                        },\n                        required: [\"selector\"],\n                        additionalProperties: false\n                    }\n                ]\n            }],\n            uniqueItems: true,\n            minItems: 0\n        }\n    },\n\n    create(context) {\n        return context.options.reduce((result, selectorOrObject) => {\n            const isStringFormat = (typeof selectorOrObject === \"string\");\n            const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);\n\n            const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;\n            const message = hasCustomMessage ? selectorOrObject.message : \"Using '{{selector}}' is not allowed.\";\n\n            return Object.assign(result, {\n                [selector](node) {\n                    context.report({\n                        node,\n                        message,\n                        data: hasCustomMessage ? {} : { selector }\n                    });\n                }\n            });\n        }, {});\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-return-assign.js":"/**\n * @fileoverview Rule to flag when return statement contains assignment\n * @author Ilya Volodin\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignment operators in `return` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const always = (context.options[0] || \"except-parens\") !== \"except-parens\";\n        const sourceCode = context.getSourceCode();\n\n        return {\n            AssignmentExpression(node) {\n                if (!always && astUtils.isParenthesised(sourceCode, node)) {\n                    return;\n                }\n\n                let parent = node.parent;\n\n                // Find ReturnStatement or ArrowFunctionExpression in ancestors.\n                while (parent && !SENTINEL_TYPE.test(parent.type)) {\n                    node = parent;\n                    parent = parent.parent;\n                }\n\n                // Reports.\n                if (parent && parent.type === \"ReturnStatement\") {\n                    context.report({\n                        node: parent,\n                        message: \"Return statement should not contain assignment.\"\n                    });\n                } else if (parent && parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n                    context.report({\n                        node: parent,\n                        message: \"Arrow function should not return assignment.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-return-await.js":"/**\n * @fileoverview Disallows unnecessary `return await`\n * @author Jordan Harband\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst message = \"Redundant use of `await` on a return value.\";\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary `return await`\",\n            category: \"Best Practices\",\n            recommended: false // TODO: set to true\n        },\n        fixable: null,\n        schema: [\n        ]\n    },\n\n    create(context) {\n\n        /**\n         * Reports a found unnecessary `await` expression.\n         * @param {ASTNode} node The node representing the `await` expression to report\n         * @returns {void}\n         */\n        function reportUnnecessaryAwait(node) {\n            context.report({\n                node: context.getSourceCode().getFirstToken(node),\n                loc: node.loc,\n                message\n            });\n        }\n\n        /**\n        * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\n        * this function. For example, a statement in a `try` block will always have an error handler. A statement in\n        * a `catch` block will only have an error handler if there is also a `finally` block.\n        * @param {ASTNode} node A node representing a location where an could be thrown\n        * @returns {boolean} `true` if a thrown error will be caught/handled in this function\n        */\n        function hasErrorHandler(node) {\n            let ancestor = node;\n\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n                    return true;\n                }\n                ancestor = ancestor.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\n         * @param {ASTNode} node A node representing the `await` expression to check\n         * @returns {boolean} The checking result\n         */\n        function isInTailCallPosition(node) {\n            if (node.parent.type === \"ArrowFunctionExpression\") {\n                return true;\n            }\n            if (node.parent.type === \"ReturnStatement\") {\n                return !hasErrorHandler(node.parent);\n            }\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n                return isInTailCallPosition(node.parent);\n            }\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n                return isInTailCallPosition(node.parent);\n            }\n            return false;\n        }\n\n        return {\n            AwaitExpression(node) {\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n                    reportUnnecessaryAwait(node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-script-url.js":"/**\n * @fileoverview Rule to flag when using javascript: urls\n * @author Ilya Volodin\n */\n/* jshint scripturl: true */\n/* eslint no-script-url: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `javascript:` urls\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            Literal(node) {\n                if (node.value && typeof node.value === \"string\") {\n                    const value = node.value.toLowerCase();\n\n                    if (value.indexOf(\"javascript:\") === 0) {\n                        context.report({ node, message: \"Script URL is a form of eval.\" });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-self-assign.js":"/**\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SPACES = /\\s+/g;\n\n/**\n * Checks whether the property of 2 given member expression nodes are the same\n * property or not.\n *\n * @param {ASTNode} left - A member expression node to check.\n * @param {ASTNode} right - Another member expression node to check.\n * @returns {boolean} `true` if the member expressions have the same property.\n */\nfunction isSameProperty(left, right) {\n    if (left.property.type === \"Identifier\" &&\n        left.property.type === right.property.type &&\n        left.property.name === right.property.name &&\n        left.computed === right.computed\n    ) {\n        return true;\n    }\n\n    const lname = astUtils.getStaticPropertyName(left);\n    const rname = astUtils.getStaticPropertyName(right);\n\n    return lname !== null && lname === rname;\n}\n\n/**\n * Checks whether 2 given member expression nodes are the reference to the same\n * property or not.\n *\n * @param {ASTNode} left - A member expression node to check.\n * @param {ASTNode} right - Another member expression node to check.\n * @returns {boolean} `true` if the member expressions are the reference to the\n *  same property or not.\n */\nfunction isSameMember(left, right) {\n    if (!isSameProperty(left, right)) {\n        return false;\n    }\n\n    const lobj = left.object;\n    const robj = right.object;\n\n    if (lobj.type !== robj.type) {\n        return false;\n    }\n    if (lobj.type === \"MemberExpression\") {\n        return isSameMember(lobj, robj);\n    }\n    return lobj.type === \"Identifier\" && lobj.name === robj.name;\n}\n\n/**\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\n *\n * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or\n *      a Property.\n * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or\n *      a Property.\n * @param {boolean} props - The flag to check member expressions as well.\n * @param {Function} report - A callback function to report.\n * @returns {void}\n */\nfunction eachSelfAssignment(left, right, props, report) {\n    if (!left || !right) {\n\n        // do nothing\n    } else if (\n        left.type === \"Identifier\" &&\n        right.type === \"Identifier\" &&\n        left.name === right.name\n    ) {\n        report(right);\n    } else if (\n        left.type === \"ArrayPattern\" &&\n        right.type === \"ArrayExpression\"\n    ) {\n        const end = Math.min(left.elements.length, right.elements.length);\n\n        for (let i = 0; i < end; ++i) {\n            const rightElement = right.elements[i];\n\n            eachSelfAssignment(left.elements[i], rightElement, props, report);\n\n            // After a spread element, those indices are unknown.\n            if (rightElement && rightElement.type === \"SpreadElement\") {\n                break;\n            }\n        }\n    } else if (\n        left.type === \"RestElement\" &&\n        right.type === \"SpreadElement\"\n    ) {\n        eachSelfAssignment(left.argument, right.argument, props, report);\n    } else if (\n        left.type === \"ObjectPattern\" &&\n        right.type === \"ObjectExpression\" &&\n        right.properties.length >= 1\n    ) {\n\n        // Gets the index of the last spread property.\n        // It's possible to overwrite properties followed by it.\n        let startJ = 0;\n\n        for (let i = right.properties.length - 1; i >= 0; --i) {\n            if (right.properties[i].type === \"ExperimentalSpreadProperty\") {\n                startJ = i + 1;\n                break;\n            }\n        }\n\n        for (let i = 0; i < left.properties.length; ++i) {\n            for (let j = startJ; j < right.properties.length; ++j) {\n                eachSelfAssignment(\n                    left.properties[i],\n                    right.properties[j],\n                    props,\n                    report\n                );\n            }\n        }\n    } else if (\n        left.type === \"Property\" &&\n        right.type === \"Property\" &&\n        !left.computed &&\n        !right.computed &&\n        right.kind === \"init\" &&\n        !right.method &&\n        left.key.name === right.key.name\n    ) {\n        eachSelfAssignment(left.value, right.value, props, report);\n    } else if (\n        props &&\n        left.type === \"MemberExpression\" &&\n        right.type === \"MemberExpression\" &&\n        isSameMember(left, right)\n    ) {\n        report(right);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignments where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = context.options[0];\n        const props = Boolean(options && options.props);\n\n        /**\n         * Reports a given node as self assignments.\n         *\n         * @param {ASTNode} node - A node to report. This is an Identifier node.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"'{{name}}' is assigned to itself.\",\n                data: {\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\n                }\n            });\n        }\n\n        return {\n            AssignmentExpression(node) {\n                if (node.operator === \"=\") {\n                    eachSelfAssignment(node.left, node.right, props, report);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-self-compare.js":"/**\n * @fileoverview Rule to flag comparison where left part is the same as the right\n * part.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comparisons where both sides are exactly the same\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            BinaryExpression(node) {\n                const operators = [\"===\", \"==\", \"!==\", \"!=\", \">\", \"<\", \">=\", \"<=\"];\n\n                if (operators.indexOf(node.operator) > -1 &&\n                    (node.left.type === \"Identifier\" && node.right.type === \"Identifier\" && node.left.name === node.right.name ||\n                    node.left.type === \"Literal\" && node.right.type === \"Literal\" && node.left.value === node.right.value)) {\n                    context.report({ node, message: \"Comparing to itself is potentially pointless.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-sequences.js":"/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comma operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Parts of the grammar that are required to have parens.\n         */\n        const parenthesized = {\n            DoWhileStatement: \"test\",\n            IfStatement: \"test\",\n            SwitchStatement: \"discriminant\",\n            WhileStatement: \"test\",\n            WithStatement: \"object\",\n            ArrowFunctionExpression: \"body\"\n\n            // Omitting CallExpression - commas are parsed as argument separators\n            // Omitting NewExpression - commas are parsed as argument separators\n            // Omitting ForInStatement - parts aren't individually parenthesised\n            // Omitting ForStatement - parts aren't individually parenthesised\n        };\n\n        /**\n         * Determines whether a node is required by the grammar to be wrapped in\n         * parens, e.g. the test of an if statement.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if parens around node belong to parent node.\n         */\n        function requiresExtraParens(node) {\n            return node.parent && parenthesized[node.parent.type] &&\n                    node === node.parent[parenthesized[node.parent.type]];\n        }\n\n        /**\n         * Check if a node is wrapped in parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if the node has a paren on each side.\n         */\n        function isParenthesised(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if a node is wrapped in two levels of parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if two parens surround the node on each side.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        return {\n            SequenceExpression(node) {\n\n                // Always allow sequences in for statement update\n                if (node.parent.type === \"ForStatement\" &&\n                        (node === node.parent.init || node === node.parent.update)) {\n                    return;\n                }\n\n                // Wrapping a sequence in extra parens indicates intent\n                if (requiresExtraParens(node)) {\n                    if (isParenthesisedTwice(node)) {\n                        return;\n                    }\n                } else {\n                    if (isParenthesised(node)) {\n                        return;\n                    }\n                }\n\n                const child = sourceCode.getTokenAfter(node.expressions[0]);\n\n                context.report({ node, loc: child.loc.start, message: \"Unexpected use of comma operator.\" });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-shadow-restricted-names.js":"/**\n * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow identifiers from shadowing restricted names\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const RESTRICTED = [\"undefined\", \"NaN\", \"Infinity\", \"arguments\", \"eval\"];\n\n        /**\n         * Check if the node name is present inside the restricted list\n         * @param {ASTNode} id id to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForViolation(id) {\n            if (RESTRICTED.indexOf(id.name) > -1) {\n                context.report({\n                    node: id,\n                    message: \"Shadowing of global property '{{idName}}'.\",\n                    data: {\n                        idName: id.name\n                    }\n                });\n            }\n        }\n\n        return {\n            VariableDeclarator(node) {\n                checkForViolation(node.id);\n            },\n            ArrowFunctionExpression(node) {\n                [].map.call(node.params, checkForViolation);\n            },\n            FunctionExpression(node) {\n                if (node.id) {\n                    checkForViolation(node.id);\n                }\n                [].map.call(node.params, checkForViolation);\n            },\n            FunctionDeclaration(node) {\n                if (node.id) {\n                    checkForViolation(node.id);\n                    [].map.call(node.params, checkForViolation);\n                }\n            },\n            CatchClause(node) {\n                checkForViolation(node.param);\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-shadow.js":"/**\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    builtinGlobals: { type: \"boolean\" },\n                    hoist: { enum: [\"all\", \"functions\", \"never\"] },\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = {\n            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\n            allow: (context.options[0] && context.options[0].allow) || []\n        };\n\n        /**\n         * Check if variable name is allowed.\n         *\n         * @param  {ASTNode} variable The variable to check.\n         * @returns {boolean} Whether or not the variable name is allowed.\n         */\n        function isAllowed(variable) {\n            return options.allow.indexOf(variable.name) !== -1;\n        }\n\n        /**\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\n         *\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n         * So we should ignore the variable in the class scope.\n         *\n         * @param {Object} variable The variable to check.\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\n         */\n        function isDuplicatedClassNameVariable(variable) {\n            const block = variable.scope.block;\n\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n        }\n\n        /**\n         * Checks if a variable is inside the initializer of scopeVar.\n         *\n         * To avoid reporting at declarations such as `var a = function a() {};`.\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n         *\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The scope variable to look for.\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\n         */\n        function isOnInitializer(variable, scopeVar) {\n            const outerScope = scopeVar.scope;\n            const outerDef = scopeVar.defs[0];\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\n            const innerScope = variable.scope;\n            const innerDef = variable.defs[0];\n            const inner = innerDef && innerDef.name.range;\n\n            return (\n                outer &&\n                inner &&\n                outer[0] < inner[0] &&\n                inner[1] < outer[1] &&\n                ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\n                outerScope === innerScope.upper\n            );\n        }\n\n        /**\n         * Get a range of a variable's identifier node.\n         * @param {Object} variable The variable to get.\n         * @returns {Array|undefined} The range of the variable's identifier node.\n         */\n        function getNameRange(variable) {\n            const def = variable.defs[0];\n\n            return def && def.name.range;\n        }\n\n        /**\n         * Checks if a variable is in TDZ of scopeVar.\n         * @param {Object} variable The variable to check.\n         * @param {Object} scopeVar The variable of TDZ.\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\n         */\n        function isInTdz(variable, scopeVar) {\n            const outerDef = scopeVar.defs[0];\n            const inner = getNameRange(variable);\n            const outer = getNameRange(scopeVar);\n\n            return (\n                inner &&\n                outer &&\n                inner[1] < outer[0] &&\n\n                // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n                (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\n            );\n        }\n\n        /**\n         * Checks the current context for shadowed variables.\n         * @param {Scope} scope - Fixme\n         * @returns {void}\n         */\n        function checkForShadows(scope) {\n            const variables = scope.variables;\n\n            for (let i = 0; i < variables.length; ++i) {\n                const variable = variables[i];\n\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n                if (variable.identifiers.length === 0 ||\n                    isDuplicatedClassNameVariable(variable) ||\n                    isAllowed(variable)\n                ) {\n                    continue;\n                }\n\n                // Gets shadowed variable.\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n                if (shadowed &&\n                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\n                    !isOnInitializer(variable, shadowed) &&\n                    !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\n                ) {\n                    context.report({\n                        node: variable.identifiers[0],\n                        message: \"'{{name}}' is already declared in the upper scope.\",\n                        data: variable\n                    });\n                }\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n                const stack = globalScope.childScopes.slice();\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push.apply(stack, scope.childScopes);\n                    checkForShadows(scope);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-spaced-func.js":"/**\n * @fileoverview Rule to check that spaced function application\n * @author Matt DuVall <http://www.mattduvall.com>\n * @deprecated in ESLint v3.3.0\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow spacing between function identifiers and their applications (deprecated)\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            replacedBy: [\"func-call-spacing\"]\n        },\n\n        deprecated: true,\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if open space is present in a function name\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function detectOpenSpaces(node) {\n            const lastCalleeToken = sourceCode.getLastToken(node.callee);\n            let prevToken = lastCalleeToken,\n                parenToken = sourceCode.getTokenAfter(lastCalleeToken);\n\n            // advances to an open parenthesis.\n            while (\n                parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                parenToken.value !== \"(\"\n            ) {\n                prevToken = parenToken;\n                parenToken = sourceCode.getTokenAfter(parenToken);\n            }\n\n            // look for a space between the callee and the open paren\n            if (parenToken &&\n                parenToken.range[1] < node.range[1] &&\n                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)\n            ) {\n                context.report({\n                    node,\n                    loc: lastCalleeToken.loc.start,\n                    message: \"Unexpected space between function name and paren.\",\n                    fix(fixer) {\n                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        return {\n            CallExpression: detectOpenSpaces,\n            NewExpression: detectOpenSpaces\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-sparse-arrays.js":"/**\n * @fileoverview Disallow sparse arrays\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow sparse arrays\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            ArrayExpression(node) {\n\n                const emptySpot = node.elements.indexOf(null) > -1;\n\n                if (emptySpot) {\n                    context.report({ node, message: \"Unexpected comma in middle of array.\" });\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-sync.js":"/**\n * @fileoverview Rule to check for properties whose identifier ends with the string Sync\n * @author Matt DuVall<http://mattduvall.com/>\n */\n\n/* jshint node:true */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow synchronous methods\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            \"MemberExpression[property.name=/.*Sync$/]\"(node) {\n                context.report({\n                    node,\n                    message: \"Unexpected sync method: '{{propertyName}}'.\",\n                    data: {\n                        propertyName: node.property.name\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-tabs.js":"/**\n * @fileoverview Rule to check for tabs inside a file\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst regex = /\\t/;\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow all tabs\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n        return {\n            Program(node) {\n                context.getSourceLines().forEach((line, index) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        context.report({ node, loc: {\n                            line: index + 1,\n                            column: match.index + 1\n                        }, message: \"Unexpected tab character.\" });\n                    }\n                });\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-template-curly-in-string.js":"/**\n * @fileoverview Warn when using template string syntax in regular strings\n * @author Jeroen Engels\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow template literal placeholder syntax in regular strings\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const regex = /\\$\\{[^}]+\\}/;\n\n        return {\n            Literal(node) {\n                if (typeof node.value === \"string\" && regex.test(node.value)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected template string expression.\"\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-ternary.js":"/**\n * @fileoverview Rule to flag use of ternary operators.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow ternary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ConditionalExpression(node) {\n                context.report({ node, message: \"Ternary operator used.\" });\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-this-before-super.js":"/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `this`/`super` before calling `super()` in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * Information for each code path segment.\n         * Each key is the id of a code path segment.\n         * Each value is an object:\n         * - superCalled:  The flag which shows `super()` called in all code paths.\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass(funcInfo) &&\n                !funcInfo.codePath.currentSegments.every(isCalled)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node - A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            const segments = funcInfo.codePath.currentSegments;\n\n            for (let i = 0; i < segments.length; ++i) {\n                const segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this treverses all segments of this code path then reports every\n             * invalid node.\n             *\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath) {\n                const isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                codePath.traverseSegments((segment, controller) => {\n                    const info = segInfoMap[segment.id];\n\n                    for (let i = 0; i < info.invalidNodes.length; ++i) {\n                        const invalidNode = info.invalidNodes[i];\n\n                        context.report({\n                            message: \"'{{kind}}' is not allowed before 'super()'.\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!isInConstructorOfDerivedClass(funcInfo)) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass(funcInfo)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    (segment, controller) => {\n                        const info = segInfoMap[segment.id];\n\n                        if (info.superCalled) {\n                            info.invalidNodes = [];\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                            info.invalidNodes = [];\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            ThisExpression(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            Super(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-throw-literal.js":"/**\n * @fileoverview Rule to restrict what can be thrown as an exception.\n * @author Dieter Oberkofler\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow throwing literals as exceptions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n\n            ThrowStatement(node) {\n                if (!astUtils.couldBeError(node.argument)) {\n                    context.report({ node, message: \"Expected an object to be thrown.\" });\n                } else if (node.argument.type === \"Identifier\") {\n                    if (node.argument.name === \"undefined\") {\n                        context.report({ node, message: \"Do not throw undefined.\" });\n                    }\n                }\n\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-trailing-spaces.js":"/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\n            NONBLANK = `${BLANK_CLASS}+$`;\n\n        const options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node,\n                loc: location,\n                message: \"Trailing spaces not allowed.\",\n                fix(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                // Let's hack. Since Espree does not return whitespace nodes,\n                // fetch the source code and do matching via regexps.\n\n                const re = new RegExp(NONBLANK),\n                    skipMatch = new RegExp(SKIP_BLANK),\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher());\n                let totalLength = 0,\n                    fixRange = [];\n\n                for (let i = 0, ii = lines.length; i < ii; i++) {\n                    const matches = re.exec(lines[i]);\n\n                    // Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                    // Because during the fix time they also reserve one spot in the array.\n                    // Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    const lineLength = lines[i].length + linebreakLength;\n\n                    if (matches) {\n                        const location = {\n                            line: i + 1,\n                            column: matches.index\n                        };\n\n                        const rangeStart = totalLength + location.column;\n                        const rangeEnd = totalLength + lineLength - linebreakLength;\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        // If the line has only whitespace, and skipBlankLines\n                        // is true, don't report it\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n                        report(node, location, fixRange);\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-undef-init.js":"/**\n * @fileoverview Rule to flag when initializing to undefined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow initializing variables to `undefined`\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            VariableDeclarator(node) {\n                const name = sourceCode.getText(node.id),\n                    init = node.init && node.init.name,\n                    scope = context.getScope(),\n                    undefinedVar = astUtils.getVariableByName(scope, \"undefined\"),\n                    shadowed = undefinedVar && undefinedVar.defs.length > 0;\n\n                if (init === \"undefined\" && node.parent.kind !== \"const\" && !shadowed) {\n                    context.report({\n                        node,\n                        message: \"It's not necessary to initialize '{{name}}' to undefined.\",\n                        data: { name },\n                        fix(fixer) {\n                            if (node.id.type === \"ArrayPattern\" || node.id.type === \"ObjectPattern\") {\n\n                                // Don't fix destructuring assignment to `undefined`.\n                                return null;\n                            }\n                            return fixer.removeRange([node.id.range[1], node.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-undef.js":"/**\n * @fileoverview Rule to flag references to undeclared variables.\n * @author Mark Macdonald\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if the given node is the argument of a typeof operator.\n * @param {ASTNode} node The AST node being checked.\n * @returns {boolean} Whether or not the node is the argument of a typeof operator.\n */\nfunction hasTypeOfOperator(node) {\n    const parent = node.parent;\n\n    return parent.type === \"UnaryExpression\" && parent.operator === \"typeof\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of undeclared variables unless mentioned in `/*global */` comments\",\n            category: \"Variables\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    typeof: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0];\n        const considerTypeOf = options && options.typeof === true || false;\n\n        return {\n            \"Program:exit\"(/* node */) {\n                const globalScope = context.getScope();\n\n                globalScope.through.forEach(ref => {\n                    const identifier = ref.identifier;\n\n                    if (!considerTypeOf && hasTypeOfOperator(identifier)) {\n                        return;\n                    }\n\n                    context.report({\n                        node: identifier,\n                        message: \"'{{name}}' is not defined.\",\n                        data: identifier\n                    });\n                });\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-undefined.js":"/**\n * @fileoverview Rule to flag references to the undefined variable.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `undefined` as an identifier\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Report an invalid \"undefined\" identifier node.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node,\n                message: \"Unexpected use of undefined.\"\n            });\n        }\n\n        /**\n         * Checks the given scope for references to `undefined` and reports\n         * all references found.\n         * @param {escope.Scope} scope The scope to check.\n         * @returns {void}\n         */\n        function checkScope(scope) {\n            const undefinedVar = scope.set.get(\"undefined\");\n\n            if (!undefinedVar) {\n                return;\n            }\n\n            const references = undefinedVar.references;\n\n            const defs = undefinedVar.defs;\n\n            // Report non-initializing references (those are covered in defs below)\n            references\n                .filter(ref => !ref.init)\n                .forEach(ref => report(ref.identifier));\n\n            defs.forEach(def => report(def.name));\n        }\n\n        return {\n            \"Program:exit\"() {\n                const globalScope = context.getScope();\n\n                const stack = [globalScope];\n\n                while (stack.length) {\n                    const scope = stack.pop();\n\n                    stack.push.apply(stack, scope.childScopes);\n                    checkScope(scope);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-underscore-dangle.js":"/**\n * @fileoverview Rule to flag trailing underscores in variable declarations.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow dangling underscores in identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    allowAfterThis: {\n                        type: \"boolean\"\n                    },\n                    allowAfterSuper: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {};\n        const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n        const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n        const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n\n        //-------------------------------------------------------------------------\n        // Helpers\n        //-------------------------------------------------------------------------\n\n        /**\n         * Check if identifier is present inside the allowed option\n         * @param {string} identifier name of the node\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function isAllowed(identifier) {\n            return ALLOWED_VARIABLES.some(ident => ident === identifier);\n        }\n\n        /**\n         * Check if identifier has a underscore at the end\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is present\n         * @private\n         */\n        function hasTrailingUnderscore(identifier) {\n            const len = identifier.length;\n\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n        }\n\n        /**\n         * Check if identifier is a special case member expression\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\n            return identifier === \"__proto__\";\n        }\n\n        /**\n         * Check if identifier is a special case variable expression\n         * @param {ASTNode} identifier node to evaluate\n         * @returns {boolean} true if its is a special case\n         * @private\n         */\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\n\n            // Checks for the underscore library usage here\n            return identifier === \"_\";\n        }\n\n        /**\n         * Check if function has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInFunctionDeclaration(node) {\n            if (node.id) {\n                const identifier = node.id.name;\n\n                if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {\n                    context.report({\n                        node,\n                        message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                        data: {\n                            identifier\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Check if variable expression has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInVariableExpression(node) {\n            const identifier = node.id.name;\n\n            if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) &&\n                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if member expression has a underscore at the end\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkForTrailingUnderscoreInMemberExpression(node) {\n            const identifier = node.property.name,\n                isMemberOfThis = node.object.type === \"ThisExpression\",\n                isMemberOfSuper = node.object.type === \"Super\";\n\n            if (typeof identifier !== \"undefined\" && hasTrailingUnderscore(identifier) &&\n                !(isMemberOfThis && allowAfterThis) &&\n                !(isMemberOfSuper && allowAfterSuper) &&\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n                context.report({\n                    node,\n                    message: \"Unexpected dangling '_' in '{{identifier}}'.\",\n                    data: {\n                        identifier\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,\n            VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,\n            MemberExpression: checkForTrailingUnderscoreInMemberExpression\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unexpected-multiline.js":"/**\n * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.\n * @author Glen Mailer\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow confusing multiline expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        const FUNCTION_MESSAGE = \"Unexpected newline between function and ( of function call.\";\n        const PROPERTY_MESSAGE = \"Unexpected newline between object and [ of property access.\";\n        const TAGGED_TEMPLATE_MESSAGE = \"Unexpected newline between template tag and template literal.\";\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check to see if there is a newline between the node and the following open bracket\n         * line's expression\n         * @param {ASTNode} node The node to check.\n         * @param {string} msg The error message to use.\n         * @returns {void}\n         * @private\n         */\n        function checkForBreakAfter(node, msg) {\n            const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);\n            const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);\n\n            if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {\n                context.report({ node, loc: openParen.loc.start, message: msg, data: { char: openParen.value } });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            MemberExpression(node) {\n                if (!node.computed) {\n                    return;\n                }\n                checkForBreakAfter(node.object, PROPERTY_MESSAGE);\n            },\n\n            TaggedTemplateExpression(node) {\n                if (node.tag.loc.end.line === node.quasi.loc.start.line) {\n                    return;\n                }\n                context.report({ node, loc: node.loc.start, message: TAGGED_TEMPLATE_MESSAGE });\n            },\n\n            CallExpression(node) {\n                if (node.arguments.length === 0) {\n                    return;\n                }\n                checkForBreakAfter(node.callee, FUNCTION_MESSAGE);\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unmodified-loop-condition.js":"/**\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Traverser = require(\"../util/traverser\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst pushAll = Function.apply.bind(Array.prototype.push);\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/;  // for-in/of statements don't have `test` property.\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;\n\n/**\n * @typedef {Object} LoopConditionInfo\n * @property {escope.Reference} reference - The reference.\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\n *      that the reference is belonging to.\n * @property {Function} isInLoop - The predicate which checks a given reference\n *      is in this loop.\n * @property {boolean} modified - The flag that the reference is modified in\n *      this loop.\n */\n\n/**\n * Checks whether or not a given reference is a write reference.\n *\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is a write reference.\n */\nfunction isWriteReference(reference) {\n    if (reference.init) {\n        const def = reference.resolved && reference.resolved.defs[0];\n\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n            return false;\n        }\n    }\n    return reference.isWrite();\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodified(condition) {\n    return !condition.modified;\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag and does not have the group this condition belongs to.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n    return !(condition.modified || condition.group);\n}\n\n/**\n * Checks whether or not a given reference is inside of a given node.\n *\n * @param {ASTNode} node - A node to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the node.\n */\nfunction isInRange(node, reference) {\n    const or = node.range;\n    const ir = reference.identifier.range;\n\n    return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of a loop node's condition.\n *\n * @param {ASTNode} node - A node to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the loop node's\n *      condition.\n */\nconst isInLoop = {\n    WhileStatement: isInRange,\n    DoWhileStatement: isInRange,\n    ForStatement(node, reference) {\n        return (\n            isInRange(node, reference) &&\n            !(node.init && isInRange(node.init, reference))\n        );\n    }\n};\n\n/**\n * Checks whether or not a given group node has any dynamic elements.\n *\n * @param {ASTNode} root - A node to check.\n *      This node is one of BinaryExpression or ConditionalExpression.\n * @returns {boolean} `true` if the node is dynamic.\n */\nfunction hasDynamicExpressions(root) {\n    let retv = false;\n    const traverser = new Traverser();\n\n    traverser.traverse(root, {\n        enter(node) {\n            if (DYNAMIC_PATTERN.test(node.type)) {\n                retv = true;\n                this.break();\n            } else if (SKIP_PATTERN.test(node.type)) {\n                this.skip();\n            }\n        }\n    });\n\n    return retv;\n}\n\n/**\n * Creates the loop condition information from a given reference.\n *\n * @param {escope.Reference} reference - A reference to create.\n * @returns {LoopConditionInfo|null} Created loop condition info, or null.\n */\nfunction toLoopCondition(reference) {\n    if (reference.init) {\n        return null;\n    }\n\n    let group = null;\n    let child = reference.identifier;\n    let node = child.parent;\n\n    while (node) {\n        if (SENTINEL_PATTERN.test(node.type)) {\n            if (LOOP_PATTERN.test(node.type) && node.test === child) {\n\n                // This reference is inside of a loop condition.\n                return {\n                    reference,\n                    group,\n                    isInLoop: isInLoop[node.type].bind(null, node),\n                    modified: false\n                };\n            }\n\n            // This reference is outside of a loop condition.\n            break;\n        }\n\n        /*\n         * If it's inside of a group, OK if either operand is modified.\n         * So stores the group this reference belongs to.\n         */\n        if (GROUP_PATTERN.test(node.type)) {\n\n            // If this expression is dynamic, no need to check.\n            if (hasDynamicExpressions(node)) {\n                break;\n            } else {\n                group = node;\n            }\n        }\n\n        child = node;\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Gets the function which encloses a given reference.\n * This supports only FunctionDeclaration.\n *\n * @param {escope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} The function node or null.\n */\nfunction getEncloseFunctionDeclaration(reference) {\n    let node = reference.identifier;\n\n    while (node) {\n        if (node.type === \"FunctionDeclaration\") {\n            return node.id ? node : null;\n        }\n\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\n *\n * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.\n * @param {escope.Reference[]} modifiers - The references to update.\n * @returns {void}\n */\nfunction updateModifiedFlag(conditions, modifiers) {\n    let funcNode, funcVar;\n\n    for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n            const modifier = modifiers[j];\n\n            /*\n             * Besides checking for the condition being in the loop, we want to\n             * check the function that this modifier is belonging to is called\n             * in the loop.\n             * FIXME: This should probably be extracted to a function.\n             */\n            const inLoop = condition.isInLoop(modifier) || Boolean(\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\n                funcVar.references.some(condition.isInLoop)\n            );\n\n            condition.modified = inLoop;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unmodified loop conditions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let groupMap = null;\n\n        /**\n         * Reports a given condition info.\n         *\n         * @param {LoopConditionInfo} condition - A loop condition info to report.\n         * @returns {void}\n         */\n        function report(condition) {\n            const node = condition.reference.identifier;\n\n            context.report({\n                node,\n                message: \"'{{name}}' is not modified in this loop.\",\n                data: node\n            });\n        }\n\n        /**\n         * Registers given conditions to the group the condition belongs to.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to\n         *      register.\n         * @returns {void}\n         */\n        function registerConditionsToGroup(conditions) {\n            for (let i = 0; i < conditions.length; ++i) {\n                const condition = conditions[i];\n\n                if (condition.group) {\n                    let group = groupMap.get(condition.group);\n\n                    if (!group) {\n                        group = [];\n                        groupMap.set(condition.group, group);\n                    }\n                    group.push(condition);\n                }\n            }\n        }\n\n        /**\n         * Reports references which are inside of unmodified groups.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to report.\n         * @returns {void}\n         */\n        function checkConditionsInGroup(conditions) {\n            if (conditions.every(isUnmodified)) {\n                conditions.forEach(report);\n            }\n        }\n\n        /**\n         * Finds unmodified references which are inside of a loop condition.\n         * Then reports the references which are outside of groups.\n         *\n         * @param {escope.Variable} variable - A variable to report.\n         * @returns {void}\n         */\n        function checkReferences(variable) {\n\n            // Gets references that exist in loop conditions.\n            const conditions = variable\n                .references\n                .map(toLoopCondition)\n                .filter(Boolean);\n\n            if (conditions.length === 0) {\n                return;\n            }\n\n            // Registers the conditions to belonging groups.\n            registerConditionsToGroup(conditions);\n\n            // Check the conditions are modified.\n            const modifiers = variable.references.filter(isWriteReference);\n\n            if (modifiers.length > 0) {\n                updateModifiedFlag(conditions, modifiers);\n            }\n\n            /*\n             * Reports the conditions which are not belonging to groups.\n             * Others will be reported after all variables are done.\n             */\n            conditions\n                .filter(isUnmodifiedAndNotBelongToGroup)\n                .forEach(report);\n        }\n\n        return {\n            \"Program:exit\"() {\n                const queue = [context.getScope()];\n\n                groupMap = new Map();\n\n                let scope;\n\n                while ((scope = queue.pop())) {\n                    pushAll(queue, scope.childScopes);\n                    scope.variables.forEach(checkReferences);\n                }\n\n                groupMap.forEach(checkConditionsInGroup);\n                groupMap = null;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unneeded-ternary.js":"/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n// Operators that always result in a boolean value\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n    \"==\": \"!=\",\n    \"!=\": \"==\",\n    \"===\": \"!==\",\n    \"!==\": \"===\"\n\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const defaultAssignment = options.defaultAssignment !== false;\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node - The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\n         * @param {ASTNode} node A node representing an expression\n         * @returns {string} A string representing an inverted expression\n         */\n        function invertExpression(node) {\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n                const operatorToken = sourceCode.getFirstTokenBetween(\n                    node.left,\n                    node.right,\n                    token => token.value === node.operator\n                );\n\n                return sourceCode.getText().slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + sourceCode.getText().slice(operatorToken.range[1], node.range[1]);\n            }\n\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n            }\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n        }\n\n        /**\n         * Tests if a given node always evaluates to a boolean value\n         * @param {ASTNode} node - An expression node\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\n         */\n        function isBooleanExpression(node) {\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node - The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of boolean literals in conditional expression.\",\n                        fix(fixer) {\n                            if (node.consequent.value === node.alternate.value) {\n\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n                            }\n                            if (node.alternate.value) {\n\n                                // Replace `foo() ? false : true` with `!(foo())`\n                                return fixer.replaceText(node, invertExpression(node.test));\n                            }\n\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n                        }\n                    });\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report({\n                        node,\n                        loc: node.consequent.loc.start,\n                        message: \"Unnecessary use of conditional expression for default assignment.\",\n                        fix: fixer => fixer.replaceText(node, `${astUtils.getParenthesisedText(sourceCode, node.test)} || ${astUtils.getParenthesisedText(sourceCode, node.alternate)}`)\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unreachable.js":"/**\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\n * @author Joel Feenstra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable declarator has the initializer.\n * @param {ASTNode} node - A VariableDeclarator node to check.\n * @returns {boolean} `true` if the node has the initializer.\n */\nfunction isInitialized(node) {\n    return Boolean(node.init);\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n/**\n * The class to distinguish consecutive unreachable statements.\n */\nclass ConsecutiveRange {\n    constructor(sourceCode) {\n        this.sourceCode = sourceCode;\n        this.startNode = null;\n        this.endNode = null;\n    }\n\n    /**\n     * The location object of this range.\n     * @type {Object}\n     */\n    get location() {\n        return {\n            start: this.startNode.loc.start,\n            end: this.endNode.loc.end\n        };\n    }\n\n    /**\n     * `true` if this range is empty.\n     * @type {boolean}\n     */\n    get isEmpty() {\n        return !(this.startNode && this.endNode);\n    }\n\n    /**\n     * Checks whether the given node is inside of this range.\n     * @param {ASTNode|Token} node - The node to check.\n     * @returns {boolean} `true` if the node is inside of this range.\n     */\n    contains(node) {\n        return (\n            node.range[0] >= this.startNode.range[0] &&\n            node.range[1] <= this.endNode.range[1]\n        );\n    }\n\n    /**\n     * Checks whether the given node is consecutive to this range.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if the node is consecutive to this range.\n     */\n    isConsecutive(node) {\n        return this.contains(this.sourceCode.getTokenBefore(node));\n    }\n\n    /**\n     * Merges the given node to this range.\n     * @param {ASTNode} node - The node to merge.\n     * @returns {void}\n     */\n    merge(node) {\n        this.endNode = node;\n    }\n\n    /**\n     * Resets this range by the given node or null.\n     * @param {ASTNode|null} node - The node to reset, or null.\n     * @returns {void}\n     */\n    reset(node) {\n        this.startNode = this.endNode = node;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let currentCodePath = null;\n\n        const range = new ConsecutiveRange(context.getSourceCode());\n\n        /**\n         * Reports a given node if it's unreachable.\n         * @param {ASTNode} node - A statement node to report.\n         * @returns {void}\n         */\n        function reportIfUnreachable(node) {\n            let nextNode = null;\n\n            if (node && currentCodePath.currentSegments.every(isUnreachable)) {\n\n                // Store this statement to distinguish consecutive statements.\n                if (range.isEmpty) {\n                    range.reset(node);\n                    return;\n                }\n\n                // Skip if this statement is inside of the current range.\n                if (range.contains(node)) {\n                    return;\n                }\n\n                // Merge if this statement is consecutive to the current range.\n                if (range.isConsecutive(node)) {\n                    range.merge(node);\n                    return;\n                }\n\n                nextNode = node;\n            }\n\n            // Report the current range since this statement is reachable or is\n            // not consecutive to the current range.\n            if (!range.isEmpty) {\n                context.report({\n                    message: \"Unreachable code.\",\n                    loc: range.location,\n                    node: range.startNode\n                });\n            }\n\n            // Update the current range.\n            range.reset(nextNode);\n        }\n\n        return {\n\n            // Manages the current code path.\n            onCodePathStart(codePath) {\n                currentCodePath = codePath;\n            },\n\n            onCodePathEnd() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            // Registers for all statement nodes (excludes FunctionDeclaration).\n            BlockStatement: reportIfUnreachable,\n            BreakStatement: reportIfUnreachable,\n            ClassDeclaration: reportIfUnreachable,\n            ContinueStatement: reportIfUnreachable,\n            DebuggerStatement: reportIfUnreachable,\n            DoWhileStatement: reportIfUnreachable,\n            EmptyStatement: reportIfUnreachable,\n            ExpressionStatement: reportIfUnreachable,\n            ForInStatement: reportIfUnreachable,\n            ForOfStatement: reportIfUnreachable,\n            ForStatement: reportIfUnreachable,\n            IfStatement: reportIfUnreachable,\n            ImportDeclaration: reportIfUnreachable,\n            LabeledStatement: reportIfUnreachable,\n            ReturnStatement: reportIfUnreachable,\n            SwitchStatement: reportIfUnreachable,\n            ThrowStatement: reportIfUnreachable,\n            TryStatement: reportIfUnreachable,\n\n            VariableDeclaration(node) {\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n                    reportIfUnreachable(node);\n                }\n            },\n\n            WhileStatement: reportIfUnreachable,\n            WithStatement: reportIfUnreachable,\n            ExportNamedDeclaration: reportIfUnreachable,\n            ExportDefaultDeclaration: reportIfUnreachable,\n            ExportAllDeclaration: reportIfUnreachable,\n\n            \"Program:exit\"() {\n                reportIfUnreachable();\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unsafe-finally.js":"/**\n * @fileoverview Rule to flag unsafe statements in finally block\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nconst SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/;\nconst SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/;\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow control flow statements in `finally` blocks\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n    create(context) {\n\n        /**\n         * Checks if the node is the finalizer of a TryStatement\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {boolean} - true if the node is the finalizer of a TryStatement\n         */\n        function isFinallyBlock(node) {\n            return node.parent.type === \"TryStatement\" && node.parent.finalizer === node;\n        }\n\n        /**\n         * Climbs up the tree if the node is not a sentinel node\n         *\n         * @param {ASTNode} node - node to check.\n         * @param {string} label - label of the break or continue statement\n         * @returns {boolean} - return whether the node is a finally block or a sentinel node\n         */\n        function isInFinallyBlock(node, label) {\n            let labelInside = false;\n            let sentinelNodeType;\n\n            if (node.type === \"BreakStatement\" && !node.label) {\n                sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;\n            } else if (node.type === \"ContinueStatement\") {\n                sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;\n            } else {\n                sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;\n            }\n\n            while (node && !sentinelNodeType.test(node.type)) {\n                if (node.parent.label && label && (node.parent.label.name === label.name)) {\n                    labelInside = true;\n                }\n                if (isFinallyBlock(node)) {\n                    if (label && labelInside) {\n                        return false;\n                    }\n                    return true;\n                }\n                node = node.parent;\n            }\n            return false;\n        }\n\n        /**\n         * Checks whether the possibly-unsafe statement is inside a finally block.\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (isInFinallyBlock(node, node.label)) {\n                context.report({\n                    message: \"Unsafe usage of {{nodeType}}.\",\n                    data: {\n                        nodeType: node.type\n                    },\n                    node,\n                    line: node.loc.line,\n                    column: node.loc.column\n                });\n            }\n        }\n\n        return {\n            ReturnStatement: check,\n            ThrowStatement: check,\n            BreakStatement: check,\n            ContinueStatement: check\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unsafe-negation.js":"/**\n * @fileoverview Rule to disallow negating the left operand of relational operators\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given operator is a relational operator or not.\n *\n * @param {string} op - The operator type to check.\n * @returns {boolean} `true` if the operator is a relational operator.\n */\nfunction isRelationalOperator(op) {\n    return op === \"in\" || op === \"instanceof\";\n}\n\n/**\n * Checks whether the given node is a logical negation expression or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is a logical negation expression.\n */\nfunction isNegation(node) {\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow negating the left operand of relational operators\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n                if (isRelationalOperator(node.operator) &&\n                    isNegation(node.left) &&\n                    !astUtils.isParenthesised(sourceCode, node.left)\n                ) {\n                    context.report({\n                        node,\n                        loc: node.left.loc,\n                        message: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n                        data: node,\n\n                        fix(fixer) {\n                            const negationToken = sourceCode.getFirstToken(node.left);\n                            const fixRange = [negationToken.range[1], node.range[1]];\n                            const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n\n                            return fixer.replaceTextRange(fixRange, `(${text})`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unused-expressions.js":"/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\"\n                    },\n                    allowTernary: {\n                        type: \"boolean\"\n                    },\n                    allowTaggedTemplates: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false,\n            allowTaggedTemplates = config.allowTaggedTemplates || false;\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list - the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (let i = 0; i < list.length; ++i) {\n                if (!predicate(list[i])) {\n                    return list.slice(0, i);\n                }\n            }\n            return list.slice();\n        }\n\n        /**\n         * @param {ASTNode} node - a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * @param {ASTNode} node - any node\n         * @param {ASTNode[]} ancestors - the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            const parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node is a valid expression\n         */\n        function isValidExpression(node) {\n            if (allowTernary) {\n\n                // Recursive check for ternary and logical expressions\n                if (node.type === \"ConditionalExpression\") {\n                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);\n                }\n            }\n\n            if (allowShortCircuit) {\n                if (node.type === \"LogicalExpression\") {\n                    return isValidExpression(node.right);\n                }\n            }\n\n            if (allowTaggedTemplates && node.type === \"TaggedTemplateExpression\") {\n                return true;\n            }\n\n            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) ||\n                (node.type === \"UnaryExpression\" && [\"delete\", \"void\"].indexOf(node.operator) >= 0);\n        }\n\n        return {\n            ExpressionStatement(node) {\n                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report({ node, message: \"Expected an assignment or function call and instead saw an expression.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unused-labels.js":"/**\n * @fileoverview Rule to disallow unused labels.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused labels\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Adds a scope info to the stack.\n         *\n         * @param {ASTNode} node - A node to add. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function enterLabeledScope(node) {\n            scopeInfo = {\n                label: node.label.name,\n                used: false,\n                upper: scopeInfo\n            };\n        }\n\n        /**\n         * Removes the top of the stack.\n         * At the same time, this reports the label if it's never used.\n         *\n         * @param {ASTNode} node - A node to report. This is a LabeledStatement.\n         * @returns {void}\n         */\n        function exitLabeledScope(node) {\n            if (!scopeInfo.used) {\n                context.report({\n                    node: node.label,\n                    message: \"'{{name}}:' is defined but never used.\",\n                    data: node.label,\n                    fix(fixer) {\n\n                        /*\n                         * Only perform a fix if there are no comments between the label and the body. This will be the case\n                         * when there is exactly one token/comment (the \":\") between the label and the body.\n                         */\n                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) === sourceCode.getTokenBefore(node.body, { includeComments: true })) {\n                            return fixer.removeRange([node.range[0], node.body.range[0]]);\n                        }\n\n                        return null;\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        /**\n         * Marks the label of a given node as used.\n         *\n         * @param {ASTNode} node - A node to mark. This is a BreakStatement or\n         *      ContinueStatement.\n         * @returns {void}\n         */\n        function markAsUsed(node) {\n            if (!node.label) {\n                return;\n            }\n\n            const label = node.label.name;\n            let info = scopeInfo;\n\n            while (info) {\n                if (info.label === label) {\n                    info.used = true;\n                    break;\n                }\n                info = info.upper;\n            }\n        }\n\n        return {\n            LabeledStatement: enterLabeledScope,\n            \"LabeledStatement:exit\": exitLabeledScope,\n            BreakStatement: markAsUsed,\n            ContinueStatement: markAsUsed\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-unused-vars.js":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused variables\",\n            category: \"Variables\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            }\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const DEFINED_MESSAGE = \"'{{name}}' is defined but never used.\";\n        const ASSIGNED_MESSAGE = \"'{{name}}' is assigned a value but never used.\";\n        const REST_PROPERTY_TYPE = /^(?:Experimental)?RestProperty$/;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);\n                }\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable - EScope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable - EScope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                return variable.defs.some(def => {\n                    const propertyNode = def.name.parent;\n                    const patternNode = propertyNode.parent;\n\n                    return (\n                        propertyNode.type === \"Property\" &&\n                        patternNode.type === \"ObjectPattern\" &&\n                        REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type)\n                    );\n                });\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref - An escope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref - The reference to check.\n         * @param {ASTNode[]} nodes - The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.indexOf(scope.block) >= 0) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         *\n         * @param {ASTNode} inner - A node which is expected as inside.\n         * @param {ASTNode} outer - A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         *\n         * @param {escope.Reference} ref - A reference to check.\n         * @param {ASTNode} prevRhsNode - The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                granpa.type === \"ExpressionStatement\" &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         *\n         * @param {ASTNode} funcNode - A function node to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         *\n         * @param {ASTNode} id - An Identifier node to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         *\n         * @param {escope.Reference} ref - A reference to check.\n         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const granpa = parent.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    parent.type === \"AssignmentExpression\" &&\n                    granpa.type === \"ExpressionStatement\" &&\n                    parent.left === id\n                ) ||\n                (\n                    parent.type === \"UpdateExpression\" &&\n                    granpa.type === \"ExpressionStatement\"\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in loops.\n         *\n         * @param {Reference} ref - The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable - The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = variable.defs.filter(def => def.type === \"FunctionName\").map(def => def.node),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is the last parameter in the non-ignored parameters.\n         *\n         * @param {escope.Variable} variable - The variable to check.\n         * @returns {boolean} `true` if the variable is the last.\n         */\n        function isLastInNonIgnoredParameters(variable) {\n            const def = variable.defs[0];\n\n            // This is the last.\n            if (def.index === def.node.params.length - 1) {\n                return true;\n            }\n\n            // if all parameters preceded by this variable are ignored and unused, this is the last.\n            if (config.argsIgnorePattern) {\n                const params = context.getDeclaredVariables(def.node);\n                const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n                if (posteriorParams.every(v => v.references.length === 0 && config.argsIgnorePattern.test(v.name))) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope - an escope Scope object.\n         * @param {Variable[]} unusedVars - an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"TDZ\" && (scope.type !== \"global\" || config.vars === \"all\")) {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip all but the last parameter\n                            if (config.args === \"after-used\" && !isLastInNonIgnoredParameters(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        /**\n         * Gets the index of a given variable name in a given comment.\n         * @param {escope.Variable} variable - A variable to get.\n         * @param {ASTNode} comment - A comment node which includes the variable name.\n         * @returns {number} The index of the variable name's location.\n         * @private\n         */\n        function getColumnInComment(variable, comment) {\n            const namePattern = new RegExp(`[\\\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\\\s,:])`, \"g\");\n\n            // To ignore the first text \"global\".\n            namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\n\n            // Search a given variable name.\n            const match = namePattern.exec(comment.value);\n\n            return match ? match.index + 1 : 0;\n        }\n\n        /**\n         * Creates the correct location of a given variables.\n         * The location is at its name string in a `/*global` comment.\n         *\n         * @param {escope.Variable} variable - A variable to get its location.\n         * @returns {{line: number, column: number}} The location object for the variable.\n         * @private\n         */\n        function getLocation(variable) {\n            const comment = variable.eslintExplicitGlobalComment;\n\n            return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    if (unusedVar.eslintExplicitGlobal) {\n                        context.report({\n                            node: programNode,\n                            loc: getLocation(unusedVar),\n                            message: DEFINED_MESSAGE,\n                            data: unusedVar\n                        });\n                    } else if (unusedVar.defs.length > 0) {\n                        context.report({\n                            node: unusedVar.identifiers[0],\n                            message: unusedVar.references.some(ref => ref.isWrite()) ? ASSIGNED_MESSAGE : DEFINED_MESSAGE,\n                            data: unusedVar\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-use-before-define.js":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;\n\n/**\n * Parses a given value as options.\n *\n * @param {any} options - A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n    }\n\n    return { functions, classes, variables };\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n* Checks whether or not a given variable is a variable declaration in an upper function scope.\n* @param {escope.Variable} variable - A variable to check.\n* @param {escope.Reference} reference - A reference to check.\n* @returns {boolean} `true` if the variable is a variable declaration.\n*/\nfunction isOuterVariable(variable, reference) {\n    return (\n        variable.defs[0].type === \"Variable\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n *\n * @param {ASTNode} node - An node to check.\n * @param {number} location - A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *\n * @param {Variable} variable - A variable to check.\n * @param {Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    let node = variable.identifiers[0].parent;\n    const location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given use-before-define case should be reported according to the options.\n         * @param {escope.Variable} variable The variable that gets used before being defined\n         * @param {escope.Reference} reference The reference to the variable\n         * @returns {boolean} `true` if the usage should be reported\n         */\n        function isForbidden(variable, reference) {\n            if (isFunction(variable)) {\n                return options.functions;\n            }\n            if (isOuterClass(variable, reference)) {\n                return options.classes;\n            }\n            if (isOuterVariable(variable, reference)) {\n                return options.variables;\n            }\n            return true;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(reference => {\n                const variable = reference.resolved;\n\n                // Skips when the reference is:\n                // - initialization's.\n                // - referring to an undefined variable.\n                // - referring to a global environment variable (there're no identifiers).\n                // - located preceded by the variable (except in initializers).\n                // - allowed by options.\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    !isForbidden(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    message: \"'{{name}}' was used before it was defined.\",\n                    data: reference.identifier\n                });\n            });\n        }\n\n        /**\n         * Validates variables inside of a node's scope.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function findVariables() {\n            const scope = context.getScope();\n\n            findVariablesInScope(scope);\n        }\n\n        const ruleDefinition = {\n            \"Program:exit\"(node) {\n                const scope = context.getScope(),\n                    ecmaFeatures = context.parserOptions.ecmaFeatures || {};\n\n                findVariablesInScope(scope);\n\n                // both Node.js and Modules have an extra scope\n                if (ecmaFeatures.globalReturn || node.sourceType === \"module\") {\n                    findVariablesInScope(scope.childScopes[0]);\n                }\n            }\n        };\n\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDefinition[\"BlockStatement:exit\"] =\n                ruleDefinition[\"SwitchStatement:exit\"] = findVariables;\n\n            ruleDefinition[\"ArrowFunctionExpression:exit\"] = function(node) {\n                if (node.body.type !== \"BlockStatement\") {\n                    findVariables(node);\n                }\n            };\n        } else {\n            ruleDefinition[\"FunctionExpression:exit\"] =\n                ruleDefinition[\"FunctionDeclaration:exit\"] =\n                ruleDefinition[\"ArrowFunctionExpression:exit\"] = findVariables;\n        }\n\n        return ruleDefinition;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-call.js":"/**\n * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.call()`/`.apply()`.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.\n */\nfunction isCallOrNonVariadicApply(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.computed === false &&\n        (\n            (node.callee.property.name === \"call\" && node.arguments.length >= 1) ||\n            (node.callee.property.name === \"apply\" && node.arguments.length === 2 && node.arguments[1].type === \"ArrayExpression\")\n        )\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, sourceCode) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, sourceCode);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary calls to `.call()` and `.apply()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isCallOrNonVariadicApply(node)) {\n                    return;\n                }\n\n                const applied = node.callee.object;\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({ node, message: \"unnecessary '.{{name}}()'.\", data: { name: node.callee.property.name } });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-computed-key.js":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\nconst esUtils = require(\"esutils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst MESSAGE_UNNECESSARY_COMPUTED = \"Unnecessarily computed property [{{property}}] found.\";\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary computed property keys in object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            Property(node) {\n                if (!node.computed) {\n                    return;\n                }\n\n                const key = node.key,\n                    nodeType = typeof key.value;\n\n                if (key.type === \"Literal\" && (nodeType === \"string\" || nodeType === \"number\") && key.value !== \"__proto__\") {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY_COMPUTED,\n                        data: { property: sourceCode.getText(key) },\n                        fix(fixer) {\n                            const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);\n                            const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);\n                            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);\n\n                            if (tokensBetween.slice(0, -1).some((token, index) => sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {\n\n                                // If there are comments between the brackets and the property name, don't do a fix.\n                                return null;\n                            }\n\n                            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                            // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                                esUtils.code.isIdentifierPartES6(tokenBeforeLeftBracket.value.slice(-1).charCodeAt(0)) &&\n                                esUtils.code.isIdentifierPartES6(key.raw.charCodeAt(0));\n\n                            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-concat.js":"/**\n * @fileoverview disallow unncessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Checks if the given token is a `+` token or not.\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a `+` token.\n */\nfunction isConcatOperatorToken(token) {\n    return token.value === \"+\" && token.type === \"Punctuator\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    let left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    let right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                const left = getLeft(node);\n                const right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n\n                    context.report({\n                        node,\n                        loc: operatorToken.loc.start,\n                        message: \"Unexpected string concatenation of literals.\"\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-constructor.js":"/**\n * @fileoverview Rule to flag the use of redundant constructors in classes.\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given array of statements is a single call of `super`.\n *\n * @param {ASTNode[]} body - An array of statements to check.\n * @returns {boolean} `true` if the body is a single call of `super`.\n */\nfunction isSingleSuperCall(body) {\n    return (\n        body.length === 1 &&\n        body[0].type === \"ExpressionStatement\" &&\n        body[0].expression.type === \"CallExpression\" &&\n        body[0].expression.callee.type === \"Super\"\n    );\n}\n\n/**\n * Checks whether a given node is a pattern which doesn't have any side effects.\n * Default parameters and Destructuring parameters can have side effects.\n *\n * @param {ASTNode} node - A pattern node.\n * @returns {boolean} `true` if the node doesn't have any side effects.\n */\nfunction isSimple(node) {\n    return node.type === \"Identifier\" || node.type === \"RestElement\";\n}\n\n/**\n * Checks whether a given array of expressions is `...arguments` or not.\n * `super(...arguments)` passes all arguments through.\n *\n * @param {ASTNode[]} superArgs - An array of expressions to check.\n * @returns {boolean} `true` if the superArgs is `...arguments`.\n */\nfunction isSpreadArguments(superArgs) {\n    return (\n        superArgs.length === 1 &&\n        superArgs[0].type === \"SpreadElement\" &&\n        superArgs[0].argument.type === \"Identifier\" &&\n        superArgs[0].argument.name === \"arguments\"\n    );\n}\n\n/**\n * Checks whether given 2 nodes are identifiers which have the same name or not.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes are identifiers which have the same\n *      name.\n */\nfunction isValidIdentifierPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"Identifier\" &&\n        superArg.type === \"Identifier\" &&\n        ctorParam.name === superArg.name\n    );\n}\n\n/**\n * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n *      same values.\n */\nfunction isValidRestSpreadPair(ctorParam, superArg) {\n    return (\n        ctorParam.type === \"RestElement\" &&\n        superArg.type === \"SpreadElement\" &&\n        isValidIdentifierPair(ctorParam.argument, superArg.argument)\n    );\n}\n\n/**\n * Checks whether given 2 nodes have the same value or not.\n *\n * @param {ASTNode} ctorParam - A node to check.\n * @param {ASTNode} superArg - A node to check.\n * @returns {boolean} `true` if the nodes have the same value or not.\n */\nfunction isValidPair(ctorParam, superArg) {\n    return (\n        isValidIdentifierPair(ctorParam, superArg) ||\n        isValidRestSpreadPair(ctorParam, superArg)\n    );\n}\n\n/**\n * Checks whether the parameters of a constructor and the arguments of `super()`\n * have the same values or not.\n *\n * @param {ASTNode} ctorParams - The parameters of a constructor to check.\n * @param {ASTNode} superArgs - The arguments of `super()` to check.\n * @returns {boolean} `true` if those have the same values.\n */\nfunction isPassingThrough(ctorParams, superArgs) {\n    if (ctorParams.length !== superArgs.length) {\n        return false;\n    }\n\n    for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether the constructor body is a redundant super call.\n *\n * @param {Array} body - constructor body content.\n * @param {Array} ctorParams - The params to check against super call.\n * @returns {boolean} true if the construtor body is redundant\n */\nfunction isRedundantSuperCall(body, ctorParams) {\n    return (\n        isSingleSuperCall(body) &&\n        ctorParams.every(isSimple) &&\n        (\n            isSpreadArguments(body[0].expression.arguments) ||\n            isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary constructors\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Checks whether a node is a redundant constructor\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkForConstructor(node) {\n            if (node.kind !== \"constructor\") {\n                return;\n            }\n\n            const body = node.value.body.body;\n            const ctorParams = node.value.params;\n            const superClass = node.parent.parent.superClass;\n\n            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {\n                context.report({\n                    node,\n                    message: \"Useless constructor.\"\n                });\n            }\n        }\n\n        return {\n            MethodDefinition: checkForConstructor\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-escape.js":"/**\n * @fileoverview Look for useless escapes in strings and regexes\n * @author Onur Temizkan\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n* Returns the union of two sets.\n* @param {Set} setA The first set\n* @param {Set} setB The second set\n* @returns {Set} The union of the two sets\n*/\nfunction union(setA, setB) {\n    return new Set(function *() {\n        yield* setA;\n        yield* setB;\n    }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()B\"));\n\n/**\n* Parses a regular expression into a list of characters with character class info.\n* @param {string} regExpText The raw text used to create the regular expression\n* @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\n* @example\n*\n* parseRegExp('a\\\\b[cd-]')\n*\n* returns:\n* [\n*   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},\n*   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},\n*   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},\n*   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},\n*   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}\n* ]\n*/\nfunction parseRegExp(regExpText) {\n    const charList = [];\n\n    regExpText.split(\"\").reduce((state, char, index) => {\n        if (!state.escapeNextChar) {\n            if (char === \"\\\\\") {\n                return Object.assign(state, { escapeNextChar: true });\n            }\n            if (char === \"[\" && !state.inCharClass) {\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\n            }\n            if (char === \"]\" && state.inCharClass) {\n                if (charList.length && charList[charList.length - 1].inCharClass) {\n                    charList[charList.length - 1].endsCharClass = true;\n                }\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\n            }\n        }\n        charList.push({ text: char, index, escaped: state.escapeNextChar, inCharClass: state.inCharClass, startsCharClass: state.startingCharClass, endsCharClass: false });\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\n\n    return charList;\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary escape characters\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a node\n         * @param {ASTNode} node The node to report\n         * @param {number} startOffset The backslash's offset from the start of the node\n         * @param {string} character The uselessly escaped character (not including the backslash)\n         * @returns {void}\n         */\n        function report(node, startOffset, character) {\n            context.report({\n                node,\n                loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),\n                message: \"Unnecessary escape character: \\\\{{character}}.\",\n                data: { character }\n            });\n        }\n\n        /**\n         * Checks if the escape character in given string slice is unnecessary.\n         *\n         * @private\n         * @param {ASTNode} node - node to validate.\n         * @param {string} match - string slice to validate.\n         * @returns {void}\n         */\n        function validateString(node, match) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n            const escapedChar = match[0][1];\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n            let isQuoteEscape;\n\n            if (isTemplateElement) {\n                isQuoteEscape = escapedChar === \"`\";\n\n                if (escapedChar === \"$\") {\n\n                    // Warn if `\\$` is not followed by `{`\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n                } else if (escapedChar === \"{\") {\n\n                    /* Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\n                     */\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n                }\n            } else {\n                isQuoteEscape = escapedChar === node.raw[0];\n            }\n\n            if (isUnnecessaryEscape && !isQuoteEscape) {\n                report(node, match.index + 1, match[0].slice(1));\n            }\n        }\n\n        /**\n         * Checks if a node has an escape.\n         *\n         * @param {ASTNode} node - node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            const isTemplateElement = node.type === \"TemplateElement\";\n\n            if (\n                isTemplateElement &&\n                node.parent &&\n                node.parent.parent &&\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\n                node.parent === node.parent.parent.quasi\n            ) {\n\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n                return;\n            }\n\n            if (typeof node.value === \"string\" || isTemplateElement) {\n\n                /*\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\n                 */\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\") {\n                    return;\n                }\n\n                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);\n                const pattern = /\\\\[^\\d]/g;\n                let match;\n\n                while ((match = pattern.exec(value))) {\n                    validateString(node, match);\n                }\n            } else if (node.regex) {\n                parseRegExp(node.regex.pattern)\n\n                    /*\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\n                     * character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n\n                    /*\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\n                     * out '^' characters that appear at the start of a character class.\n                     */\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\n\n                    // Filter out characters that aren't escaped.\n                    .filter(charInfo => charInfo.escaped)\n\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\n\n                    // Report all the remaining characters.\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n            }\n\n        }\n\n        return {\n            Literal: check,\n            TemplateElement: check\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-rename.js":"/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow renaming import, export, and destructured assignments to the same name\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: { type: \"boolean\" },\n                    ignoreImport: { type: \"boolean\" },\n                    ignoreExport: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            ignoreDestructuring = options.ignoreDestructuring === true,\n            ignoreImport = options.ignoreImport === true,\n            ignoreExport = options.ignoreExport === true;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports error for unnecessarily renamed assignments\n         * @param {ASTNode} node - node to report\n         * @param {ASTNode} initial - node with initial name value\n         * @param {ASTNode} result - node with new name value\n         * @param {string} type - the type of the offending node\n         * @returns {void}\n         */\n        function reportError(node, initial, result, type) {\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n\n            return context.report({\n                node,\n                message: \"{{type}} {{name}} unnecessarily renamed.\",\n                data: {\n                    name,\n                    type\n                },\n                fix(fixer) {\n                    return fixer.replaceTextRange([\n                        initial.range[0],\n                        result.range[1]\n                    ], name);\n                }\n            });\n        }\n\n        /**\n         * Checks whether a destructured assignment is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkDestructured(node) {\n            if (ignoreDestructuring) {\n                return;\n            }\n\n            const properties = node.properties;\n\n            for (let i = 0; i < properties.length; i++) {\n                if (properties[i].shorthand) {\n                    continue;\n                }\n\n                /**\n                 * If an ObjectPattern property is computed, we have no idea\n                 * if a rename is useless or not. If an ObjectPattern property\n                 * lacks a key, it is likely an ExperimentalRestProperty and\n                 * so there is no \"renaming\" occurring here.\n                 */\n                if (properties[i].computed || !properties[i].key) {\n                    continue;\n                }\n\n                if (properties[i].key.type === \"Identifier\" && properties[i].key.name === properties[i].value.name ||\n                        properties[i].key.type === \"Literal\" && properties[i].key.value === properties[i].value.name) {\n                    reportError(properties[i], properties[i].key, properties[i].value, \"Destructuring assignment\");\n                }\n            }\n        }\n\n        /**\n         * Checks whether an import is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkImport(node) {\n            if (ignoreImport) {\n                return;\n            }\n\n            if (node.imported.name === node.local.name &&\n                    node.imported.range[0] !== node.local.range[0]) {\n                reportError(node, node.imported, node.local, \"Import\");\n            }\n        }\n\n        /**\n         * Checks whether an export is unnecessarily renamed\n         * @param {ASTNode} node - node to check\n         * @returns {void}\n         */\n        function checkExport(node) {\n            if (ignoreExport) {\n                return;\n            }\n\n            if (node.local.name === node.exported.name &&\n                    node.local.range[0] !== node.exported.range[0]) {\n                reportError(node, node.local, node.exported, \"Export\");\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ObjectPattern: checkDestructured,\n            ImportSpecifier: checkImport,\n            ExportSpecifier: checkExport\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-useless-return.js":"/**\n * @fileoverview Disallow redundant return statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\"),\n    FixTracker = require(\"../util/fix-tracker\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds all elements of 2nd argument into 1st argument.\n *\n * @param {Array} array - The destination array to add.\n * @param {Array} elements - The source array to add.\n * @returns {void}\n */\nconst pushAll = Function.apply.bind(Array.prototype.push);\n\n/**\n * Removes the given element from the array.\n *\n * @param {Array} array - The source array to remove.\n * @param {any} element - The target item to remove.\n * @returns {void}\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n\n    if (index !== -1) {\n        array.splice(index, 1);\n    }\n}\n\n/**\n * Checks whether it can remove the given return statement or not.\n *\n * @param {ASTNode} node - The return statement node to check.\n * @returns {boolean} `true` if the node is removeable.\n */\nfunction isRemovable(node) {\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n\n/**\n * Checks whether the given return statement is in a `finally` block or not.\n *\n * @param {ASTNode} node - The return statement node to check.\n * @returns {boolean} `true` if the node is in a `finally` block.\n */\nfunction isInFinally(node) {\n    while (node && node.parent && !astUtils.isFunction(node)) {\n        if (node.parent.type === \"TryStatement\" && node.parent.finalizer === node) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow redundant return statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        fixable: \"code\",\n        schema: []\n    },\n\n    create(context) {\n        const segmentInfoMap = new WeakMap();\n        const usedUnreachableSegments = new WeakSet();\n        let scopeInfo = null;\n\n        /**\n         * Checks whether the given segment is terminated by a return statement or not.\n         *\n         * @param {CodePathSegment} segment - The segment to check.\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\n         */\n        function isReturned(segment) {\n            const info = segmentInfoMap.get(segment);\n\n            return !info || info.returned;\n        }\n\n        /**\n         * Collects useless return statements from the given previous segments.\n         *\n         * A previous segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         *\n         * @param {ASTNode[]} uselessReturns - The collected return statements.\n         * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.\n         * @param {WeakSet<CodePathSegment>} [traversedSegments] A set of segments that have already been traversed in this call\n         * @returns {ASTNode[]} `uselessReturns`.\n         */\n        function getUselessReturns(uselessReturns, prevSegments, traversedSegments) {\n            if (!traversedSegments) {\n                traversedSegments = new WeakSet();\n            }\n            for (const segment of prevSegments) {\n                if (!segment.reachable) {\n                    if (!traversedSegments.has(segment)) {\n                        traversedSegments.add(segment);\n                        getUselessReturns(\n                            uselessReturns,\n                            segment.allPrevSegments.filter(isReturned),\n                            traversedSegments\n                        );\n                    }\n                    continue;\n                }\n\n                pushAll(uselessReturns, segmentInfoMap.get(segment).uselessReturns);\n            }\n\n            return uselessReturns;\n        }\n\n        /**\n         * Removes the return statements on the given segment from the useless return\n         * statement list.\n         *\n         * This segment may be an unreachable segment.\n         * In that case, the information object of the unreachable segment is not\n         * initialized because `onCodePathSegmentStart` event is not notified for\n         * unreachable segments.\n         * This goes to the previous segments of the unreachable segment recursively\n         * if the unreachable segment was generated by a return statement. Otherwise,\n         * this ignores the unreachable segment.\n         *\n         * This behavior would simulate code paths for the case that the return\n         * statement does not exist.\n         *\n         * @param {CodePathSegment} segment - The segment to get return statements.\n         * @returns {void}\n         */\n        function markReturnStatementsOnSegmentAsUsed(segment) {\n            if (!segment.reachable) {\n                usedUnreachableSegments.add(segment);\n                segment.allPrevSegments\n                    .filter(isReturned)\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\n                return;\n            }\n\n            const info = segmentInfoMap.get(segment);\n\n            for (const node of info.uselessReturns) {\n                remove(scopeInfo.uselessReturns, node);\n            }\n            info.uselessReturns = [];\n        }\n\n        /**\n         * Removes the return statements on the current segments from the useless\n         * return statement list.\n         *\n         * This function will be called at every statement except FunctionDeclaration,\n         * BlockStatement, and BreakStatement.\n         *\n         * - FunctionDeclarations are always executed whether it's returned or not.\n         * - BlockStatements do nothing.\n         * - BreakStatements go the next merely.\n         *\n         * @returns {void}\n         */\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\n            scopeInfo\n                .codePath\n                .currentSegments\n                .forEach(markReturnStatementsOnSegmentAsUsed);\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Makes and pushs a new scope information.\n            onCodePathStart(codePath) {\n                scopeInfo = {\n                    upper: scopeInfo,\n                    uselessReturns: [],\n                    codePath\n                };\n            },\n\n            // Reports useless return statements if exist.\n            onCodePathEnd() {\n                for (const node of scopeInfo.uselessReturns) {\n                    context.report({\n                        node,\n                        loc: node.loc,\n                        message: \"Unnecessary return statement.\",\n                        fix(fixer) {\n                            if (isRemovable(node)) {\n\n                                // Extend the replacement range to include the\n                                // entire function to avoid conflicting with\n                                // no-else-return.\n                                // https://github.com/eslint/eslint/issues/8026\n                                return new FixTracker(fixer, context.getSourceCode())\n                                    .retainEnclosingFunction(node)\n                                    .remove(node);\n                            }\n                            return null;\n                        }\n                    });\n                }\n\n                scopeInfo = scopeInfo.upper;\n            },\n\n            // Initializes segments.\n            // NOTE: This event is notified for only reachable segments.\n            onCodePathSegmentStart(segment) {\n                const info = {\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\n                    returned: false\n                };\n\n                // Stores the info.\n                segmentInfoMap.set(segment, info);\n            },\n\n            // Adds ReturnStatement node to check whether it's useless or not.\n            ReturnStatement(node) {\n                if (node.argument) {\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\n                }\n                if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {\n                    return;\n                }\n\n                for (const segment of scopeInfo.codePath.currentSegments) {\n                    const info = segmentInfoMap.get(segment);\n\n                    if (info) {\n                        info.uselessReturns.push(node);\n                        info.returned = true;\n                    }\n                }\n                scopeInfo.uselessReturns.push(node);\n            },\n\n            // Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\n            // Removes return statements of the current segments from the useless return statement list.\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-var.js":"/**\n * @fileoverview Rule to check for the usage of var.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Finds the nearest function scope or global scope walking up the scope\n * hierarchy.\n *\n * @param {escope.Scope} scope - The scope to traverse.\n * @returns {escope.Scope} a function scope or global scope containing the given\n *      scope.\n */\nfunction getEnclosingFunctionScope(scope) {\n    while (scope.type !== \"function\" && scope.type !== \"global\") {\n        scope = scope.upper;\n    }\n    return scope;\n}\n\n/**\n * Checks whether the given variable has any references from a more specific\n * function expression (i.e. a closure).\n *\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is used from a closure.\n */\nfunction isReferencedInClosure(variable) {\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n\n    return variable.references.some(reference =>\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n\n/**\n * Checks whether the given node is the assignee of a loop.\n *\n * @param {ASTNode} node - A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration is assigned as part of loop\n *      iteration.\n */\nfunction isLoopAssignee(node) {\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\n        node === node.parent.left;\n}\n\n/**\n * Checks whether the given variable declaration is immediately initialized.\n *\n * @param {ASTNode} node - A VariableDeclaration node to check.\n * @returns {boolean} `true` if the declaration has an initializer.\n */\nfunction isDeclarationInitialized(node) {\n    return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;\n\n/**\n * Gets the scope node which directly contains a given node.\n *\n * @param {ASTNode} node - A node to get. This is a `VariableDeclaration` or\n *      an `Identifier`.\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\n *      `ForOfStatement`.\n */\nfunction getScopeNode(node) {\n    while (node) {\n        if (SCOPE_NODE_TYPE.test(node.type)) {\n            return node;\n        }\n\n        node = node.parent;\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks whether a given variable is redeclared or not.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is redeclared.\n */\nfunction isRedeclared(variable) {\n    return variable.defs.length >= 2;\n}\n\n/**\n * Checks whether a given variable is used from outside of the specified scope.\n *\n * @param {ASTNode} scopeNode - A scope node to check.\n * @returns {Function} The predicate function which checks whether a given\n *      variable is used from outside of the specified scope.\n */\nfunction isUsedFromOutsideOf(scopeNode) {\n\n    /**\n     * Checks whether a given reference is inside of the specified scope or not.\n     *\n     * @param {escope.Reference} reference - A reference to check.\n     * @returns {boolean} `true` if the reference is inside of the specified\n     *      scope.\n     */\n    function isOutsideOfScope(reference) {\n        const scope = scopeNode.range;\n        const id = reference.identifier.range;\n\n        return id[0] < scope[0] || id[1] > scope[1];\n    }\n\n    return function(variable) {\n        return variable.references.some(isOutsideOfScope);\n    };\n}\n\n/**\n * Creates the predicate function which checks whether a variable has their references in TDZ.\n *\n * The predicate function would return `true`:\n *\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\n *\n * @param {ASTNode} node - The initializer node of VariableDeclarator.\n * @returns {Function} The predicate function.\n * @private\n */\nfunction hasReferenceInTDZ(node) {\n    const initStart = node.range[0];\n    const initEnd = node.range[1];\n\n    return variable => {\n        const id = variable.defs[0].name;\n        const idStart = id.range[0];\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\n        const defaultStart = defaultValue && defaultValue.range[0];\n        const defaultEnd = defaultValue && defaultValue.range[1];\n\n        return variable.references.some(reference => {\n            const start = reference.identifier.range[0];\n            const end = reference.identifier.range[1];\n\n            return !reference.init && (\n                start < idStart ||\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\n                (start >= initStart && end <= initEnd)\n            );\n        });\n    };\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `let` or `const` instead of `var`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\n         *\n         * @param {ASTNode} declarator - The VariableDeclarator node to check.\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\n         */\n        function hasSelfReferenceInTDZ(declarator) {\n            if (!declarator.init) {\n                return false;\n            }\n            const variables = context.getDeclaredVariables(declarator);\n\n            return variables.some(hasReferenceInTDZ(declarator.init));\n        }\n\n        /**\n         * Checks whether it can fix a given variable declaration or not.\n         * It cannot fix if the following cases:\n         *\n         * - A variable is declared on a SwitchCase node.\n         * - A variable is redeclared.\n         * - A variable is used from outside the scope.\n         * - A variable is used from a closure within a loop.\n         * - A variable might be used before it is assigned within a loop.\n         * - A variable might be used in TDZ.\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\n         *\n         * ## A variable is declared on a SwitchCase node.\n         *\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\n         * would generate the warnings of 'no-case-declarations' rule. And the\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\n         * this rule doesn't modify those declarations.\n         *\n         * ## A variable is redeclared.\n         *\n         * The language spec disallows redeclarations of `let` declarations.\n         * Those variables would cause syntax errors.\n         *\n         * ## A variable is used from outside the scope.\n         *\n         * The language spec disallows accesses from outside of the scope for\n         * `let` declarations. Those variables would cause reference errors.\n         *\n         * ## A variable is used from a closure within a loop.\n         *\n         * A `var` declaration within a loop shares the same variable instance\n         * across all loop iterations, while a `let` declaration creates a new\n         * instance for each iteration. This means if a variable in a loop is\n         * referenced by any closure, changing it from `var` to `let` would\n         * change the behavior in a way that is generally unsafe.\n         *\n         * ## A variable might be used before it is assigned within a loop.\n         *\n         * Within a loop, a `let` declaration without an initializer will be\n         * initialized to null, while a `var` declaration will retain its value\n         * from the previous iteration, so it is only safe to change `var` to\n         * `let` if we can statically determine that the variable is always\n         * assigned a value before its first access in the loop body. To keep\n         * the implementation simple, we only convert `var` to `let` within\n         * loops when the variable is a loop assignee or the declaration has an\n         * initializer.\n         *\n         * @param {ASTNode} node - A variable declaration node to check.\n         * @returns {boolean} `true` if it can fix the node.\n         */\n        function canFix(node) {\n            const variables = context.getDeclaredVariables(node);\n            const scopeNode = getScopeNode(node);\n\n            if (node.parent.type === \"SwitchCase\" ||\n                node.declarations.some(hasSelfReferenceInTDZ) ||\n                variables.some(isRedeclared) ||\n                variables.some(isUsedFromOutsideOf(scopeNode))\n            ) {\n                return false;\n            }\n\n            if (astUtils.isInLoop(node)) {\n                if (variables.some(isReferencedInClosure)) {\n                    return false;\n                }\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n                    return false;\n                }\n            }\n\n            if (\n                !isLoopAssignee(node) &&\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\n            ) {\n\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Reports a given variable declaration node.\n         *\n         * @param {ASTNode} node - A variable declaration node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            const varToken = sourceCode.getFirstToken(node);\n\n            context.report({\n                node,\n                message: \"Unexpected var, use let or const instead.\",\n\n                fix(fixer) {\n                    if (canFix(node)) {\n                        return fixer.replaceText(varToken, \"let\");\n                    }\n                    return null;\n                }\n            });\n        }\n\n        return {\n            \"VariableDeclaration:exit\"(node) {\n                if (node.kind === \"var\") {\n                    report(node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-void.js":"/**\n * @fileoverview Rule to disallow use of void operator.\n * @author Mike Sidorov\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `void` operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression(node) {\n                if (node.operator === \"void\") {\n                    context.report({ node, message: \"Expected 'undefined' and instead saw 'void'.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-warning-comments.js":"/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         *\n         * @param {string} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            const escaped = term.replace(/[-/\\\\$^*+?.()|[\\]{}]/g, \"\\\\$&\");\n            let prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            const suffix = /\\w$/.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/.test(term)) {\n                prefix = \"\\\\b\";\n            } else {\n                prefix = \"\";\n            }\n\n            return new RegExp(prefix + escaped + suffix, \"i\");\n        }\n\n        const warningRegExps = warningTerms.map(convertToRegExp);\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {string} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            const matches = [];\n\n            warningRegExps.forEach((regex, index) => {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n                return;\n            }\n\n            const matches = commentContainsWarningTerm(node.value);\n\n            matches.forEach(matchedTerm => {\n                context.report({\n                    node,\n                    message: \"Unexpected '{{matchedTerm}}' comment.\",\n                    data: {\n                        matchedTerm\n                    }\n                });\n            });\n        }\n\n        return {\n            BlockComment: checkComment,\n            LineComment: checkComment\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-whitespace-before-property.js":"/**\n * @fileoverview Rule to disallow whitespace before properties\n * @author Kai Cataldo\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow whitespace before properties\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports whitespace before property token\n         * @param {ASTNode} node - the node to report in the event of an error\n         * @param {Token} leftToken - the left token\n         * @param {Token} rightToken - the right token\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, leftToken, rightToken) {\n            const replacementText = node.computed ? \"\" : \".\";\n\n            context.report({\n                node,\n                message: \"Unexpected whitespace before property {{propName}}.\",\n                data: {\n                    propName: sourceCode.getText(node.property)\n                },\n                fix(fixer) {\n                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {\n\n                        // If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.\n                        // Don't fix this case.\n                        return null;\n                    }\n                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            MemberExpression(node) {\n                let rightToken;\n                let leftToken;\n\n                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {\n                    return;\n                }\n\n                if (node.computed) {\n                    rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);\n                    leftToken = sourceCode.getTokenBefore(rightToken);\n                } else {\n                    rightToken = sourceCode.getFirstToken(node.property);\n                    leftToken = sourceCode.getTokenBefore(rightToken, 1);\n                }\n\n                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {\n                    reportError(node, leftToken, rightToken);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/no-with.js":"/**\n * @fileoverview Rule to flag use of with statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `with` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            WithStatement(node) {\n                context.report({ node, message: \"Unexpected use of 'with' statement.\" });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/nonblock-statement-body-position.js":"/**\n * @fileoverview enforce the location of single-line statements\n * @author Teddy Katz\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst POSITION_SCHEMA = { enum: [\"beside\", \"below\", \"any\"] };\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the location of single-line statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            POSITION_SCHEMA,\n            {\n                properties: {\n                    overrides: {\n                        properties: {\n                            if: POSITION_SCHEMA,\n                            else: POSITION_SCHEMA,\n                            while: POSITION_SCHEMA,\n                            do: POSITION_SCHEMA,\n                            for: POSITION_SCHEMA\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n         * Gets the applicable preference for a particular keyword\n         * @param {string} keywordName The name of a keyword, e.g. 'if'\n         * @returns {string} The applicable option for the keyword, e.g. 'beside'\n         */\n        function getOption(keywordName) {\n            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||\n                context.options[0] ||\n                \"beside\";\n        }\n\n        /**\n         * Validates the location of a single-line statement\n         * @param {ASTNode} node The single-line statement\n         * @param {string} keywordName The applicable keyword name for the single-line statement\n         * @returns {void}\n         */\n        function validateStatement(node, keywordName) {\n            const option = getOption(keywordName);\n\n            if (node.type === \"BlockStatement\" || option === \"any\") {\n                return;\n            }\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (tokenBefore.loc.end.line === node.loc.start.line && option === \"below\") {\n                context.report({\n                    node,\n                    message: \"Expected a linebreak before this statement.\",\n                    fix: fixer => fixer.insertTextBefore(node, \"\\n\")\n                });\n            } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === \"beside\") {\n                context.report({\n                    node,\n                    message: \"Expected no linebreak before this statement.\",\n                    fix(fixer) {\n                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {\n                            return null;\n                        }\n                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n            IfStatement(node) {\n                validateStatement(node.consequent, \"if\");\n\n                // Check the `else` node, but don't check 'else if' statements.\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    validateStatement(node.alternate, \"else\");\n                }\n            },\n            WhileStatement: node => validateStatement(node.body, \"while\"),\n            DoWhileStatement: node => validateStatement(node.body, \"do\"),\n            ForStatement: node => validateStatement(node.body, \"for\"),\n            ForInStatement: node => validateStatement(node.body, \"for\"),\n            ForOfStatement: node => validateStatement(node.body, \"for\")\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/object-curly-newline.js":"/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n *\n * @param {string|Object|undefined} value - An option value to parse.\n * @returns {{multiline: boolean, minProperties: number}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n        }\n    } else {\n        multiline = true;\n    }\n\n    return { multiline, minProperties };\n}\n\n/**\n * Normalizes a given option value.\n *\n * @param {string|Object|undefined} options - An option value to parse.\n * @returns {{ObjectExpression: {multiline: boolean, minProperties: number}, ObjectPattern: {multiline: boolean, minProperties: number}}} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    if (options && (options.ObjectExpression || options.ObjectPattern)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value };\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent line breaks inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         *\n         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.\n         * @param {{multiline: boolean, minProperties: number}} options - An option object.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n            const openBrace = sourceCode.getFirstToken(node);\n            const closeBrace = sourceCode.getLastToken(node);\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n            const needsLinebreaks = (\n                node.properties.length >= options.minProperties ||\n                (\n                    options.multiline &&\n                    node.properties.length > 0 &&\n                    first.loc.start.line !== last.loc.end.line\n                )\n            );\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLinebreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        message: \"Expected a line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        message: \"Expected a line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                if (!astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        message: \"Unexpected line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (!astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        message: \"Unexpected line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/object-curly-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside of object literals.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    arraysInObjects: {\n                        type: \"boolean\"\n                    },\n                    objectsInObjects: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option - The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n            objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Reports that there shouldn't be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    const nextToken = context.getSourceCode().getTokenAfter(token);\n\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there shouldn't be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportNoEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"There should be no space before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    const previousToken = context.getSourceCode().getTokenBefore(token);\n\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space after the first token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n        * Reports that there should be a space before the last token\n        * @param {ASTNode} node - The node to report in the event of an error.\n        * @param {Token} token - The token to use for the report.\n        * @returns {void}\n        */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc.start,\n                message: \"A space is required before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if spacing in curly braces is valid.\n         * @param {ASTNode} node The AST node to check.\n         * @param {Token} first The first token to check (should be the opening brace)\n         * @param {Token} second The second token to check (should be first after the opening brace)\n         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)\n         * @param {Token} last The last token to check (should be closing brace)\n         * @returns {void}\n         */\n        function validateBraceSpacing(node, first, second, penultimate, last) {\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);\n\n                if (options.spaced && !firstSpaced) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!options.spaced && firstSpaced) {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (astUtils.isTokenOnSameLine(penultimate, last)) {\n                const shouldCheckPenultimate = (\n                    options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) ||\n                    options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate)\n                );\n                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.start).type;\n\n                const closingCurlyBraceMustBeSpaced = (\n                    options.arraysInObjectsException && penultimateType === \"ArrayExpression\" ||\n                    options.objectsInObjectsException && (penultimateType === \"ObjectExpression\" || penultimateType === \"ObjectPattern\")\n                ) ? !options.spaced : options.spaced;\n\n                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);\n\n                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        /**\n         * Gets '}' token of an object node.\n         *\n         * Because the last token of object patterns might be a type annotation,\n         * this traverses tokens preceded by the last property, then returns the\n         * first '}' token.\n         *\n         * @param {ASTNode} node - The node to get. This node is an\n         *      ObjectExpression or an ObjectPattern. And this node has one or\n         *      more properties.\n         * @returns {Token} '}' token.\n         */\n        function getClosingBraceOfObject(node) {\n            const lastProperty = node.properties[node.properties.length - 1];\n\n            return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);\n        }\n\n        /**\n         * Reports a given object node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.\n         * @returns {void}\n         */\n        function checkForObject(node) {\n            if (node.properties.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                last = getClosingBraceOfObject(node),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given import node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ImportDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForImport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            let firstSpecifier = node.specifiers[0];\n            const lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n            if (lastSpecifier.type !== \"ImportSpecifier\") {\n                return;\n            }\n            if (firstSpecifier.type !== \"ImportSpecifier\") {\n                firstSpecifier = node.specifiers[1];\n            }\n\n            const first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given export node if spacing in curly braces is invalid.\n         * @param {ASTNode} node - An ExportNamedDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForExport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            const firstSpecifier = node.specifiers[0],\n                lastSpecifier = node.specifiers[node.specifiers.length - 1],\n                first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first),\n                penultimate = sourceCode.getTokenBefore(last);\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // var {x} = y;\n            ObjectPattern: checkForObject,\n\n            // var y = {x: 'y'}\n            ObjectExpression: checkForObject,\n\n            // import {y} from 'x';\n            ImportDeclaration: checkForImport,\n\n            // export {name} from 'yo';\n            ExportNamedDeclaration: checkForExport\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/object-property-newline.js":"/**\n * @fileoverview Rule to enforce placing object properties on separate lines.\n * @author Vitor Balocco\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce placing object properties on separate lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowMultiplePropertiesPerLine: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const allowSameLine = context.options[0] && Boolean(context.options[0].allowMultiplePropertiesPerLine);\n        const errorMessage = allowSameLine\n            ? \"Object properties must go on a new line if they aren't all on the same line.\"\n            : \"Object properties must go on a new line.\";\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            ObjectExpression(node) {\n                if (allowSameLine) {\n                    if (node.properties.length > 1) {\n                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);\n                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);\n\n                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {\n\n                            // All keys and values are on the same line\n                            return;\n                        }\n                    }\n                }\n\n                for (let i = 1; i < node.properties.length; i++) {\n                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);\n                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);\n\n                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {\n                        context.report({\n                            node,\n                            loc: firstTokenOfCurrentProperty.loc.start,\n                            message: errorMessage,\n                            fix(fixer) {\n                                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);\n                                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];\n\n                                // Don't perform a fix if there are any comments between the comma and the next property.\n                                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(rangeAfterComma, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/object-shorthand.js":"/**\n * @fileoverview Rule to enforce concise object methods and properties.\n * @author Jamund Ferguson\n */\n\n\"use strict\";\n\nconst OPTIONS = {\n    always: \"always\",\n    never: \"never\",\n    methods: \"methods\",\n    properties: \"properties\",\n    consistent: \"consistent\",\n    consistentAsNeeded: \"consistent-as-needed\"\n};\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow method and property shorthand syntax for object literals\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\", \"properties\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"methods\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                ignoreConstructors: {\n                                    type: \"boolean\"\n                                },\n                                avoidQuotes: {\n                                    type: \"boolean\"\n                                },\n                                avoidExplicitReturnArrows: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const APPLY = context.options[0] || OPTIONS.always;\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n        const APPLY_NEVER = APPLY === OPTIONS.never;\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n\n        const PARAMS = context.options[1] || {};\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if the first character of the name is a capital letter.\n         * @param {string} name The name of the node to evaluate.\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\n         * @private\n         */\n        function isConstructor(name) {\n            const firstChar = name.charAt(0);\n\n            return firstChar === firstChar.toUpperCase();\n        }\n\n        /**\n         * Determines if the property can have a shorthand form.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property can have a shorthand form\n         * @private\n         **/\n        function canHaveShorthand(property) {\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\n        }\n\n        /**\n          * Checks whether a node is a string literal.\n          * @param   {ASTNode} node - Any AST node.\n          * @returns {boolean} `true` if it is a string literal.\n          */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        /**\n         * Determines if the property is a shorthand or not.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the property is considered shorthand, false if not.\n         * @private\n         **/\n        function isShorthand(property) {\n\n            // property.method is true when `{a(){}}`.\n            return (property.shorthand || property.method);\n        }\n\n        /**\n         * Determines if the property's key and method or value are named equally.\n         * @param {ASTNode} property Property AST node\n         * @returns {boolean} True if the key and value are named equally, false if not.\n         * @private\n         **/\n        function isRedundant(property) {\n            const value = property.value;\n\n            if (value.type === \"FunctionExpression\") {\n                return !value.id; // Only anonymous should be shorthand method.\n            }\n            if (value.type === \"Identifier\") {\n                return astUtils.getStaticPropertyName(property) === value.name;\n            }\n\n            return false;\n        }\n\n        /**\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkRedundancy Whether to check longform redundancy\n         * @returns {void}\n         **/\n        function checkConsistency(node, checkRedundancy) {\n\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n            const properties = node.properties.filter(canHaveShorthand);\n\n            // Do we still have properties left after filtering the getters and setters?\n            if (properties.length > 0) {\n                const shorthandProperties = properties.filter(isShorthand);\n\n                // If we do not have an equal number of longform properties as\n                // shorthand properties, we are using the annotations inconsistently\n                if (shorthandProperties.length !== properties.length) {\n\n                    // We have at least 1 shorthand property\n                    if (shorthandProperties.length > 0) {\n                        context.report({ node, message: \"Unexpected mix of shorthand and non-shorthand properties.\" });\n                    } else if (checkRedundancy) {\n\n                        // If all properties of the object contain a method or value with a name matching it's key,\n                        // all the keys are redundant.\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\n\n                        if (canAlwaysUseShorthand) {\n                            context.report({ node, message: \"Expected shorthand for all properties.\" });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n        * Fixes a FunctionExpression node by making it into a shorthand property.\n        * @param {SourceCodeFixer} fixer The fixer object\n        * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\n        * @returns {Object} A fix for this node\n        */\n        function makeFunctionShorthand(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let keyPrefix = \"\";\n\n            if (node.value.generator) {\n                keyPrefix = \"*\";\n            } else if (node.value.async) {\n                keyPrefix = \"async \";\n            }\n\n            if (node.value.type === \"FunctionExpression\") {\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n\n                return fixer.replaceTextRange(\n                    [firstKeyToken.range[0], node.range[1]],\n                    keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\n                );\n            }\n            const arrowToken = sourceCode.getTokens(node.value).find(token => token.value === \"=>\");\n            const tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);\n            const hasParensAroundParameters = tokenBeforeArrow.type === \"Punctuator\" && tokenBeforeArrow.value === \")\";\n            const oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);\n            const newParamText = hasParensAroundParameters ? oldParamText : `(${oldParamText})`;\n\n            return fixer.replaceTextRange(\n                [firstKeyToken.range[0], node.range[1]],\n                keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1])\n            );\n\n        }\n\n        /**\n        * Fixes a FunctionExpression node by making it into a longform property.\n        * @param {SourceCodeFixer} fixer The fixer object\n        * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\n        * @returns {Object} A fix for this node\n        */\n        function makeFunctionLongform(fixer, node) {\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n            let functionHeader = \"function\";\n\n            if (node.value.generator) {\n                functionHeader = \"function*\";\n            } else if (node.value.async) {\n                functionHeader = \"async function\";\n            }\n\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n        }\n\n        /*\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\n         * because converting it into a method would change the value of one of the lexical identifiers.\n         */\n        const lexicalScopeStack = [];\n        const arrowsWithLexicalIdentifiers = new WeakSet();\n        const argumentsIdentifiers = new WeakSet();\n\n        /**\n        * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\n        * Also, this marks all `arguments` identifiers so that they can be detected later.\n        * @returns {void}\n        */\n        function enterFunction() {\n            lexicalScopeStack.unshift(new Set());\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n            });\n        }\n\n        /**\n        * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\n        * @returns {void}\n        */\n        function exitFunction() {\n            lexicalScopeStack.shift();\n        }\n\n        /**\n        * Marks the current function as having a lexical keyword. This implies that all arrow functions\n        * in the current lexical scope contain a reference to this lexical keyword.\n        * @returns {void}\n        */\n        function reportLexicalIdentifier() {\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: enterFunction,\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            \"Program:exit\": exitFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            ArrowFunctionExpression(node) {\n                lexicalScopeStack[0].add(node);\n            },\n            \"ArrowFunctionExpression:exit\"(node) {\n                lexicalScopeStack[0].delete(node);\n            },\n\n            ThisExpression: reportLexicalIdentifier,\n            Super: reportLexicalIdentifier,\n            MetaProperty(node) {\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\n                    reportLexicalIdentifier();\n                }\n            },\n            Identifier(node) {\n                if (argumentsIdentifiers.has(node)) {\n                    reportLexicalIdentifier();\n                }\n            },\n\n            ObjectExpression(node) {\n                if (APPLY_CONSISTENT) {\n                    checkConsistency(node, false);\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\n                    checkConsistency(node, true);\n                }\n            },\n\n            \"Property:exit\"(node) {\n                const isConciseProperty = node.method || node.shorthand;\n\n                // Ignore destructuring assignment\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                // getters and setters are ignored\n                if (node.kind === \"get\" || node.kind === \"set\") {\n                    return;\n                }\n\n                // only computed methods can fail the following checks\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                //--------------------------------------------------------------\n                // Checks for property/method shorthand.\n                if (isConciseProperty) {\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n                        const message = APPLY_NEVER ? \"Expected longform method syntax.\" : \"Expected longform method syntax for string literal keys.\";\n\n                        // { x() {} } should be written as { x: function() {} }\n                        context.report({\n                            node,\n                            message,\n                            fix: fixer => makeFunctionLongform(fixer, node)\n                        });\n                    } else if (APPLY_NEVER) {\n\n                        // { x } should be written as { x: x }\n                        context.report({\n                            node,\n                            message: \"Expected longform property syntax.\",\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n                        });\n                    }\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n                    if (IGNORE_CONSTRUCTORS && isConstructor(node.key.name)) {\n                        return;\n                    }\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\n                        return;\n                    }\n\n                    // {[x]: function(){}} should be written as {[x]() {}}\n                    if (node.value.type === \"FunctionExpression\" ||\n                        node.value.type === \"ArrowFunctionExpression\" &&\n                        node.value.body.type === \"BlockStatement\" &&\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\n                        !arrowsWithLexicalIdentifiers.has(node.value)\n                    ) {\n                        context.report({\n                            node,\n                            message: \"Expected method shorthand.\",\n                            fix: fixer => makeFunctionShorthand(fixer, node)\n                        });\n                    }\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n\n                    // {x: x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n                    if (AVOID_QUOTES) {\n                        return;\n                    }\n\n                    // {\"x\": x} should be written as {x}\n                    context.report({\n                        node,\n                        message: \"Expected property shorthand.\",\n                        fix(fixer) {\n                            return fixer.replaceText(node, node.value.name);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/one-var-declaration-per-line.js":"/**\n * @fileoverview Rule to check multiple var declarations per line\n * @author Alberto Rodríguez\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow newlines around variable declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"initializations\"]\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n\n        const ERROR_MESSAGE = \"Expected variable declaration to be on a new line.\";\n        const always = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Checks newlines around variable declarations.\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForNewLine(node) {\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            const declarations = node.declarations;\n            let prev;\n\n            declarations.forEach(current => {\n                if (prev && prev.loc.end.line === current.loc.start.line) {\n                    if (always || prev.init || current.init) {\n                        context.report({\n                            node,\n                            message: ERROR_MESSAGE,\n                            loc: current.loc.start,\n                            fix: fixer => fixer.insertTextBefore(current, \"\\n\")\n                        });\n                    }\n                }\n                prev = current;\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForNewLine\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/one-var.js":"/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            var: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        const options = {\n        };\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode };\n            options.let = { uninitialized: mode, initialized: mode };\n            options.const = { uninitialized: mode, initialized: mode };\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            if (mode.hasOwnProperty(\"var\") && typeof mode.var === \"string\") {\n                options.var = { uninitialized: mode.var, initialized: mode.var };\n            }\n            if (mode.hasOwnProperty(\"let\") && typeof mode.let === \"string\") {\n                options.let = { uninitialized: mode.let, initialized: mode.let };\n            }\n            if (mode.hasOwnProperty(\"const\") && typeof mode.const === \"string\") {\n                options.const = { uninitialized: mode.const, initialized: mode.const };\n            }\n            if (mode.hasOwnProperty(\"uninitialized\")) {\n                if (!options.var) {\n                    options.var = {};\n                }\n                if (!options.let) {\n                    options.let = {};\n                }\n                if (!options.const) {\n                    options.const = {};\n                }\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (mode.hasOwnProperty(\"initialized\")) {\n                if (!options.var) {\n                    options.var = {};\n                }\n                if (!options.let) {\n                    options.let = {};\n                }\n                if (!options.const) {\n                    options.const = {};\n                }\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const functionStack = [];\n        const blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: { initialized: false, uninitialized: false },\n                const: { initialized: false, uninitialized: false }\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({ initialized: false, uninitialized: false });\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Records whether initialized or uninitialized variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        currentScope.initialized = true;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            let currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            const counts = { uninitialized: 0, initialized: 0 };\n\n            for (let i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            const declarationCounts = countDeclarations(declarations);\n            const currentOptions = options[statementType] || {};\n            const currentScope = getCurrentScope(statementType);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    return false;\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    return false;\n                }\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n\n            VariableDeclaration(node) {\n                const parent = node.parent;\n                const type = node.kind;\n\n                if (!options[type]) {\n                    return;\n                }\n\n                const declarations = node.declarations;\n                const declarationCounts = countDeclarations(declarations);\n\n                // always\n                if (!hasOnlyOneStatement(type, declarations)) {\n                    if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            message: \"Combine this with the previous '{{type}}' statement.\",\n                            data: {\n                                type\n                            }\n                        });\n                    } else {\n                        if (options[type].initialized === MODE_ALWAYS) {\n                            context.report({\n                                node,\n                                message: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        }\n                        if (options[type].uninitialized === MODE_ALWAYS) {\n                            if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n                                return;\n                            }\n                            context.report({\n                                node,\n                                message: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        }\n                    }\n                }\n\n                // never\n                if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                    const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                    if (totalDeclarations > 1) {\n\n                        if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                            // both initialized and uninitialized\n                            context.report({\n                                node,\n                                message: \"Split '{{type}}' declarations into multiple statements.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                            // initialized\n                            context.report({\n                                node,\n                                message: \"Split initialized '{{type}}' declarations into multiple statements.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                            // uninitialized\n                            context.report({\n                                node,\n                                message: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n                                data: {\n                                    type\n                                }\n                            });\n                        }\n                    }\n                }\n            },\n\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/operator-assignment.js":"/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\":\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return same(a.object, b.object) && same(a.property, b.property);\n\n        default:\n            return false;\n    }\n}\n\n/**\n* Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\n* toString calls regardless of whether assignment shorthand is used)\n* @param {ASTNode} node The node on the left side of the expression\n* @returns {boolean} `true` if the node can be fixed\n*/\nfunction canBeFixed(node) {\n    return node.type === \"Identifier\" ||\n        node.type === \"MemberExpression\" && node.object.type === \"Identifier\" && (!node.computed || node.property.type === \"Literal\");\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow assignment operator shorthand where possible\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n        * Returns the operator token of an AssignmentExpression or BinaryExpression\n        * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\n        * @returns {Token} The operator token in the node\n        */\n        function getOperatorToken(node) {\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        }\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            const left = node.left;\n            const expr = node.right;\n            const operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n                if (same(left, expr.left)) {\n                    context.report({\n                        node,\n                        message: \"Assignment can be replaced with operator assignment.\",\n                        fix(fixer) {\n                            if (canBeFixed(left)) {\n                                const equalsToken = getOperatorToken(node);\n                                const operatorToken = getOperatorToken(expr);\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\n\n                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n                            }\n                            return null;\n                        }\n                    });\n                } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {\n\n                    /*\n                     * This case can't be fixed safely.\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\n                     * change the execution order of the valueOf() functions.\n                     */\n                    context.report({\n                        node,\n                        message: \"Assignment can be replaced with operator assignment.\"\n                    });\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\") {\n                context.report({\n                    node,\n                    message: \"Unexpected operator assignment shorthand.\",\n                    fix(fixer) {\n                        if (canBeFixed(node.left)) {\n                            const operatorToken = getOperatorToken(node);\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n                            const newOperator = node.operator.slice(0, -1);\n                            let rightText;\n\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n                            if (\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\n                                !astUtils.isParenthesised(sourceCode, node.right)\n                            ) {\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n                            } else {\n                                rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);\n                            }\n\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n                        }\n                        return null;\n                    }\n                });\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/operator-linebreak.js":"/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        properties: {\n                            anyOf: {\n                                type: \"string\",\n                                enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                            }\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Gets a fixer function to fix rule issues\n        * @param {Token} operatorToken The operator token of an expression\n        * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n        * @returns {Function} A fixer function\n        */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n\n            // When the left part of a binary expression is a single expression wrapped in\n            // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n            // and operatorToken will be the closing parenthesis.\n            // The leftToken should be the last closing parenthesis, and the operatorToken\n            // should be the token right after that.\n            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operator = operatorToken.value;\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"Bad line breaking before and after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the beginning of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"'{{operator}}' should be placed at the end of the line.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: {\n                        line: operatorToken.loc.end.line,\n                        column: operatorToken.loc.end.column\n                    },\n                    message: \"There should be no line break before or after '{{operator}}'.\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/padded-blocks.js":"/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const options = {};\n        const config = context.options[0] || \"always\";\n\n        if (typeof config === \"string\") {\n            options.blocks = config === \"always\";\n        } else {\n            if (config.hasOwnProperty(\"blocks\")) {\n                options.blocks = config.blocks === \"always\";\n            }\n            if (config.hasOwnProperty(\"switches\")) {\n                options.switches = config.switches === \"always\";\n            }\n            if (config.hasOwnProperty(\"classes\")) {\n                options.classes = config.classes === \"always\";\n            }\n        }\n\n        const ALWAYS_MESSAGE = \"Block must be padded by blank lines.\",\n            NEVER_MESSAGE = \"Block must not be padded by blank lines.\";\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if there is padding between two tokens\n         * @param {Token} first The first token\n         * @param {Token} second The second token\n         * @returns {boolean} True if there is at least a line between the tokens\n         */\n        function isPaddingBetweenTokens(first, second) {\n            return second.loc.start.line - first.loc.end.line >= 2;\n        }\n\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function getFirstBlockToken(token) {\n            let prev = token,\n                first = token;\n\n            do {\n                prev = first;\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n            return first;\n        }\n\n        /**\n         * Checks if the given token is preceeded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceeded by a blank line\n         */\n        function getLastBlockToken(token) {\n            let last = token,\n                next = token;\n\n            do {\n                next = last;\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n            return last;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            const openBrace = getOpenBrace(node),\n                firstBlockToken = getFirstBlockToken(openBrace),\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\n                closeBrace = sourceCode.getLastToken(node),\n                lastBlockToken = getLastBlockToken(closeBrace),\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n            if (requirePaddingFor(node)) {\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n                        },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },\n                        fix(fixer) {\n                            return fixer.replaceTextRange([tokenBeforeFirst.end, firstBlockToken.start - firstBlockToken.loc.start.column], \"\\n\");\n                        },\n                        message: NEVER_MESSAGE\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n\n                    context.report({\n                        node,\n                        loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },\n                        message: NEVER_MESSAGE,\n                        fix(fixer) {\n                            return fixer.replaceTextRange([lastBlockToken.end, tokenAfterLast.start - tokenAfterLast.loc.start.column], \"\\n\");\n                        }\n                    });\n                }\n            }\n        }\n\n        const rule = {};\n\n        if (options.hasOwnProperty(\"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (options.hasOwnProperty(\"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (options.hasOwnProperty(\"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-arrow-callback.js":"/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node - A MetaProperty node to check.\n * @param {string} metaName - The name of `MetaProperty.meta`.\n * @param {string} propertyName - The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {escope.Scope} scope - A scope to get.\n * @returns {escope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node - A node to check.\n * @returns {Object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    const retv = { isCallback: false, isLexicalThis: false };\n    let parent = node.parent;\n\n    while (node) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (parent.object === node &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\" &&\n                    parent.parent.type === \"CallExpression\" &&\n                    parent.parent.callee === parent\n                ) {\n                    retv.isLexicalThis = (\n                        parent.parent.arguments.length === 1 &&\n                        parent.parent.arguments[0].type === \"ThisExpression\"\n                    );\n                    node = parent;\n                    parent = parent.parent;\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== node) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        node = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n/**\n* Checks whether a simple list of parameters contains any duplicates. This does not handle complex\nparameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\nparameter names anyway. Instead, it always returns `false` for complex parameter lists.\n* @param {ASTNode[]} paramsList The list of parameters for a function\n* @returns {boolean} `true` if the list of parameters contains any duplicates\n*/\nfunction hasDuplicateParams(paramsList) {\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require arrow functions as callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\"\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n\n        const allowUnboundThis = options.allowUnboundThis !== false;  // default to true\n        const allowNamedFunctions = options.allowNamedFunctions;\n        const sourceCode = context.getSourceCode();\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        let stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({ this: false, super: false, meta: false });\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super() {\n                const info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty(node) {\n                const info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\"(node) {\n                const scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                const nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                const variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                const callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report({\n                        node,\n                        message: \"Unexpected function expression.\",\n                        fix(fixer) {\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\n\n                                // If the callback function does not have .bind(this) and contains a reference to `this`, there\n                                // is no way to determine what `this` should be, so don't perform any fixes.\n                                // If the callback function has duplicates in its list of parameters (possible in sloppy mode),\n                                // don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\n                                return null;\n                            }\n\n                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);\n                            const paramsRightParen = sourceCode.getTokenBefore(node.body);\n                            const asyncKeyword = node.async ? \"async \" : \"\";\n                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);\n\n                            if (callbackInfo.isLexicalThis) {\n\n                                // If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.\n                                return fixer.replaceText(node.parent.parent, `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`);\n                            }\n\n                            // Otherwise, only replace the `function` keyword and parameters with the arrow function parameters.\n                            return fixer.replaceTextRange([node.start, node.body.start], `${asyncKeyword}${paramsFullText} => `);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-const.js":"/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;\n\n/**\n * Adds multiple items to the tail of an array.\n *\n * @param {any[]} array - A destination to add.\n * @param {any[]} values - Items to be added.\n * @returns {void}\n */\nconst pushAll = Function.apply.bind(Array.prototype.push);\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n *\n * @param {ASTNode} identifier - An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n *\n * @param {escope.Variable} variable - A variable to get.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    /*\n     * Due to a bug in acorn, code such as `let foo = 1; let foo = 2;` will not throw a syntax error. As a sanity\n     * check, make sure that the variable only has one declaration. After the parsing bug is fixed, this check\n     * will no longer be necessary, because variables declared with `let` or `const` should always have exactly one\n     * declaration.\n     * https://github.com/ternjs/acorn/issues/487\n     */\n    if (variable.defs.length > 1) {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    // If the assignment is from a different scope, ignore it.\n    // If the assignment cannot change to a declaration, ignore it.\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n    return writer.identifier;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {escope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {escope.Variable[]} variables - Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            // Avoid counting a reference twice or more for default values of\n            // destructuring.\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n *\n * @param {ASTNode} node – The node to search from.\n * @param {string} type – The type field of the parent node.\n * @param {Function} shouldStop – a predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"] },\n                    ignoreReadBeforeAssign: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const checkingMixedDestructuring = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         *\n         * @param {(escope.Reference|null)[]} nodes -\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (checkingMixedDestructuring || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const shouldFix = varDeclParent &&\n\n                    // If there are multiple variable declarations, like {let a = 1, b = 2}, then\n                    // do not attempt to fix if one of the declarations should be `const`. It's\n                    // too hard to know how the developer would want to automatically resolve the issue.\n                    varDeclParent.declarations.length === 1 &&\n\n                    // Don't do a fix unless the variable is initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations[0].init) &&\n\n                    // If options.destucturing is \"all\", then this warning will not occur unless\n                    // every assignment in the destructuring should be const. In that case, it's safe\n                    // to apply the fix.\n                    nodesToReport.length === nodes.length;\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        message: \"'{{name}}' is never reassigned. Use 'const' instead.\",\n                        data: node,\n                        fix: shouldFix ? fixer => fixer.replaceText(sourceCode.getFirstToken(varDeclParent), \"const\") : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    pushAll(variables, context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-destructuring.js":"/**\n * @fileoverview Prefer destructuring from arrays and objects\n * @author Alex LaFroscia\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require destructuring from arrays and/or objects\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    array: {\n                        type: \"boolean\"\n                    },\n                    object: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            },\n            {\n                type: \"object\",\n                properties: {\n                    enforceForRenamedProperties: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n    create(context) {\n\n        let checkArrays = true;\n        let checkObjects = true;\n        let enforceForRenamedProperties = false;\n        const enabledTypes = context.options[0];\n        const additionalOptions = context.options[1];\n\n        if (enabledTypes) {\n            if (typeof enabledTypes.array !== \"undefined\") {\n                checkArrays = enabledTypes.array;\n            }\n\n            if (typeof enabledTypes.object !== \"undefined\") {\n                checkObjects = enabledTypes.object;\n            }\n        }\n\n        if (additionalOptions) {\n            if (typeof additionalOptions.enforceForRenamedProperties !== \"undefined\") {\n                enforceForRenamedProperties = additionalOptions.enforceForRenamedProperties;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if the given node node is accessing an array index\n         *\n         * This is used to differentiate array index access from object property\n         * access.\n         *\n         * @param {ASTNode} node the node to evaluate\n         * @returns {boolean} whether or not the node is an integer\n         */\n        function isArrayIndexAccess(node) {\n            return Number.isInteger(node.property.value);\n        }\n\n        /**\n         * Report that the given node should use destructuring\n         *\n         * @param {ASTNode} reportNode the node to report\n         * @param {string} type the type of destructuring that should have been done\n         * @returns {void}\n         */\n        function report(reportNode, type) {\n            context.report({ node: reportNode, message: \"Use {{type}} destructuring.\", data: { type } });\n        }\n\n        /**\n         * Check that the `prefer-destructuring` rules are followed based on the\n         * given left- and right-hand side of the assignment.\n         *\n         * Pulled out into a separate method so that VariableDeclarators and\n         * AssignmentExpressions can share the same verification logic.\n         *\n         * @param {ASTNode} leftNode the left-hand side of the assignment\n         * @param {ASTNode} rightNode the right-hand side of the assignment\n         * @param {ASTNode} reportNode the node to report the error on\n         * @returns {void}\n         */\n        function performCheck(leftNode, rightNode, reportNode) {\n            if (rightNode.type !== \"MemberExpression\") {\n                return;\n            }\n\n            if (checkArrays && isArrayIndexAccess(rightNode)) {\n                report(reportNode, \"array\");\n                return;\n            }\n\n            if (checkObjects && enforceForRenamedProperties) {\n                report(reportNode, \"object\");\n                return;\n            }\n\n            if (checkObjects) {\n                const property = rightNode.property;\n\n                if ((property.type === \"Literal\" && leftNode.name === property.value) ||\n                    (property.type === \"Identifier\" && leftNode.name === property.name)) {\n                    report(reportNode, \"object\");\n                }\n            }\n        }\n\n        /**\n         * Check if a given variable declarator is coming from an property access\n         * that should be using destructuring instead\n         *\n         * @param {ASTNode} node the variable declarator to check\n         * @returns {void}\n         */\n        function checkVariableDeclarator(node) {\n\n            // Skip if variable is declared without assignment\n            if (!node.init) {\n                return;\n            }\n\n            // We only care about member expressions past this point\n            if (node.init.type !== \"MemberExpression\") {\n                return;\n            }\n\n            performCheck(node.id, node.init, node);\n        }\n\n        /**\n         * Run the `prefer-destructuring` check on an AssignmentExpression\n         *\n         * @param {ASTNode} node the AssignmentExpression node\n         * @returns {void}\n         */\n        function checkAssigmentExpression(node) {\n            if (node.operator === \"=\") {\n                performCheck(node.left, node.right, node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator: checkVariableDeclarator,\n            AssignmentExpression: checkAssigmentExpression\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-numeric-literals.js":"/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const radixMap = {\n            2: \"binary\",\n            8: \"octal\",\n            16: \"hexadecimal\"\n        };\n\n        const prefixMap = {\n            2: \"0b\",\n            8: \"0o\",\n            16: \"0x\"\n        };\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            CallExpression(node) {\n\n                // doesn't check parseInt() if it doesn't have a radix argument\n                if (node.arguments.length !== 2) {\n                    return;\n                }\n\n                // only error if the radix is 2, 8, or 16\n                const radixName = radixMap[node.arguments[1].value];\n\n                if (node.callee.type === \"Identifier\" &&\n                    node.callee.name === \"parseInt\" &&\n                    radixName &&\n                    node.arguments[0].type === \"Literal\"\n                ) {\n                    context.report({\n                        node,\n                        message: \"Use {{radixName}} literals instead of parseInt().\",\n                        data: {\n                            radixName\n                        },\n                        fix(fixer) {\n                            const newPrefix = prefixMap[node.arguments[1].value];\n\n                            if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {\n\n                                // If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                // or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                return null;\n                            }\n                            return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-promise-reject-errors.js":"/**\n * @fileoverview restrict values that can be used as Promise rejection reasons\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require using Error objects as Promise rejection reasons\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        fixable: null,\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowEmptyReject: { type: \"boolean\" }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n\n        /**\n        * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error\n        * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise\n        * @returns {void}\n        */\n        function checkRejectCall(callExpression) {\n            if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {\n                return;\n            }\n            if (\n                !callExpression.arguments.length ||\n                !astUtils.couldBeError(callExpression.arguments[0]) ||\n                callExpression.arguments[0].type === \"Identifier\" && callExpression.arguments[0].name === \"undefined\"\n            ) {\n                context.report({\n                    node: callExpression,\n                    message: \"Expected the Promise rejection reason to be an Error.\"\n                });\n            }\n        }\n\n        /**\n        * Determines whether a function call is a Promise.reject() call\n        * @param {ASTNode} node A CallExpression node\n        * @returns {boolean} `true` if the call is a Promise.reject() call\n        */\n        function isPromiseRejectCall(node) {\n            return node.callee.type === \"MemberExpression\" &&\n                node.callee.object.type === \"Identifier\" && node.callee.object.name === \"Promise\" &&\n                node.callee.property.type === \"Identifier\" && node.callee.property.name === \"reject\";\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            // Check `Promise.reject(value)` calls.\n            CallExpression(node) {\n                if (isPromiseRejectCall(node)) {\n                    checkRejectCall(node);\n                }\n            },\n\n            /*\n             * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.\n             * This function is run on \"NewExpression:exit\" instead of \"NewExpression\" to ensure that\n             * the nodes in the expression already have the `parent` property.\n             */\n            \"NewExpression:exit\"(node) {\n                if (\n                    node.callee.type === \"Identifier\" && node.callee.name === \"Promise\" &&\n                    node.arguments.length && astUtils.isFunction(node.arguments[0]) &&\n                    node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === \"Identifier\"\n                ) {\n                    context.getDeclaredVariables(node.arguments[0])\n\n                        /*\n                        * Find the first variable that matches the second parameter's name.\n                        * If the first parameter has the same name as the second parameter, then the variable will actually\n                        * be \"declared\" when the first parameter is evaluated, but then it will be immediately overwritten\n                        * by the second parameter. It's not possible for an expression with the variable to be evaluated before\n                        * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or\n                        * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for\n                        * this case.\n                        */\n                        .find(variable => variable.name === node.arguments[0].params[1].name)\n\n                        // Get the references to that variable.\n                        .references\n\n                        // Only check the references that read the parameter's value.\n                        .filter(ref => ref.isRead())\n\n                        // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.\n                        .filter(ref => ref.identifier.parent.type === \"CallExpression\" && ref.identifier === ref.identifier.parent.callee)\n\n                        // Check the argument of the function call to determine whether it's an Error.\n                        .forEach(ref => checkRejectCall(ref.identifier.parent));\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-reflect.js":"/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n * @deprecated in ESLint v3.9.0\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `Reflect` methods where applicable\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            replacedBy: []\n        },\n\n        deprecated: true,\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\n                                \"apply\",\n                                \"call\",\n                                \"delete\",\n                                \"defineProperty\",\n                                \"getOwnPropertyDescriptor\",\n                                \"getPrototypeOf\",\n                                \"setPrototypeOf\",\n                                \"isExtensible\",\n                                \"getOwnPropertyNames\",\n                                \"preventExtensions\"\n                            ]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const existingNames = {\n            apply: \"Function.prototype.apply\",\n            call: \"Function.prototype.call\",\n            defineProperty: \"Object.defineProperty\",\n            getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Object.getPrototypeOf\",\n            setPrototypeOf: \"Object.setPrototypeOf\",\n            isExtensible: \"Object.isExtensible\",\n            getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n            preventExtensions: \"Object.preventExtensions\"\n        };\n\n        const reflectSubsitutes = {\n            apply: \"Reflect.apply\",\n            call: \"Reflect.apply\",\n            defineProperty: \"Reflect.defineProperty\",\n            getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Reflect.getPrototypeOf\",\n            setPrototypeOf: \"Reflect.setPrototypeOf\",\n            isExtensible: \"Reflect.isExtensible\",\n            getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n            preventExtensions: \"Reflect.preventExtensions\"\n        };\n\n        const exceptions = (context.options[0] || {}).exceptions || [];\n\n        /**\n         * Reports the Reflect violation based on the `existing` and `substitute`\n         * @param {Object} node The node that violates the rule.\n         * @param {string} existing The existing method name that has been used.\n         * @param {string} substitute The Reflect substitute that should be used.\n         * @returns {void}\n         */\n        function report(node, existing, substitute) {\n            context.report({ node, message: \"Avoid using {{existing}}, instead use {{substitute}}.\", data: {\n                existing,\n                substitute\n            } });\n        }\n\n        return {\n            CallExpression(node) {\n                const methodName = (node.callee.property || {}).name;\n                const isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n                const hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);\n                const userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {\n                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);\n                }\n            },\n            UnaryExpression(node) {\n                const isDeleteOperator = node.operator === \"delete\";\n                const targetsIdentifier = node.argument.type === \"Identifier\";\n                const userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n                    report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-rest-params.js":"/**\n * @fileoverview Rule to\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {escope.Scope} scope - A scope to get.\n * @returns {escope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    const variables = scope.variables;\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            // If there was a parameter which is named \"arguments\", the implicit \"arguments\" is not defined.\n            // So does fast return with null.\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next : unreachable */\n    return null;\n}\n\n/**\n * Checks if the given reference is not normal member access.\n *\n * - arguments         .... true    // not member access\n * - arguments[i]      .... true    // computed member access\n * - arguments[0]      .... true    // computed member access\n * - arguments.length  .... false   // normal member access\n *\n * @param {escope.Reference} reference - The reference to check.\n * @returns {boolean} `true` if the reference is not normal member access.\n */\nfunction isNotNormalMemberAccess(reference) {\n    const id = reference.identifier;\n    const parent = id.parent;\n\n    return !(\n        parent.type === \"MemberExpression\" &&\n        parent.object === id &&\n        !parent.computed\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require rest parameters instead of `arguments`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports a given reference.\n         *\n         * @param {escope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            context.report({\n                node: reference.identifier,\n                loc: reference.identifier.loc,\n                message: \"Use the rest parameters instead of 'arguments'.\"\n            });\n        }\n\n        /**\n         * Reports references of the implicit `arguments` variable if exist.\n         *\n         * @returns {void}\n         */\n        function checkForArguments() {\n            const argumentsVar = getVariableOfArguments(context.getScope());\n\n            if (argumentsVar) {\n                argumentsVar\n                    .references\n                    .filter(isNotNormalMemberAccess)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            \"FunctionDeclaration:exit\": checkForArguments,\n            \"FunctionExpression:exit\": checkForArguments\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-spread.js":"/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.property.name === \"apply\" &&\n        node.callee.computed === false &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\" &&\n        node.arguments[1].type !== \"SpreadElement\"\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    const tokensL = sourceCode.getTokens(left);\n    const tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (let i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context - The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require spread operators instead of `.apply()`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression(node) {\n                if (!isVariadicApplyCalling(node)) {\n                    return;\n                }\n\n                const applied = node.callee.object;\n                const expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                const thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report({\n                        node,\n                        message: \"Use the spread operator instead of '.apply()'.\",\n                        fix(fixer) {\n                            if (expectedThis && expectedThis.type !== \"Identifier\") {\n\n                                // Don't fix cases where the `this` value could be a computed expression.\n                                return null;\n                            }\n\n                            const propertyDot = sourceCode.getFirstTokenBetween(applied, node.callee.property, token => token.value === \".\");\n\n                            return fixer.replaceTextRange([propertyDot.range[0], node.range[1]], `(...${sourceCode.getText(node.arguments[1])})`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/prefer-template.js":"/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node - A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    while (isConcatenation(node.parent)) {\n        node = node.parent;\n    }\n    return node;\n}\n\n/**\n* Checks whether or not a given binary expression has string literals.\n* @param {ASTNode} node - A node to check.\n* @returns {boolean} `true` if the node has string literals.\n*/\nfunction hasStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n    }\n    return astUtils.isStringLiteral(node);\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n/**\n* Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\n* @param {ASTNode} node The node that will be fixed to a template literal\n* @returns {boolean} `true` if the node will start with a template curly.\n*/\nfunction startsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.left);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[0].start === node.quasis[0].end;\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n/**\n* Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\n* @param {ASTNode} node The node that will be fixed to a template literal\n* @returns {boolean} `true` if the node will end with a template curly.\n*/\nfunction endsWithTemplateCurly(node) {\n    if (node.type === \"BinaryExpression\") {\n        return startsWithTemplateCurly(node.right);\n    }\n    if (node.type === \"TemplateLiteral\") {\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].start === node.quasis[node.quasis.length - 1].end;\n    }\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let done = Object.create(null);\n\n        /**\n        * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\n        * @param {ASTNode} node1 The first node\n        * @param {ASTNode} node2 The second node\n        * @returns {string} The text between the nodes, excluding other tokens\n        */\n        function getTextBetween(node1, node2) {\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n            const sourceText = sourceCode.getText();\n\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n        }\n\n        /**\n        * Returns a template literal form of the given node.\n        * @param {ASTNode} currentNode A node that should be converted to a template literal\n        * @param {string} textBeforeNode Text that should appear before the node\n        * @param {string} textAfterNode Text that should appear after the node\n        * @returns {string} A string form of this node, represented as a template literal\n        */\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n\n                // If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\n                // as a template placeholder. However, if the code already contains a backslash before the ${ or `\n                // for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\n                // an actual backslash character to appear before the dollar sign).\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\${|`)/g, matched => {\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\n                        return `\\\\${matched}`;\n                    }\n                    return matched;\n\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"g\"), currentNode.raw[0])}\\``;\n            }\n\n            if (currentNode.type === \"TemplateLiteral\") {\n                return sourceCode.getText(currentNode);\n            }\n\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n                if (leftEndsWithCurly) {\n\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n                }\n                if (rightStartsWithCurly) {\n\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n                }\n\n                // Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\n                // the text between them.\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n            }\n\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n        }\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report({\n                    node: topBinaryExpr,\n                    message: \"Unexpected string concatenation.\",\n                    fix(fixer) {\n                        return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n                    }\n                });\n            }\n        }\n\n        return {\n            Program() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/quote-props.js":"/**\n * @fileoverview Rule to flag non-quoted property names in object literals.\n * @author Mathias Bynens <http://mathiasbynens.be/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require quotes around object literal property names\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                keywords: {\n                                    type: \"boolean\"\n                                },\n                                unnecessary: {\n                                    type: \"boolean\"\n                                },\n                                numbers: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const MODE = context.options[0],\n            KEYWORDS = context.options[1] && context.options[1].keywords,\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n            NUMBERS = context.options[1] && context.options[1].numbers,\n\n            MESSAGE_UNNECESSARY = \"Unnecessarily quoted property '{{property}}' found.\",\n            MESSAGE_UNQUOTED = \"Unquoted property '{{property}}' found.\",\n            MESSAGE_NUMERIC = \"Unquoted number literal '{{property}}' used as key.\",\n            MESSAGE_RESERVED = \"Unquoted reserved word '{{property}}' used as key.\",\n            sourceCode = context.getSourceCode();\n\n\n        /**\n         * Checks whether a certain string constitutes an ES3 token\n         * @param   {string} tokenStr - The string to be checked.\n         * @returns {boolean} `true` if it is an ES3 token.\n         */\n        function isKeyword(tokenStr) {\n            return keywords.indexOf(tokenStr) >= 0;\n        }\n\n        /**\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\n         * @param   {string} rawKey The raw key value from the source\n         * @param   {espreeTokens} tokens The espree-tokenized node key\n         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\n         * @returns {boolean} Whether or not a key has redundant quotes.\n         * @private\n         */\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\n        }\n\n        /**\n        * Returns a string representation of a property node with quotes removed\n        * @param {ASTNode} key Key AST Node, which may or may not be quoted\n        * @returns {string} A replacement string for this property\n        */\n        function getUnquotedKey(key) {\n            return key.type === \"Identifier\" ? key.name : key.value;\n        }\n\n        /**\n        * Returns a string representation of a property node with quotes added\n        * @param {ASTNode} key Key AST Node, which may or may not be quoted\n        * @returns {string} A replacement string for this property\n        */\n        function getQuotedKey(key) {\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                // If the key is already a string literal, don't replace the quotes with double quotes.\n                return sourceCode.getText(key);\n            }\n\n            // Otherwise, the key is either an identifier or a number literal.\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n        }\n\n        /**\n         * Ensures that a property's key is quoted only when necessary\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkUnnecessaryQuotes(node) {\n            const key = node.key;\n            let tokens;\n\n            if (node.method || node.computed || node.shorthand) {\n                return;\n            }\n\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\n                try {\n                    tokens = espree.tokenize(key.value);\n                } catch (e) {\n                    return;\n                }\n\n                if (tokens.length !== 1) {\n                    return;\n                }\n\n                const isKeywordToken = isKeyword(tokens[0].value);\n\n                if (isKeywordToken && KEYWORDS) {\n                    return;\n                }\n\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n                    context.report({\n                        node,\n                        message: MESSAGE_UNNECESSARY,\n                        data: { property: key.value },\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n                    });\n                }\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n                context.report({\n                    node,\n                    message: MESSAGE_RESERVED,\n                    data: { property: key.name },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            } else if (NUMBERS && key.type === \"Literal\" && typeof key.value === \"number\") {\n                context.report({\n                    node,\n                    message: MESSAGE_NUMERIC,\n                    data: { property: key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that a property's key is quoted\n         * @param   {ASTNode} node Property AST node\n         * @returns {void}\n         */\n        function checkOmittedQuotes(node) {\n            const key = node.key;\n\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n                context.report({\n                    node,\n                    message: MESSAGE_UNQUOTED,\n                    data: { property: key.name || key.value },\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n                });\n            }\n        }\n\n        /**\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\n         * @param   {ASTNode} node Property AST node\n         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\n         * @returns {void}\n         */\n        function checkConsistency(node, checkQuotesRedundancy) {\n            const quotedProps = [],\n                unquotedProps = [];\n            let keywordKeyName = null,\n                necessaryQuotes = false;\n\n            node.properties.forEach(property => {\n                const key = property.key;\n                let tokens;\n\n                if (!key || property.method || property.computed || property.shorthand) {\n                    return;\n                }\n\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\n\n                    quotedProps.push(property);\n\n                    if (checkQuotesRedundancy) {\n                        try {\n                            tokens = espree.tokenize(key.value);\n                        } catch (e) {\n                            necessaryQuotes = true;\n                            return;\n                        }\n\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n                    }\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n                    unquotedProps.push(property);\n                    necessaryQuotes = true;\n                    keywordKeyName = key.name;\n                } else {\n                    unquotedProps.push(property);\n                }\n            });\n\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n                quotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties shouldn't be quoted as all quotes are redundant.\",\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n                    });\n                });\n            } else if (unquotedProps.length && keywordKeyName) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n                        data: { property: keywordKeyName },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            } else if (quotedProps.length && unquotedProps.length) {\n                unquotedProps.forEach(property => {\n                    context.report({\n                        node: property,\n                        message: \"Inconsistently quoted property '{{key}}' found.\",\n                        data: { key: property.key.name || property.key.value },\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n                    });\n                });\n            }\n        }\n\n        return {\n            Property(node) {\n                if (MODE === \"always\" || !MODE) {\n                    checkOmittedQuotes(node);\n                }\n                if (MODE === \"as-needed\") {\n                    checkUnnecessaryQuotes(node);\n                }\n            },\n            ObjectExpression(node) {\n                if (MODE === \"consistent\") {\n                    checkConsistency(node, false);\n                }\n                if (MODE === \"consistent-as-needed\") {\n                    checkConsistency(node, true);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/quotes.js":"/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst QUOTE_SETTINGS = {\n    double: {\n        quote: \"\\\"\",\n        alternateQuote: \"'\",\n        description: \"doublequote\"\n    },\n    single: {\n        quote: \"'\",\n        alternateQuote: \"\\\"\",\n        description: \"singlequote\"\n    },\n    backtick: {\n        quote: \"`\",\n        alternateQuote: \"\\\"\",\n        description: \"backtick\"\n    }\n};\n\n// An unescaped newline is a newline preceded by an even number of backslashes.\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`);\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str - A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert =\nQUOTE_SETTINGS.single.convert =\nQUOTE_SETTINGS.backtick.convert = function(str) {\n    const newQuote = this.quote;\n    const oldQuote = str[0];\n\n    if (newQuote === oldQuote) {\n        return str;\n    }\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\${|\\r\\n?|\\n|.)|[\"'`]|\\${|(\\r\\n?|\\n)/g, (match, escaped, newline) => {\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n            return escaped; // unescape\n        }\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n            return `\\\\${match}`; // escape\n        }\n        if (newline && oldQuote === \"`\") {\n            return \"\\\\n\"; // escape newlines\n        }\n        return match;\n    }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either backticks, double, or single quotes\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"single\", \"double\", \"backtick\"]\n            },\n            {\n                anyOf: [\n                    {\n                        enum: [\"avoid-escape\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            avoidEscape: {\n                                type: \"boolean\"\n                            },\n                            allowTemplateLiterals: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n\n        const quoteOption = context.options[0],\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n            options = context.options[1],\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n            sourceCode = context.getSourceCode();\n        let avoidEscape = options && options.avoidEscape === true;\n\n        // deprecated\n        if (options === AVOID_ESCAPE) {\n            avoidEscape = true;\n        }\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         *\n         * This function returns `true` in the following cases:\n         *\n         * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\n         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\n         *\n         * In particular, this function returns `false` in the following cases:\n         *\n         * - `<div className={\"foo\"}></div>`\n         * - `<div>{\"foo\"}</div>`\n         *\n         * In both cases, inside of the braces is handled as normal JavaScript.\n         * The braces are `JSXExpressionContainer` nodes.\n         *\n         * @param {ASTNode} node The Literal node to check.\n         * @returns {boolean} True if the node is a part of JSX, false if not.\n         * @private\n         */\n        function isJSXLiteral(node) {\n            return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\";\n        }\n\n        /**\n         * Checks whether or not a given node is a directive.\n         * The directive is a `ExpressionStatement` which has only a string literal.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a directive.\n         * @private\n         */\n        function isDirective(node) {\n            return (\n                node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" &&\n                typeof node.expression.value === \"string\"\n            );\n        }\n\n        /**\n         * Checks whether or not a given node is a part of directive prologues.\n         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a part of directive prologues.\n         * @private\n         */\n        function isPartOfDirectivePrologue(node) {\n            const block = node.parent.parent;\n\n            if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\n                return false;\n            }\n\n            // Check the node is at a prologue.\n            for (let i = 0; i < block.body.length; ++i) {\n                const statement = block.body[i];\n\n                if (statement === node.parent) {\n                    return true;\n                }\n                if (!isDirective(statement)) {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether or not a given node is allowed as non backtick.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\n         * @private\n         */\n        function isAllowedAsNonBacktick(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                // Directive Prologues.\n                case \"ExpressionStatement\":\n                    return isPartOfDirectivePrologue(node);\n\n                // LiteralPropertyName.\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.key === node && !parent.computed;\n\n                // ModuleSpecifier.\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                case \"ExportAllDeclaration\":\n                    return parent.source === node;\n\n                // Others don't allow.\n                default:\n                    return false;\n            }\n        }\n\n        return {\n\n            Literal(node) {\n                const val = node.value,\n                    rawVal = node.raw;\n                let isValid;\n\n                if (settings && typeof val === \"string\") {\n                    isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\n                        isJSXLiteral(node) ||\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\n\n                    if (!isValid && avoidEscape) {\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n                    }\n\n                    if (!isValid) {\n                        context.report({\n                            node,\n                            message: \"Strings must use {{description}}.\",\n                            data: {\n                                description: settings.description\n                            },\n                            fix(fixer) {\n                                return fixer.replaceText(node, settings.convert(node.raw));\n                            }\n                        });\n                    }\n                }\n            },\n\n            TemplateLiteral(node) {\n\n                // If backticks are expected or it's a tagged template, then this shouldn't throw an errors\n                if (\n                    allowTemplateLiterals ||\n                    quoteOption === \"backtick\" ||\n                    node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi\n                ) {\n                    return;\n                }\n\n                // A warning should be produced if the template literal only has one TemplateElement, and has no unescaped newlines.\n                const shouldWarn = node.quasis.length === 1 && !UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n                if (shouldWarn) {\n                    context.report({\n                        node,\n                        message: \"Strings must use {{description}}.\",\n                        data: {\n                            description: settings.description\n                        },\n                        fix(fixer) {\n                            if (isPartOfDirectivePrologue(node)) {\n\n                                /*\n                                 * TemplateLiterals in a directive prologue aren't actually directives, but if they're\n                                 * in the directive prologue, then fixing them might turn them into directives and change\n                                 * the behavior of the code.\n                                 */\n                                return null;\n                            }\n                            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/radix.js":"/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\n/**\n * Checks whether a given variable is shadowed or not.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except numbers.\n * - undefined.\n *\n * @param {ASTNode} radix - A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && typeof radix.value !== \"number\") ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n *\n * @param {ASTNode} radix - A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         *\n         * @param {ASTNode} node - A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        message: \"Missing parameters.\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            message: \"Missing radix parameter.\"\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Redundant radix parameter.\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            message: \"Invalid radix parameter.\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (!isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/require-await.js":"/**\n * @fileoverview Rule to disallow async functions which have no `await` expression.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Capitalize the 1st letter of the given text.\n *\n * @param {string} text - The text to capitalize.\n * @returns {string} The text that the 1st letter was capitalized.\n */\nfunction capitalizeFirstLetter(text) {\n    return text[0].toUpperCase() + text.slice(1);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow async functions which have no `await` expression\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: []\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        let scopeInfo = null;\n\n        /**\n         * Push the scope info object to the stack.\n         *\n         * @returns {void}\n         */\n        function enterFunction() {\n            scopeInfo = {\n                upper: scopeInfo,\n                hasAwait: false\n            };\n        }\n\n        /**\n         * Pop the top scope info object from the stack.\n         * Also, it reports the function if needed.\n         *\n         * @param {ASTNode} node - The node to report.\n         * @returns {void}\n         */\n        function exitFunction(node) {\n            if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {\n                context.report({\n                    node,\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n                    message: \"{{name}} has no 'await' expression.\",\n                    data: {\n                        name: capitalizeFirstLetter(\n                            astUtils.getFunctionNameWithKind(node)\n                        )\n                    }\n                });\n            }\n\n            scopeInfo = scopeInfo.upper;\n        }\n\n        return {\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            \"FunctionExpression:exit\": exitFunction,\n            \"ArrowFunctionExpression:exit\": exitFunction,\n\n            AwaitExpression() {\n                scopeInfo.hasAwait = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/require-jsdoc.js":"/**\n * @fileoverview Rule to check for jsdoc presence.\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require JSDoc comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    require: {\n                        type: \"object\",\n                        properties: {\n                            ClassDeclaration: {\n                                type: \"boolean\"\n                            },\n                            MethodDefinition: {\n                                type: \"boolean\"\n                            },\n                            FunctionDeclaration: {\n                                type: \"boolean\"\n                            },\n                            ArrowFunctionExpression: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const source = context.getSourceCode();\n        const DEFAULT_OPTIONS = {\n            FunctionDeclaration: true,\n            MethodDefinition: false,\n            ClassDeclaration: false\n        };\n        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({ node, message: \"Missing JSDoc comment.\" });\n        }\n\n        /**\n         * Check if the jsdoc comment is present for class methods\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkClassMethodJsDoc(node) {\n            if (node.parent.type === \"MethodDefinition\") {\n                const jsdocComment = source.getJSDocComment(node);\n\n                if (!jsdocComment) {\n                    report(node);\n                }\n            }\n        }\n\n        /**\n         * Check if the jsdoc comment is present or not.\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkJsDoc(node) {\n            const jsdocComment = source.getJSDocComment(node);\n\n            if (!jsdocComment) {\n                report(node);\n            }\n        }\n\n        return {\n            FunctionDeclaration(node) {\n                if (options.FunctionDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            FunctionExpression(node) {\n                if (options.MethodDefinition) {\n                    checkClassMethodJsDoc(node);\n                }\n            },\n            ClassDeclaration(node) {\n                if (options.ClassDeclaration) {\n                    checkJsDoc(node);\n                }\n            },\n            ArrowFunctionExpression(node) {\n                if (options.ArrowFunctionExpression && node.parent.type === \"VariableDeclarator\") {\n                    checkJsDoc(node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/require-yield.js":"/**\n * @fileoverview Rule to flag the generator functions that does not have yield.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require generator functions to contain `yield`\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [];\n\n        /**\n         * If the node is a generator function, start counting `yield` keywords.\n         * @param {Node} node - A function node to check.\n         * @returns {void}\n         */\n        function beginChecking(node) {\n            if (node.generator) {\n                stack.push(0);\n            }\n        }\n\n        /**\n         * If the node is a generator function, end counting `yield` keywords, then\n         * reports result.\n         * @param {Node} node - A function node to check.\n         * @returns {void}\n         */\n        function endChecking(node) {\n            if (!node.generator) {\n                return;\n            }\n\n            const countYield = stack.pop();\n\n            if (countYield === 0 && node.body.body.length > 0) {\n                context.report({ node, message: \"This generator function does not have 'yield'.\" });\n            }\n        }\n\n        return {\n            FunctionDeclaration: beginChecking,\n            \"FunctionDeclaration:exit\": endChecking,\n            FunctionExpression: beginChecking,\n            \"FunctionExpression:exit\": endChecking,\n\n            // Increases the count of `yield` keyword.\n            YieldExpression() {\n\n                /* istanbul ignore else */\n                if (stack.length > 0) {\n                    stack[stack.length - 1] += 1;\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/rest-spread-spacing.js":"/**\n * @fileoverview Enforce spacing between rest and spread operators and their expressions.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce spacing between rest and spread operators and their expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n        fixable: \"whitespace\",\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            alwaysSpace = context.options[0] === \"always\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks whitespace between rest/spread operators and their expressions\n         * @param {ASTNode} node - The node to check\n         * @returns {void}\n         */\n        function checkWhiteSpace(node) {\n            const operator = sourceCode.getFirstToken(node),\n                nextToken = sourceCode.getTokenAfter(operator),\n                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);\n            let type;\n\n            switch (node.type) {\n                case \"SpreadElement\":\n                    type = \"spread\";\n                    break;\n                case \"RestElement\":\n                    type = \"rest\";\n                    break;\n                case \"ExperimentalSpreadProperty\":\n                    type = \"spread property\";\n                    break;\n                case \"ExperimentalRestProperty\":\n                    type = \"rest property\";\n                    break;\n                default:\n                    return;\n            }\n\n            if (alwaysSpace && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        line: operator.loc.end.line,\n                        column: operator.loc.end.column\n                    },\n                    message: \"Expected whitespace after {{type}} operator.\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], \" \");\n                    }\n                });\n            } else if (!alwaysSpace && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: {\n                        line: operator.loc.end.line,\n                        column: operator.loc.end.column\n                    },\n                    message: \"Unexpected whitespace after {{type}} operator.\",\n                    data: {\n                        type\n                    },\n                    fix(fixer) {\n                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            SpreadElement: checkWhiteSpace,\n            RestElement: checkWhiteSpace,\n            ExperimentalSpreadProperty: checkWhiteSpace,\n            ExperimentalRestProperty: checkWhiteSpace\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/semi-spacing.js":"/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let requireSpaceBefore = false,\n            requireSpaceAfter = true;\n\n        if (typeof config === \"object\") {\n            if (config.hasOwnProperty(\"before\")) {\n                requireSpaceBefore = config.before;\n            }\n            if (config.hasOwnProperty(\"after\")) {\n                requireSpaceAfter = config.after;\n            }\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            const tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\n        }\n\n        /**\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            if (astUtils.isSemicolonToken(token)) {\n                const location = token.loc.start;\n\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Unexpected whitespace before semicolon.\",\n                            fix(fixer) {\n                                const tokenBefore = sourceCode.getTokenBefore(token);\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        context.report({\n                            node,\n                            loc: location,\n                            message: \"Missing whitespace before semicolon.\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Unexpected whitespace after semicolon.\",\n                                fix(fixer) {\n                                    const tokenAfter = sourceCode.getTokenAfter(token);\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            context.report({\n                                node,\n                                loc: location,\n                                message: \"Missing whitespace after semicolon.\",\n                                fix(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            const token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration: checkNode,\n            ExportAllDeclaration: checkNode,\n            ExportDefaultDeclaration: checkNode,\n            ForStatement(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/semi.js":"/**\n * @fileoverview Rule to flag missing semicolons.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"../util/fix-tracker\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow semicolons instead of ASI\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                omitLastInOneLineBlock: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const OPT_OUT_PATTERN = /^[-[(/+`]/; // One of [(/+-`\n        const options = context.options[1];\n        const never = context.options[0] === \"never\",\n            exceptOneLine = options && options.omitLastInOneLineBlock === true,\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a semicolon error with appropriate location and message.\n         * @param {ASTNode} node The node with an extra or missing semicolon.\n         * @param {boolean} missing True if the semicolon is missing.\n         * @returns {void}\n         */\n        function report(node, missing) {\n            const lastToken = sourceCode.getLastToken(node);\n            let message,\n                fix,\n                loc = lastToken.loc;\n\n            if (!missing) {\n                message = \"Missing semicolon.\";\n                loc = loc.end;\n                fix = function(fixer) {\n                    return fixer.insertTextAfter(lastToken, \";\");\n                };\n            } else {\n                message = \"Extra semicolon.\";\n                loc = loc.start;\n                fix = function(fixer) {\n\n                    // Expand the replacement range to include the surrounding\n                    // tokens to avoid conflicting with no-extra-semi.\n                    // https://github.com/eslint/eslint/issues/7928\n                    return new FixTracker(fixer, sourceCode)\n                        .retainSurroundingTokens(lastToken)\n                        .remove(lastToken);\n                };\n            }\n\n            context.report({\n                node,\n                loc,\n                message,\n                fix\n            });\n\n        }\n\n        /**\n         * Check if a semicolon is unnecessary, only true if:\n         *   - next token is on a new line and is not one of the opt-out tokens\n         *   - next token is a valid statement divider\n         * @param {Token} lastToken last token of current node.\n         * @returns {boolean} whether the semicolon is unnecessary.\n         */\n        function isUnnecessarySemicolon(lastToken) {\n            if (!astUtils.isSemicolonToken(lastToken)) {\n                return false;\n            }\n\n            const nextToken = sourceCode.getTokenAfter(lastToken);\n\n            if (!nextToken) {\n                return true;\n            }\n\n            const lastTokenLine = lastToken.loc.end.line;\n            const nextTokenLine = nextToken.loc.start.line;\n            const isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value) && nextToken.value !== \"++\" && nextToken.value !== \"--\";\n            const isDivider = (astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken));\n\n            return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;\n        }\n\n        /**\n         * Checks a node to see if it's in a one-liner block statement.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is in a one-liner block statement.\n         */\n        function isOneLinerBlock(node) {\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            if (!nextToken || nextToken.value !== \"}\") {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            return parent && parent.type === \"BlockStatement\" &&\n              parent.loc.start.line === parent.loc.end.line;\n        }\n\n        /**\n         * Checks a node to see if it's followed by a semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolon(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (never) {\n                if (isUnnecessarySemicolon(lastToken)) {\n                    report(node, true);\n                }\n            } else {\n                if (!astUtils.isSemicolonToken(lastToken)) {\n                    if (!exceptOneLine || !isOneLinerBlock(node)) {\n                        report(node);\n                    }\n                } else {\n                    if (exceptOneLine && isOneLinerBlock(node)) {\n                        report(node, true);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks to see if there's a semicolon after a variable declaration.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolonForVariableDeclaration(node) {\n            const ancestors = context.getAncestors(),\n                parentIndex = ancestors.length - 1,\n                parent = ancestors[parentIndex];\n\n            if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\n                (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)\n            ) {\n                checkForSemicolon(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForSemicolonForVariableDeclaration,\n            ExpressionStatement: checkForSemicolon,\n            ReturnStatement: checkForSemicolon,\n            ThrowStatement: checkForSemicolon,\n            DoWhileStatement: checkForSemicolon,\n            DebuggerStatement: checkForSemicolon,\n            BreakStatement: checkForSemicolon,\n            ContinueStatement: checkForSemicolon,\n            ImportDeclaration: checkForSemicolon,\n            ExportAllDeclaration: checkForSemicolon,\n            ExportNamedDeclaration(node) {\n                if (!node.declaration) {\n                    checkForSemicolon(node);\n                }\n            },\n            ExportDefaultDeclaration(node) {\n                if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {\n                    checkForSemicolon(node);\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/sort-imports.js":"/**\n * @fileoverview Rule to require sorting of import declarations\n * @author Christian Schuller\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce sorted import declarations within modules\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\"\n                    },\n                    memberSyntaxSortOrder: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n                        },\n                        uniqueItems: true,\n                        minItems: 4,\n                        maxItems: 4\n                    },\n                    ignoreMemberSort: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false,\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n            sourceCode = context.getSourceCode();\n        let previousDeclaration = null;\n\n        /**\n         * Gets the used member syntax style.\n         *\n         * import \"my-module.js\" --> none\n         * import * as myModule from \"my-module.js\" --> all\n         * import {myMember} from \"my-module.js\" --> single\n         * import {foo, bar} from  \"my-module.js\" --> multiple\n         *\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\n         */\n        function usedMemberSyntax(node) {\n            if (node.specifiers.length === 0) {\n                return \"none\";\n            } else if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n                return \"all\";\n            } else if (node.specifiers.length === 1) {\n                return \"single\";\n            }\n            return \"multiple\";\n\n        }\n\n        /**\n         * Gets the group by member parameter index for given declaration.\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {number} the declaration group by member index.\n         */\n        function getMemberParameterGroupIndex(node) {\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n        }\n\n        /**\n         * Gets the local name of the first imported module.\n         * @param {ASTNode} node - the ImportDeclaration node.\n         * @returns {?string} the local name of the first imported module.\n         */\n        function getFirstLocalMemberName(node) {\n            if (node.specifiers[0]) {\n                return node.specifiers[0].local.name;\n            }\n            return null;\n\n        }\n\n        return {\n            ImportDeclaration(node) {\n                if (previousDeclaration) {\n                    const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                        previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n                    let currentLocalMemberName = getFirstLocalMemberName(node),\n                        previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n                    if (ignoreCase) {\n                        previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n                        currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n                    }\n\n                    // When the current declaration uses a different member syntax,\n                    // then check if the ordering is correct.\n                    // Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\n                    if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n                        if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                            context.report({\n                                node,\n                                message: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\",\n                                data: {\n                                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                                }\n                            });\n                        }\n                    } else {\n                        if (previousLocalMemberName &&\n                            currentLocalMemberName &&\n                            currentLocalMemberName < previousLocalMemberName\n                        ) {\n                            context.report({\n                                node,\n                                message: \"Imports should be sorted alphabetically.\"\n                            });\n                        }\n                    }\n                }\n\n                if (!ignoreMemberSort) {\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n                    if (firstUnsortedIndex !== -1) {\n                        context.report({\n                            node: importSpecifiers[firstUnsortedIndex],\n                            message: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\n                            fix(fixer) {\n                                if (importSpecifiers.some(specifier => sourceCode.getComments(specifier).leading.length || sourceCode.getComments(specifier).trailing.length)) {\n\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\n                                    importSpecifiers\n\n                                        // Clone the importSpecifiers array to avoid mutating it\n                                        .slice()\n\n                                        // Sort the array into the desired order\n                                        .sort((specifierA, specifierB) => {\n                                            const aName = getSortableName(specifierA);\n                                            const bName = getSortableName(specifierB);\n\n                                            return aName > bName ? 1 : -1;\n                                        })\n\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\n                                        .reduce((sourceText, specifier, index) => {\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\n                                                ? \"\"\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                                        }, \"\")\n                                );\n                            }\n                        });\n                    }\n                }\n\n                previousDeclaration = node;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/sort-keys.js":"/**\n * @fileoverview Rule to require object keys to be sorted\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\"),\n    naturalCompare = require(\"natural-compare\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property name of the given `Property` node.\n *\n * - If the property's key is an `Identifier` node, this returns the key's name\n *   whether it's a computed property or not.\n * - If the property has a static name, this returns the static name.\n * - Otherwise, this returns null.\n *\n * @param {ASTNode} node - The `Property` node to get.\n * @returns {string|null} The property name or null.\n * @private\n */\nfunction getPropertyName(node) {\n    return astUtils.getStaticPropertyName(node) || node.key.name || null;\n}\n\n/**\n * Functions which check that the given 2 names are in specific order.\n *\n * Postfix `I` is meant insensitive.\n * Postfix `N` is meant natual.\n *\n * @private\n */\nconst isValidOrders = {\n    asc(a, b) {\n        return a <= b;\n    },\n    ascI(a, b) {\n        return a.toLowerCase() <= b.toLowerCase();\n    },\n    ascN(a, b) {\n        return naturalCompare(a, b) <= 0;\n    },\n    ascIN(a, b) {\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n    },\n    desc(a, b) {\n        return isValidOrders.asc(b, a);\n    },\n    descI(a, b) {\n        return isValidOrders.ascI(b, a);\n    },\n    descN(a, b) {\n        return isValidOrders.ascN(b, a);\n    },\n    descIN(a, b) {\n        return isValidOrders.ascIN(b, a);\n    }\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require object keys to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n        schema: [\n            {\n                enum: [\"asc\", \"desc\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    caseSensitive: {\n                        type: \"boolean\"\n                    },\n                    natural: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Parse options.\n        const order = context.options[0] || \"asc\";\n        const options = context.options[1];\n        const insensitive = (options && options.caseSensitive) === false;\n        const natual = Boolean(options && options.natural);\n        const isValidOrder = isValidOrders[\n            order + (insensitive ? \"I\" : \"\") + (natual ? \"N\" : \"\")\n        ];\n\n        // The stack to save the previous property's name for each object literals.\n        let stack = null;\n\n        return {\n            ObjectExpression() {\n                stack = {\n                    upper: stack,\n                    prevName: null\n                };\n            },\n\n            \"ObjectExpression:exit\"() {\n                stack = stack.upper;\n            },\n\n            Property(node) {\n                if (node.parent.type === \"ObjectPattern\") {\n                    return;\n                }\n\n                const prevName = stack.prevName;\n                const thisName = getPropertyName(node);\n\n                stack.prevName = thisName || prevName;\n\n                if (!prevName || !thisName) {\n                    return;\n                }\n\n                if (!isValidOrder(prevName, thisName)) {\n                    context.report({\n                        node,\n                        loc: node.key.loc,\n                        message: \"Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\",\n                        data: {\n                            thisName,\n                            prevName,\n                            order,\n                            insensitive: insensitive ? \"insensitive \" : \"\",\n                            natual: natual ? \"natural \" : \"\"\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/sort-vars.js":"/**\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require variables within the same declaration block to be sorted\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreCase: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const configuration = context.options[0] || {},\n            ignoreCase = configuration.ignoreCase || false;\n\n        return {\n            VariableDeclaration(node) {\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n\n                idDeclarations.slice(1).reduce((memo, decl) => {\n                    let lastVariableName = memo.id.name,\n                        currenVariableName = decl.id.name;\n\n                    if (ignoreCase) {\n                        lastVariableName = lastVariableName.toLowerCase();\n                        currenVariableName = currenVariableName.toLowerCase();\n                    }\n\n                    if (currenVariableName < lastVariableName) {\n                        context.report({ node: decl, message: \"Variables within the same declaration block should be sorted alphabetically.\" });\n                        return memo;\n                    }\n                    return decl;\n\n                }, idDeclarations[0]);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/space-before-blocks.js":"/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let checkFunctions = true,\n            checkKeywords = true,\n            checkClasses = true;\n\n        if (typeof config === \"object\") {\n            checkFunctions = config.functions !== \"never\";\n            checkKeywords = config.keywords !== \"never\";\n            checkClasses = config.classes !== \"never\";\n        } else if (config === \"never\") {\n            checkFunctions = false;\n            checkKeywords = false;\n            checkClasses = false;\n        }\n\n        /**\n         * Checks whether or not a given token is an arrow operator (=>) or a keyword\n         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.\n         *\n         * @param {Token} token - A token to check.\n         * @returns {boolean} `true` if the token is an arrow operator.\n         */\n        function isConflicted(token) {\n            return (token.type === \"Punctuator\" && token.value === \"=>\") || token.type === \"Keyword\";\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n            let requireSpace;\n\n            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                const parent = context.getAncestors().pop();\n\n                if (parent.type === \"FunctionExpression\" || parent.type === \"FunctionDeclaration\") {\n                    requireSpace = checkFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = checkClasses;\n                } else {\n                    requireSpace = checkKeywords;\n                }\n\n                if (requireSpace) {\n                    if (!hasSpace) {\n                        context.report({\n                            node,\n                            message: \"Missing space before opening brace.\",\n                            fix(fixer) {\n                                return fixer.insertTextBefore(node, \" \");\n                            }\n                        });\n                    }\n                } else {\n                    if (hasSpace) {\n                        context.report({\n                            node,\n                            message: \"Unexpected space before opening brace.\",\n                            fix(fixer) {\n                                return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/space-before-function-paren.js":"/**\n * @fileoverview Rule to validate spacing before function paren.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            anonymous: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            named: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            },\n                            asyncArrow: {\n                                enum: [\"always\", \"never\", \"ignore\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n\n        /**\n         * Determines whether a function has a name.\n         * @param {ASTNode} node The function node.\n         * @returns {boolean} Whether the function has a name.\n         */\n        function isNamedFunction(node) {\n            if (node.id) {\n                return true;\n            }\n\n            const parent = node.parent;\n\n            return parent.type === \"MethodDefinition\" ||\n                (parent.type === \"Property\" &&\n                    (\n                        parent.kind === \"get\" ||\n                        parent.kind === \"set\" ||\n                        parent.method\n                    )\n                );\n        }\n\n        /**\n         * Gets the config for a given function\n         * @param {ASTNode} node The function node\n         * @returns {string} \"always\", \"never\", or \"ignore\"\n         */\n        function getConfigForFunction(node) {\n            if (node.type === \"ArrowFunctionExpression\") {\n\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\n\n                    // For backwards compatibility, the base config does not apply to async arrow functions.\n                    return overrideConfig.asyncArrow || \"ignore\";\n                }\n            } else if (isNamedFunction(node)) {\n                return overrideConfig.named || baseConfig;\n\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n            } else if (!node.generator) {\n                return overrideConfig.anonymous || baseConfig;\n            }\n\n            return \"ignore\";\n        }\n\n        /**\n         * Checks the parens of a function node\n         * @param {ASTNode} node A function node\n         * @returns {void}\n         */\n        function checkFunction(node) {\n            const functionConfig = getConfigForFunction(node);\n\n            if (functionConfig === \"ignore\") {\n                return;\n            }\n\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const leftToken = sourceCode.getTokenBefore(rightToken);\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n            if (hasSpacing && functionConfig === \"never\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Unexpected space before function parentheses.\",\n                    fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])\n                });\n            } else if (!hasSpacing && functionConfig === \"always\") {\n                context.report({\n                    node,\n                    loc: leftToken.loc.end,\n                    message: \"Missing space before function parentheses.\",\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n                });\n            }\n        }\n\n        return {\n            ArrowFunctionExpression: checkFunction,\n            FunctionDeclaration: checkFunction,\n            FunctionExpression: checkFunction\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/space-in-parens.js":"/**\n * @fileoverview Disallows or enforces spaces inside of parentheses.\n * @author Jonathan Rajavuori\n */\n\"use strict\";\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing inside parentheses\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const MISSING_SPACE_MESSAGE = \"There must be a space inside this paren.\",\n            REJECTED_SPACE_MESSAGE = \"There should be no spaces inside this paren.\",\n            ALWAYS = context.options[0] === \"always\",\n\n            exceptionsArrayOptions = (context.options.length === 2) ? context.options[1].exceptions : [],\n            options = {};\n        let exceptions;\n\n        if (exceptionsArrayOptions.length) {\n            options.braceException = exceptionsArrayOptions.indexOf(\"{}\") !== -1;\n            options.bracketException = exceptionsArrayOptions.indexOf(\"[]\") !== -1;\n            options.parenException = exceptionsArrayOptions.indexOf(\"()\") !== -1;\n            options.empty = exceptionsArrayOptions.indexOf(\"empty\") !== -1;\n        }\n\n        /**\n         * Produces an object with the opener and closer exception values\n         * @param {Object} opts The exception options\n         * @returns {Object} `openers` and `closers` exception values\n         * @private\n         */\n        function getExceptions() {\n            const openers = [],\n                closers = [];\n\n            if (options.braceException) {\n                openers.push(\"{\");\n                closers.push(\"}\");\n            }\n\n            if (options.bracketException) {\n                openers.push(\"[\");\n                closers.push(\"]\");\n            }\n\n            if (options.parenException) {\n                openers.push(\"(\");\n                closers.push(\")\");\n            }\n\n            if (options.empty) {\n                openers.push(\")\");\n                closers.push(\"(\");\n            }\n\n            return {\n                openers,\n                closers\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if a token is one of the exceptions for the opener paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\n         */\n        function isOpenerException(token) {\n            return token.type === \"Punctuator\" && exceptions.openers.indexOf(token.value) >= 0;\n        }\n\n        /**\n         * Determines if a token is one of the exceptions for the closer paren\n         * @param {Object} token The token to check\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\n         */\n        function isCloserException(token) {\n            return token.type === \"Punctuator\" && exceptions.closers.indexOf(token.value) >= 0;\n        }\n\n        /**\n         * Determines if an opener paren should have a missing space after it\n         * @param {Object} left The paren token\n         * @param {Object} right The token after it\n         * @returns {boolean} True if the paren should have a space\n         */\n        function shouldOpenerHaveSpace(left, right) {\n            if (sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                if (astUtils.isClosingParenToken(right)) {\n                    return false;\n                }\n                return !isOpenerException(right);\n            }\n            return isOpenerException(right);\n\n        }\n\n        /**\n         * Determines if an closer paren should have a missing space after it\n         * @param {Object} left The token before the paren\n         * @param {Object} right The paren token\n         * @returns {boolean} True if the paren should have a space\n         */\n        function shouldCloserHaveSpace(left, right) {\n            if (astUtils.isOpeningParenToken(left)) {\n                return false;\n            }\n\n            if (sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return !isCloserException(left);\n            }\n            return isCloserException(left);\n\n        }\n\n        /**\n         * Determines if an opener paren should not have an existing space after it\n         * @param {Object} left The paren token\n         * @param {Object} right The token after it\n         * @returns {boolean} True if the paren should reject the space\n         */\n        function shouldOpenerRejectSpace(left, right) {\n            if (right.type === \"Line\") {\n                return false;\n            }\n\n            if (!astUtils.isTokenOnSameLine(left, right)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isOpenerException(right);\n            }\n            return !isOpenerException(right);\n\n        }\n\n        /**\n         * Determines if an closer paren should not have an existing space after it\n         * @param {Object} left The token before the paren\n         * @param {Object} right The paren token\n         * @returns {boolean} True if the paren should reject the space\n         */\n        function shouldCloserRejectSpace(left, right) {\n            if (astUtils.isOpeningParenToken(left)) {\n                return false;\n            }\n\n            if (!astUtils.isTokenOnSameLine(left, right)) {\n                return false;\n            }\n\n            if (!sourceCode.isSpaceBetweenTokens(left, right)) {\n                return false;\n            }\n\n            if (ALWAYS) {\n                return isCloserException(left);\n            }\n            return !isCloserException(left);\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function checkParenSpaces(node) {\n                exceptions = getExceptions();\n                const tokens = sourceCode.tokensAndComments;\n\n                tokens.forEach((token, i) => {\n                    const prevToken = tokens[i - 1];\n                    const nextToken = tokens[i + 1];\n\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n                        return;\n                    }\n\n                    if (token.value === \"(\" && shouldOpenerHaveSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: MISSING_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.insertTextAfter(token, \" \");\n                            }\n                        });\n                    } else if (token.value === \"(\" && shouldOpenerRejectSpace(token, nextToken)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: REJECTED_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                            }\n                        });\n                    } else if (token.value === \")\" && shouldCloserHaveSpace(prevToken, token)) {\n\n                        // context.report(node, token.loc.start, MISSING_SPACE_MESSAGE);\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: MISSING_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    } else if (token.value === \")\" && shouldCloserRejectSpace(prevToken, token)) {\n                        context.report({\n                            node,\n                            loc: token.loc.start,\n                            message: REJECTED_SPACE_MESSAGE,\n                            fix(fixer) {\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/space-infix-ops.js":"/**\n * @fileoverview Require spaces around infix operators\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require spacing around infix operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    int32Hint: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n\n        const OPERATORS = [\n            \"*\", \"/\", \"%\", \"+\", \"-\", \"<<\", \">>\", \">>>\", \"<\", \"<=\", \">\", \">=\", \"in\",\n            \"instanceof\", \"==\", \"!=\", \"===\", \"!==\", \"&\", \"^\", \"|\", \"&&\", \"||\", \"=\",\n            \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"&=\", \"^=\", \"|=\",\n            \"?\", \":\", \",\", \"**\"\n        ];\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Returns the first token which violates the rule\n         * @param {ASTNode} left - The left node of the main node\n         * @param {ASTNode} right - The right node of the main node\n         * @returns {Object} The violator token or null\n         * @private\n         */\n        function getFirstNonSpacedToken(left, right) {\n            const tokens = sourceCode.getTokensBetween(left, right, 1);\n\n            for (let i = 1, l = tokens.length - 1; i < l; ++i) {\n                const op = tokens[i];\n\n                if (\n                    (op.type === \"Punctuator\" || op.type === \"Keyword\") &&\n                    OPERATORS.indexOf(op.value) >= 0 &&\n                    (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])\n                ) {\n                    return op;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Reports an AST node as a rule violation\n         * @param {ASTNode} mainNode - The node to report\n         * @param {Object} culpritToken - The token which has a problem\n         * @returns {void}\n         * @private\n         */\n        function report(mainNode, culpritToken) {\n            context.report({\n                node: mainNode,\n                loc: culpritToken.loc.start,\n                message: \"Infix operators must be spaced.\",\n                fix(fixer) {\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\n                    let fixString = \"\";\n\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\n                        fixString = \" \";\n                    }\n\n                    fixString += culpritToken.value;\n\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\n                        fixString += \" \";\n                    }\n\n                    return fixer.replaceText(culpritToken, fixString);\n                }\n            });\n        }\n\n        /**\n         * Check if the node is binary then report\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkBinary(node) {\n            if (node.left.typeAnnotation) {\n                return;\n            }\n\n            const nonSpacedNode = getFirstNonSpacedToken(node.left, node.right);\n\n            if (nonSpacedNode) {\n                if (!(int32Hint && sourceCode.getText(node).substr(-2) === \"|0\")) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        /**\n         * Check if the node is conditional\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkConditional(node) {\n            const nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);\n\n            if (nonSpacedConsequesntNode) {\n                report(node, nonSpacedConsequesntNode);\n            } else if (nonSpacedAlternateNode) {\n                report(node, nonSpacedAlternateNode);\n            }\n        }\n\n        /**\n         * Check if the node is a variable\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkVar(node) {\n            if (node.init) {\n                const nonSpacedNode = getFirstNonSpacedToken(node.id, node.init);\n\n                if (nonSpacedNode) {\n                    report(node, nonSpacedNode);\n                }\n            }\n        }\n\n        return {\n            AssignmentExpression: checkBinary,\n            AssignmentPattern: checkBinary,\n            BinaryExpression: checkBinary,\n            LogicalExpression: checkBinary,\n            ConditionalExpression: checkConditional,\n            VariableDeclarator: checkVar\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/space-unary-ops.js":"/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\"\n                    },\n                    nonwords: {\n                        type: \"boolean\"\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n        * @param {ASTnode} node AST node\n        * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n        */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n        * Check if the node's child argument is an \"ObjectExpression\"\n        * @param {ASTnode} node AST node\n        * @returns {boolean} Whether or not the argument's type is \"ObjectExpression\"\n        */\n        function isArgumentObjectExpression(node) {\n            return node.argument && node.argument.type && node.argument.type === \"ObjectExpression\";\n        }\n\n        /**\n         * Check if it is safe to remove the spaces between the two tokens in\n         * the context of a non-word prefix unary operator. For example, `+ +1`\n         * cannot safely be changed to `++1`.\n         * @param {Token} firstToken The operator for a non-word prefix unary operator\n         * @param {Token} secondToken The first token of its operand\n         * @returns {boolean} Whether or not the spacing between the tokens can be removed\n         */\n        function canRemoveSpacesBetween(firstToken, secondToken) {\n            return !(\n                (firstToken.value === \"+\" && secondToken.value[0] === \"+\") ||\n                (firstToken.value === \"-\" && secondToken.value[0] === \"-\")\n            );\n        }\n\n        /**\n        * Checks if an override exists for a given operator.\n        * @param {ASTnode} node AST node\n        * @param {string} operator Operator\n        * @returns {boolean} Whether or not an override has been provided for the operator\n        */\n        function overrideExistsForOperator(node, operator) {\n            return options.overrides && options.overrides.hasOwnProperty(operator);\n        }\n\n        /**\n        * Gets the value that the override was set to for this operator\n        * @param {ASTnode} node AST node\n        * @param {string} operator Operator\n        * @returns {boolean} Whether or not an override enforces a space with this operator\n        */\n        function overrideEnforcesSpaces(node, operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n        * Verify Unary Word Operator has spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken first token from the AST node\n        * @param {Object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node,\n                    message: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n                    data: {\n                        word\n                    },\n                    fix(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n        * Verify Unary Word Operator doesn't have spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken first token from the AST node\n        * @param {Object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (isArgumentObjectExpression(node)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space after unary word operator '{{word}}'.\",\n                        data: {\n                            word\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Check Unary Word Operators for spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken first token from the AST node\n        * @param {Object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            word = word || firstToken.value;\n\n            if (overrideExistsForOperator(node, word)) {\n                if (overrideEnforcesSpaces(node, word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n        * Verifies YieldExpressions satisfy spacing requirements\n        * @param {ASTnode} node AST node\n        * @returns {void}\n        */\n        function checkForSpacesAfterYield(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n        * Verifies AwaitExpressions satisfy spacing requirements\n        * @param {ASTNode} node AwaitExpression AST node\n        * @returns {void}\n        */\n        function checkForSpacesAfterAwait(node) {\n            const tokens = sourceCode.getFirstTokens(node, 3);\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken First token in the expression\n        * @param {Object} secondToken Second token in the expression\n        * @returns {void}\n        */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        message: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node,\n                        message: \"Space is required before unary expressions '{{token}}'.\",\n                        data: {\n                            token: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n        * @param {ASTnode} node AST node\n        * @param {Object} firstToken First token in the expression\n        * @param {Object} secondToken Second token in the expression\n        * @returns {void}\n        */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space after unary operator '{{operator}}'.\",\n                        data: {\n                            operator: firstToken.value\n                        },\n                        fix(fixer) {\n                            if (canRemoveSpacesBetween(firstToken, secondToken)) {\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                            }\n                            return null;\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node,\n                        message: \"Unexpected space before unary operator '{{operator}}'.\",\n                        data: {\n                            operator: secondToken.value\n                        },\n                        fix(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n        * @param {ASTnode} node AST node\n        * @returns {void}\n        */\n        function checkForSpaces(node) {\n            const tokens = sourceCode.getFirstTokens(node, 2),\n                firstToken = tokens[0],\n                secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);\n                return;\n            }\n\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(node, operator)) {\n                if (overrideEnforcesSpaces(node, operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield,\n            AwaitExpression: checkForSpacesAfterAwait\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/spaced-comment.js":"/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nconst lodash = require(\"lodash\");\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    const isOneChar = s.length === 1;\n\n    s = lodash.escapeRegExp(s);\n    return isOneChar ? s : `(?:${s})`;\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return `${escape(s)}+`;\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] - A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n    markers = markers ? markers.slice(0) : [];\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        markers.push(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates string pattern for exceptions.\n * Generated pattern:\n *\n * 1. A space or an exception pattern sequence.\n *\n * @param {string[]} exceptions - An exception pattern list.\n * @returns {string} A regular expression string for exceptions.\n */\nfunction createExceptionsPattern(exceptions) {\n    let pattern = \"\";\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of the exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n    }\n\n    return pattern;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n *\n * @param {string[]} markers - A marker list.\n * @param {string[]} exceptions - An exception pattern list.\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    let pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n    pattern += createExceptionsPattern(exceptions);\n\n    return new RegExp(pattern);\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern for beginning of comment:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n *\n * @param {string[]} markers - A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n\n    return new RegExp(pattern);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            balanced: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Unless the first option is never, require a space\n        const requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        const config = context.options[1] || {};\n        const balanced = config.block && config.block.balanced;\n\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers);\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n            const endNeverPattern = \"[ \\t]+$\";\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern),\n                hasExceptions: exceptions.length > 0,\n                markers: new RegExp(`^(${markers.map(escape).join(\"|\")})`)\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a beginning spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report.\n         * @param {Array} match - An array of match results for markers.\n         * @param {string} refChar - Character used for reference in the error message.\n         * @returns {void}\n         */\n        function reportBegin(node, message, match, refChar) {\n            const type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node,\n                fix(fixer) {\n                    const start = node.range[0];\n                    let end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    }\n                    end += match[0].length;\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n\n                },\n                message,\n                data: { refChar }\n            });\n        }\n\n        /**\n         * Reports an ending spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report.\n         * @param {string} match - An array of the matched whitespace characters.\n         * @returns {void}\n         */\n        function reportEnd(node, message, match) {\n            context.report({\n                node,\n                fix(fixer) {\n                    if (requireSpace) {\n                        return fixer.insertTextAfterRange([node.start, node.end - 2], \" \");\n                    }\n                    const end = node.end - 2,\n                        start = end - match[0].length;\n\n                    return fixer.replaceTextRange([start, end], \"\");\n\n                },\n                message\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node - a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            const type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments.\n            if (node.value.length === 0) {\n                return;\n            }\n\n            const beginMatch = rule.beginRegex.exec(node.value);\n            const endMatch = rule.endRegex.exec(node.value);\n\n            // Checks.\n            if (requireSpace) {\n                if (!beginMatch) {\n                    const hasMarker = rule.markers.exec(node.value);\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        reportBegin(node, \"Expected exception block, space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    } else {\n                        reportBegin(node, \"Expected space or tab after '{{refChar}}' in comment.\", hasMarker, marker);\n                    }\n                }\n\n                if (balanced && type === \"block\" && !endMatch) {\n                    reportEnd(node, \"Expected space or tab before '*/' in comment.\");\n                }\n            } else {\n                if (beginMatch) {\n                    if (!beginMatch[1]) {\n                        reportBegin(node, \"Unexpected space or tab after '{{refChar}}' in comment.\", beginMatch, commentIdentifier);\n                    } else {\n                        reportBegin(node, \"Unexpected space or tab after marker ({{refChar}}) in comment.\", beginMatch, beginMatch[1]);\n                    }\n                }\n\n                if (balanced && type === \"block\" && endMatch) {\n                    reportEnd(node, \"Unexpected space or tab before '*/' in comment.\", endMatch);\n                }\n            }\n        }\n\n        return {\n\n            LineComment: checkCommentForSpace,\n            BlockComment: checkCommentForSpace\n\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/strict.js":"/**\n * @fileoverview Rule to control usage of strict mode directives.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst messages = {\n    function: \"Use the function form of 'use strict'.\",\n    global: \"Use the global form of 'use strict'.\",\n    multiple: \"Multiple 'use strict' directives.\",\n    never: \"Strict mode is not permitted.\",\n    unnecessary: \"Unnecessary 'use strict' directive.\",\n    module: \"'use strict' is unnecessary inside of modules.\",\n    implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n    unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n    nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n    wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n};\n\n/**\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\n * statements.\n * @param {ASTNode[]} statements Statements in the program or function body.\n * @returns {ASTNode[]} All of the Use Strict Directives.\n */\nfunction getUseStrictDirectives(statements) {\n    const directives = [];\n\n    for (let i = 0; i < statements.length; i++) {\n        const statement = statements[i];\n\n        if (\n            statement.type === \"ExpressionStatement\" &&\n            statement.expression.type === \"Literal\" &&\n            statement.expression.value === \"use strict\"\n        ) {\n            directives[i] = statement;\n        } else {\n            break;\n        }\n    }\n\n    return directives;\n}\n\n/**\n * Checks whether a given parameter is a simple parameter.\n *\n * @param {ASTNode} node - A pattern node to check.\n * @returns {boolean} `true` if the node is an Identifier node.\n */\nfunction isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n}\n\n/**\n * Checks whether a given parameter list is a simple parameter list.\n *\n * @param {ASTNode[]} params - A parameter list to check.\n * @returns {boolean} `true` if the every parameter is an Identifier node.\n */\nfunction isSimpleParameterList(params) {\n    return params.every(isSimpleParameter);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow strict mode directives\",\n            category: \"Strict Mode\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n            scopes = [],\n            classScopes = [];\n        let mode = context.options[0] || \"safe\";\n\n        if (ecmaFeatures.impliedStrict) {\n            mode = \"implied\";\n        } else if (mode === \"safe\") {\n            mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\n        }\n\n        /**\n        * Determines whether a reported error should be fixed, depending on the error type.\n        * @param {string} errorType The type of error\n        * @returns {boolean} `true` if the reported error should be fixed\n        */\n        function shouldFix(errorType) {\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n        }\n\n        /**\n        * Gets a fixer function to remove a given 'use strict' directive.\n        * @param {ASTNode} node The directive that should be removed\n        * @returns {Function} A fixer function\n        */\n        function getFixFunction(node) {\n            return fixer => fixer.remove(node);\n        }\n\n        /**\n         * Report a slice of an array of nodes with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} start Index to start from.\n         * @param {string} end Index to end before.\n         * @param {string} message Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportSlice(nodes, start, end, message, fix) {\n            nodes.slice(start, end).forEach(node => {\n                context.report({ node, message, fix: fix ? getFixFunction(node) : null });\n            });\n        }\n\n        /**\n         * Report all nodes in an array with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} message Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAll(nodes, message, fix) {\n            reportSlice(nodes, 0, nodes.length, message, fix);\n        }\n\n        /**\n         * Report all nodes in an array, except the first, with a given message.\n         * @param {ASTNode[]} nodes Nodes.\n         * @param {string} message Message to display.\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\n         * @returns {void}\n         */\n        function reportAllExceptFirst(nodes, message, fix) {\n            reportSlice(nodes, 1, nodes.length, message, fix);\n        }\n\n        /**\n         * Entering a function in 'function' mode pushes a new nested scope onto the\n         * stack. The new scope is true if the nested function is strict mode code.\n         * @param {ASTNode} node The function declaration or expression.\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\n         * @returns {void}\n         */\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\n            const isInClass = classScopes.length > 0,\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n                isStrict = useStrictDirectives.length > 0;\n\n            if (isStrict) {\n                if (!isSimpleParameterList(node.params)) {\n                    context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });\n                } else if (isParentStrict) {\n                    context.report({ node: useStrictDirectives[0], message: messages.unnecessary, fix: getFixFunction(useStrictDirectives[0]) });\n                } else if (isInClass) {\n                    context.report({ node: useStrictDirectives[0], message: messages.unnecessaryInClasses, fix: getFixFunction(useStrictDirectives[0]) });\n                }\n\n                reportAllExceptFirst(useStrictDirectives, messages.multiple, true);\n            } else if (isParentGlobal) {\n                if (isSimpleParameterList(node.params)) {\n                    context.report({ node, message: messages.function });\n                } else {\n                    context.report({\n                        node,\n                        message: messages.wrap,\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\n                    });\n                }\n            }\n\n            scopes.push(isParentStrict || isStrict);\n        }\n\n        /**\n         * Exiting a function in 'function' mode pops its scope off the stack.\n         * @returns {void}\n         */\n        function exitFunctionInFunctionMode() {\n            scopes.pop();\n        }\n\n        /**\n         * Enter a function and either:\n         * - Push a new nested scope onto the stack (in 'function' mode).\n         * - Report all the Use Strict Directives (in the other modes).\n         * @param {ASTNode} node The function declaration or expression.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n            const isBlock = node.body.type === \"BlockStatement\",\n                useStrictDirectives = isBlock\n                    ? getUseStrictDirectives(node.body.body) : [];\n\n            if (mode === \"function\") {\n                enterFunctionInFunctionMode(node, useStrictDirectives);\n            } else if (useStrictDirectives.length > 0) {\n                if (isSimpleParameterList(node.params)) {\n                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));\n                } else {\n                    context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });\n                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);\n                }\n            }\n        }\n\n        const rule = {\n            Program(node) {\n                const useStrictDirectives = getUseStrictDirectives(node.body);\n\n                if (node.sourceType === \"module\") {\n                    mode = \"module\";\n                }\n\n                if (mode === \"global\") {\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\n                        context.report({ node, message: messages.global });\n                    }\n                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);\n                } else {\n                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));\n                }\n            },\n            FunctionDeclaration: enterFunction,\n            FunctionExpression: enterFunction,\n            ArrowFunctionExpression: enterFunction\n        };\n\n        if (mode === \"function\") {\n            Object.assign(rule, {\n\n                // Inside of class bodies are always strict mode.\n                ClassBody() {\n                    classScopes.push(true);\n                },\n                \"ClassBody:exit\"() {\n                    classScopes.pop();\n                },\n\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n            });\n        }\n\n        return rule;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/symbol-description.js":"/**\n * @fileoverview Rule to enforce description with the `Symbol` object\n * @author Jarek Rencz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require symbol descriptions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /**\n         * Reports if node does not conform the rule in case rule is set to\n         * report missing description\n         *\n         * @param {ASTNode} node - A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArgument(node) {\n            if (node.arguments.length === 0) {\n                context.report({\n                    node,\n                    message: \"Expected Symbol to have a description.\"\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                const variable = astUtils.getVariableByName(scope, \"Symbol\");\n\n                if (variable && variable.defs.length === 0) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArgument(node.parent);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/template-curly-spacing.js":"/**\n * @fileoverview Rule to enforce spacing around embedded expressions of template strings\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst OPEN_PAREN = /\\$\\{$/;\nconst CLOSE_PAREN = /^\\}/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing around embedded expressions of template strings\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const always = context.options[0] === \"always\";\n        const prefix = always ? \"Expected\" : \"Unexpected\";\n\n        /**\n         * Checks spacing before `}` of a given token.\n         * @param {Token} token - A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token) {\n            const prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                CLOSE_PAREN.test(token.value) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token) !== always\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"{{prefix}} space(s) before '}'.\",\n                    data: {\n                        prefix\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextBefore(token, \" \");\n                        }\n                        return fixer.removeRange([\n                            prevToken.range[1],\n                            token.range[0]\n                        ]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Checks spacing after `${` of a given token.\n         * @param {Token} token - A token to check. This is a Template token.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token) {\n            const nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                OPEN_PAREN.test(token.value) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken) !== always\n            ) {\n                context.report({\n                    loc: {\n                        line: token.loc.end.line,\n                        column: token.loc.end.column - 2\n                    },\n                    message: \"{{prefix}} space(s) after '${'.\",\n                    data: {\n                        prefix\n                    },\n                    fix(fixer) {\n                        if (always) {\n                            return fixer.insertTextAfter(token, \" \");\n                        }\n                        return fixer.removeRange([\n                            token.range[1],\n                            nextToken.range[0]\n                        ]);\n                    }\n                });\n            }\n        }\n\n        return {\n            TemplateElement(node) {\n                const token = sourceCode.getFirstToken(node);\n\n                checkSpacingBefore(token);\n                checkSpacingAfter(token);\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/template-tag-spacing.js":"/**\n * @fileoverview Rule to check spacing between template tags and their literals\n * @author Jonathan Wilsson\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing between template tags and their literals\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            { enum: [\"always\", \"never\"] }\n        ]\n    },\n\n    create(context) {\n        const never = context.options[0] !== \"always\";\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if a space is present between a template tag and its literal\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function checkSpacing(node) {\n            const tagToken = sourceCode.getTokenBefore(node.quasi);\n            const literalToken = sourceCode.getFirstToken(node.quasi);\n            const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);\n\n            if (never && hasWhitespace) {\n                context.report({\n                    node,\n                    loc: tagToken.loc.start,\n                    message: \"Unexpected space between template tag and template literal.\",\n                    fix(fixer) {\n                        const comments = sourceCode.getComments(node.quasi).leading;\n\n                        // Don't fix anything if there's a single line comment after the template tag\n                        if (comments.some(comment => comment.type === \"Line\")) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange(\n                            [tagToken.range[1], literalToken.range[0]],\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\n                        );\n                    }\n                });\n            } else if (!never && !hasWhitespace) {\n                context.report({\n                    node,\n                    loc: tagToken.loc.start,\n                    message: \"Missing space between template tag and template literal.\",\n                    fix(fixer) {\n                        return fixer.insertTextAfter(tagToken, \" \");\n                    }\n                });\n            }\n        }\n\n        return {\n            TaggedTemplateExpression: checkSpacing\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/unicode-bom.js":"/**\n * @fileoverview Require or disallow Unicode BOM\n * @author Andrew Johnston <https://github.com/ehjay>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow Unicode byte order mark (BOM)\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkUnicodeBOM(node) {\n\n                const sourceCode = context.getSourceCode(),\n                    location = { column: 0, line: 1 },\n                    requireBOM = context.options[0] || \"never\";\n\n                if (!sourceCode.hasBOM && (requireBOM === \"always\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Expected Unicode BOM (Byte Order Mark).\",\n                        fix(fixer) {\n                            return fixer.insertTextBeforeRange([0, 1], \"\\uFEFF\");\n                        }\n                    });\n                } else if (sourceCode.hasBOM && (requireBOM === \"never\")) {\n                    context.report({\n                        node,\n                        loc: location,\n                        message: \"Unexpected Unicode BOM (Byte Order Mark).\",\n                        fix(fixer) {\n                            return fixer.removeRange([-1, 0]);\n                        }\n                    });\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/use-isnan.js":"/**\n * @fileoverview Rule to flag comparisons to the value NaN\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        return {\n            BinaryExpression(node) {\n                if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === \"NaN\" || node.right.name === \"NaN\")) {\n                    context.report({ node, message: \"Use the isNaN function to compare with NaN.\" });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/valid-jsdoc.js":"/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\"\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\"\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\"\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        const fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node)\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            const functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {Object} current and expected type object\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            let currentType;\n\n            if (type.name) {\n                currentType = type.name;\n            } else if (type.expression) {\n                currentType = type.expression.name;\n            }\n\n            const expectedType = currentType && preferType[currentType];\n\n            return {\n                currentType,\n                expectedType\n            };\n        }\n\n        /**\n         * Validate type for a given JSDoc node\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            const typesToCheck = [];\n            let elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\":  // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\":  // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\":  // {String|number|Test}\n                case \"ArrayType\":  // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\":  // Array.<{count: number, votes: number}>\n                    if (type.value) {\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    }\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(typeToCheck => {\n                if (typeToCheck.expectedType &&\n                    typeToCheck.expectedType !== typeToCheck.currentType) {\n                    context.report({\n                        node: jsdocNode,\n                        message: \"Use '{{expectedType}}' instead of '{{currentType}}'.\",\n                        data: {\n                            currentType: typeToCheck.currentType,\n                            expectedType: typeToCheck.expectedType\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            const jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                params = Object.create(null);\n            let hasReturns = false,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false,\n                jsdoc;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/i.test(ex.message)) {\n                        context.report({ node: jsdocNode, message: \"JSDoc type missing brace.\" });\n                    } else {\n                        context.report({ node: jsdocNode, message: \"JSDoc syntax error.\" });\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(tag => {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            if (!tag.type) {\n                                context.report({ node: jsdocNode, message: \"Missing JSDoc parameter type for '{{name}}'.\", data: { name: tag.name } });\n                            }\n\n                            if (!tag.description && requireParamDescription) {\n                                context.report({ node: jsdocNode, message: \"Missing JSDoc parameter description for '{{name}}'.\", data: { name: tag.name } });\n                            }\n\n                            if (params[tag.name]) {\n                                context.report({ node: jsdocNode, message: \"Duplicate JSDoc parameter '{{name}}'.\", data: { name: tag.name } });\n                            } else if (tag.name.indexOf(\".\") === -1) {\n                                params[tag.name] = 1;\n                            }\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n\n                            if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag)) && !isAbstract) {\n                                context.report({\n                                    node: jsdocNode,\n                                    message: \"Unexpected @{{title}} tag; function has no return statement.\",\n                                    data: {\n                                        title: tag.title\n                                    }\n                                });\n                            } else {\n                                if (requireReturnType && !tag.type) {\n                                    context.report({ node: jsdocNode, message: \"Missing JSDoc return type.\" });\n                                }\n\n                                if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {\n                                    context.report({ node: jsdocNode, message: \"Missing JSDoc return description.\" });\n                                }\n                            }\n\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {\n                        context.report({ node: jsdocNode, message: \"Use @{{name}} instead.\", data: { name: prefer[tag.title] } });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || functionData.returnPresent) {\n                        context.report({\n                            node: jsdocNode,\n                            message: \"Missing JSDoc @{{returns}} for function.\",\n                            data: {\n                                returns: prefer.returns || \"returns\"\n                            }\n                        });\n                    }\n                }\n\n                // check the parameters\n                const jsdocParams = Object.keys(params);\n\n                if (node.params) {\n                    node.params.forEach((param, i) => {\n                        if (param.type === \"AssignmentPattern\") {\n                            param = param.left;\n                        }\n\n                        const name = param.name;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (param.type === \"Identifier\") {\n                            if (jsdocParams[i] && (name !== jsdocParams[i])) {\n                                context.report({ node: jsdocNode, message: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\", data: {\n                                    name,\n                                    jsdocName: jsdocParams[i]\n                                } });\n                            } else if (!params[name] && !isOverride) {\n                                context.report({ node: jsdocNode, message: \"Missing JSDoc for parameter '{{name}}'.\", data: {\n                                    name\n                                } });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    const regex = new RegExp(options.matchDescription);\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report({ node: jsdocNode, message: \"JSDoc description does not satisfy the regex pattern.\" });\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/valid-typeof.js":"/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    requireStringLiterals: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n\n        /**\n        * Determines whether a node is a typeof expression.\n        * @param {ASTNode} node The node\n        * @returns {boolean} `true` if the node is a typeof expression\n        */\n        function isTypeofExpression(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression(node) {\n                if (isTypeofExpression(node)) {\n                    const parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        const sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n                            if (VALID_TYPES.indexOf(value) === -1) {\n                                context.report({ node: sibling, message: \"Invalid typeof comparison value.\" });\n                            }\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n                            context.report({ node: sibling, message: \"Typeof comparisons should be to string literals.\" });\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/vars-on-top.js":"/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `var` declarations be placed at the top of their containing scope\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const errorMessage = \"All 'var' declarations must be at the top of the function scope.\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         *\n         * @param {ASTNode} node - any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // skip over directives\n            for (; i < l; ++i) {\n                if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                    break;\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode} parent - Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, message: errorMessage });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node - The node to check\n         * @param {ASTNode} parent - Parent of the node\n         * @param {ASTNode} grandParent - Parent of the node's parent\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node, parent, grandParent) {\n            if (!(/Function/.test(grandParent.type) &&\n                    parent.type === \"BlockStatement\" &&\n                    isVarOnTop(node, parent.body))) {\n                context.report({ node, message: errorMessage });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration(node) {\n                const ancestors = context.getAncestors();\n                let parent = ancestors.pop();\n                let grandParent = ancestors.pop();\n\n                if (node.kind === \"var\") { // check variable is `var` type and not `let` or `const`\n                    if (parent.type === \"ExportNamedDeclaration\") {\n                        node = parent;\n                        parent = grandParent;\n                        grandParent = ancestors.pop();\n                    }\n\n                    if (parent.type === \"Program\") { // That means its a global variable\n                        globalVarCheck(node, parent);\n                    } else {\n                        blockScopeVarCheck(node, parent, grandParent);\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/wrap-iife.js":"/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = (context.options[1] && context.options[1].functionPrototypeMethods) || false;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in ()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped\n         * @private\n         */\n        function wrapped(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n        * Get the function node from an IIFE\n        * @param {ASTNode} node node to evaluate\n        * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n        */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = node.callee;\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const callExpressionWrapped = wrapped(node),\n                    functionExpressionWrapped = wrapped(innerNode);\n\n                if (!callExpressionWrapped && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        message: \"Wrap an immediate function invocation in parentheses.\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !functionExpressionWrapped) {\n                    context.report({\n                        node,\n                        message: \"Wrap only the function expression in parens.\",\n                        fix(fixer) {\n\n                            /*\n                             * The outer call expression will always be wrapped at this point.\n                             * Replace the range between the end of the function expression and the end of the call expression.\n                             * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                             * Replace the parens from the outer expression, and parenthesize the function expression.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(node);\n\n                            return fixer.replaceTextRange(\n                                [innerNode.range[1], parenAfter.range[1]],\n                                `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                            );\n                        }\n                    });\n                } else if (style === \"outside\" && !callExpressionWrapped) {\n                    context.report({\n                        node,\n                        message: \"Move the invocation into the parens that contain the function.\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/wrap-regex.js":"/**\n * @fileoverview Rule to flag when regex literals are not wrapped in parens\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parenthesis around regex literals\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            Literal(node) {\n                const token = sourceCode.getFirstToken(node),\n                    nodeType = token.type;\n\n                if (nodeType === \"RegularExpression\") {\n                    const source = sourceCode.getTokenBefore(node);\n                    const ancestors = context.getAncestors();\n                    const grandparent = ancestors[ancestors.length - 1];\n\n                    if (grandparent.type === \"MemberExpression\" && grandparent.object === node &&\n                        (!source || source.value !== \"(\")) {\n                        context.report({\n                            node,\n                            message: \"Wrap the regexp literal in parens to disambiguate the slash.\",\n                            fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/yield-star-spacing.js":"/**\n * @fileoverview Rule to check the spacing around the * in yield* expressions.\n * @author Bryan Smith\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow spacing around the `*` in `yield*` expressions\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            before: { type: \"boolean\" },\n                            after: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const mode = (function(option) {\n            if (!option || typeof option === \"string\") {\n                return {\n                    before: { before: true, after: false },\n                    after: { before: false, after: true },\n                    both: { before: true, after: true },\n                    neither: { before: false, after: false }\n                }[option || \"after\"];\n            }\n            return option;\n        }(context.options[0]));\n\n        /**\n         * Checks the spacing between two tokens before or after the star token.\n         * @param {string} side Either \"before\" or \"after\".\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\n         *     star token if side is \"after\".\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\n         *     token if side is \"after\".\n         * @returns {void}\n         */\n        function checkSpacing(side, leftToken, rightToken) {\n            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {\n                const after = leftToken.value === \"*\";\n                const spaceRequired = mode[side];\n                const node = after ? leftToken : rightToken;\n                const type = spaceRequired ? \"Missing\" : \"Unexpected\";\n                const message = \"{{type}} space {{side}} *.\";\n\n                context.report({\n                    node,\n                    message,\n                    data: {\n                        type,\n                        side\n                    },\n                    fix(fixer) {\n                        if (spaceRequired) {\n                            if (after) {\n                                return fixer.insertTextAfter(node, \" \");\n                            }\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Enforces the spacing around the star if node is a yield* expression.\n         * @param {ASTNode} node A yield expression node.\n         * @returns {void}\n         */\n        function checkExpression(node) {\n            if (!node.delegate) {\n                return;\n            }\n\n            const tokens = sourceCode.getFirstTokens(node, 3);\n            const yieldToken = tokens[0];\n            const starToken = tokens[1];\n            const nextToken = tokens[2];\n\n            checkSpacing(\"before\", yieldToken, starToken);\n            checkSpacing(\"after\", starToken, nextToken);\n        }\n\n        return {\n            YieldExpression: checkExpression\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/rules/yoda.js":"/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return (/^(==|===)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {string} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction looksLikeLiteral(node) {\n    return (node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        node.argument.type === \"Literal\" &&\n        typeof node.argument.value === \"number\");\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @param {number} [defaultValue] The default value to be returned if the node\n *                                is not a Literal.\n * @returns {ASTNode} One of the following options.\n *  1. The original node if the node is already a Literal\n *  2. A normalized Literal node with the negative number as the value if the\n *     node represents a negative number literal.\n *  3. The Literal node which has the `defaultValue` argument if it exists.\n *  4. Otherwise `null`.\n */\nfunction getNormalizedLiteral(node, defaultValue) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (looksLikeLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: `-${node.argument.value}`\n        };\n    }\n\n    if (defaultValue) {\n        return {\n            type: \"Literal\",\n            value: defaultValue,\n            raw: String(defaultValue)\n        };\n    }\n\n    return null;\n}\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\": {\n            const nameA = astUtils.getStaticPropertyName(a);\n\n            // x.y = x[\"y\"]\n            if (nameA) {\n                return (\n                    same(a.object, b.object) &&\n                    nameA === astUtils.getStaticPropertyName(b)\n                );\n            }\n\n            // x[0] = x[0]\n            // x[y] = x[y]\n            // x.y = x.y\n            return (\n                a.computed === b.computed &&\n                same(a.object, b.object) &&\n                same(a.property, b.property)\n            );\n        }\n\n        case \"ThisExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow \\\"Yoda\\\" conditions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\"\n                    },\n                    onlyEquality: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n\n        // Default to \"never\" (!always) if no option\n        const always = (context.options[0] === \"always\");\n        const exceptRange = (context.options[1] && context.options[1].exceptRange);\n        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            const left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"&&\" &&\n                    (leftLiteral = getNormalizedLiteral(left.left)) &&\n                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.right, right.left));\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                let leftLiteral, rightLiteral;\n\n                return (node.operator === \"||\" &&\n                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&\n                    (rightLiteral = getNormalizedLiteral(right.left)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.left, right.right));\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                return astUtils.isParenthesised(sourceCode, node);\n            }\n\n            return (node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped());\n        }\n\n        const OPERATOR_FLIP_MAP = {\n            \"===\": \"===\",\n            \"!==\": \"!==\",\n            \"==\": \"==\",\n            \"!=\": \"!=\",\n            \"<\": \">\",\n            \">\": \"<\",\n            \"<=\": \">=\",\n            \">=\": \"<=\"\n        };\n\n        /**\n        * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\n        * @param {ASTNode} node The BinaryExpression node\n        * @returns {string} A string representation of the node with the sides and operator flipped\n        */\n        function getFlippedString(node) {\n            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);\n            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);\n            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);\n            const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);\n\n            return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression(node) {\n                const expectedLiteral = always ? node.left : node.right;\n                const expectedNonLiteral = always ? node.right : node.left;\n\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n                if (\n                    (expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) &&\n                    !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report({\n                        node,\n                        message: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\",\n                        data: {\n                            operator: node.operator,\n                            expectedSide: always ? \"left\" : \"right\"\n                        },\n                        fix: fixer => fixer.replaceText(node, getFlippedString(node))\n                    });\n                }\n\n            }\n        };\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/autoconfig.js":"/**\n * @fileoverview Used for creating a suggested configuration based on project code.\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    eslint = require(\"../eslint\"),\n    configRule = require(\"./config-rule\"),\n    ConfigOps = require(\"./config-ops\"),\n    recConfig = require(\"../../conf/eslint-recommended\");\n\nconst debug = require(\"debug\")(\"eslint:autoconfig\");\n\n//------------------------------------------------------------------------------\n// Data\n//------------------------------------------------------------------------------\n\nconst MAX_CONFIG_COMBINATIONS = 17, // 16 combinations + 1 for severity only\n    RECOMMENDED_CONFIG_NAME = \"eslint:recommended\";\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Information about a rule configuration, in the context of a Registry.\n *\n * @typedef {Object}     registryItem\n * @param   {ruleConfig} config        A valid configuration for the rule\n * @param   {number}     specificity   The number of elements in the ruleConfig array\n * @param   {number}     errorCount    The number of errors encountered when linting with the config\n */\n\n /**\n  * This callback is used to measure execution status in a progress bar\n  * @callback progressCallback\n  * @param {number} The total number of times the callback will be called.\n  */\n\n/**\n * Create registryItems for rules\n * @param   {rulesConfig} rulesConfig Hash of rule names and arrays of ruleConfig items\n * @returns {Object}                  registryItems for each rule in provided rulesConfig\n */\nfunction makeRegistryItems(rulesConfig) {\n    return Object.keys(rulesConfig).reduce((accumulator, ruleId) => {\n        accumulator[ruleId] = rulesConfig[ruleId].map(config => ({\n            config,\n            specificity: config.length || 1,\n            errorCount: void 0\n        }));\n        return accumulator;\n    }, {});\n}\n\n/**\n* Creates an object in which to store rule configs and error counts\n*\n* Unless a rulesConfig is provided at construction, the registry will not contain\n* any rules, only methods.  This will be useful for building up registries manually.\n*\n* Registry class\n*/\nclass Registry {\n\n    /**\n     * @param {rulesConfig} [rulesConfig] Hash of rule names and arrays of possible configurations\n     */\n    constructor(rulesConfig) {\n        this.rules = (rulesConfig) ? makeRegistryItems(rulesConfig) : {};\n    }\n\n    /**\n     * Populate the registry with core rule configs.\n     *\n     * It will set the registry's `rule` property to an object having rule names\n     * as keys and an array of registryItems as values.\n     *\n     * @returns {void}\n     */\n    populateFromCoreRules() {\n        const rulesConfig = configRule.createCoreRuleConfigs();\n\n        this.rules = makeRegistryItems(rulesConfig);\n    }\n\n    /**\n     * Creates sets of rule configurations which can be used for linting\n     * and initializes registry errors to zero for those configurations (side effect).\n     *\n     * This combines as many rules together as possible, such that the first sets\n     * in the array will have the highest number of rules configured, and later sets\n     * will have fewer and fewer, as not all rules have the same number of possible\n     * configurations.\n     *\n     * The length of the returned array will be <= MAX_CONFIG_COMBINATIONS.\n     *\n     * @param   {Object}   registry The autoconfig registry\n     * @returns {Object[]}          \"rules\" configurations to use for linting\n     */\n    buildRuleSets() {\n        let idx = 0;\n        const ruleIds = Object.keys(this.rules),\n            ruleSets = [];\n\n        /**\n         * Add a rule configuration from the registry to the ruleSets\n         *\n         * This is broken out into its own function so that it doesn't need to be\n         * created inside of the while loop.\n         *\n         * @param   {string} rule The ruleId to add.\n         * @returns {void}\n         */\n        const addRuleToRuleSet = function(rule) {\n\n            /*\n             * This check ensures that there is a rule configuration and that\n             * it has fewer than the max combinations allowed.\n             * If it has too many configs, we will only use the most basic of\n             * the possible configurations.\n             */\n            const hasFewCombos = (this.rules[rule].length <= MAX_CONFIG_COMBINATIONS);\n\n            if (this.rules[rule][idx] && (hasFewCombos || this.rules[rule][idx].specificity <= 2)) {\n\n                /*\n                 * If the rule has too many possible combinations, only take\n                 * simple ones, avoiding objects.\n                 */\n                if (!hasFewCombos && typeof this.rules[rule][idx].config[1] === \"object\") {\n                    return;\n                }\n\n                ruleSets[idx] = ruleSets[idx] || {};\n                ruleSets[idx][rule] = this.rules[rule][idx].config;\n\n                /*\n                 * Initialize errorCount to zero, since this is a config which\n                 * will be linted.\n                 */\n                this.rules[rule][idx].errorCount = 0;\n            }\n        }.bind(this);\n\n        while (ruleSets.length === idx) {\n            ruleIds.forEach(addRuleToRuleSet);\n            idx += 1;\n        }\n\n        return ruleSets;\n    }\n\n    /**\n     * Remove all items from the registry with a non-zero number of errors\n     *\n     * Note: this also removes rule configurations which were not linted\n     * (meaning, they have an undefined errorCount).\n     *\n     * @returns {void}\n     */\n    stripFailingConfigs() {\n        const ruleIds = Object.keys(this.rules),\n            newRegistry = new Registry();\n\n        newRegistry.rules = Object.assign({}, this.rules);\n        ruleIds.forEach(ruleId => {\n            const errorFreeItems = newRegistry.rules[ruleId].filter(registryItem => (registryItem.errorCount === 0));\n\n            if (errorFreeItems.length > 0) {\n                newRegistry.rules[ruleId] = errorFreeItems;\n            } else {\n                delete newRegistry.rules[ruleId];\n            }\n        });\n\n        return newRegistry;\n    }\n\n    /**\n     * Removes rule configurations which were not included in a ruleSet\n     *\n     * @returns {void}\n     */\n    stripExtraConfigs() {\n        const ruleIds = Object.keys(this.rules),\n            newRegistry = new Registry();\n\n        newRegistry.rules = Object.assign({}, this.rules);\n        ruleIds.forEach(ruleId => {\n            newRegistry.rules[ruleId] = newRegistry.rules[ruleId].filter(registryItem => (typeof registryItem.errorCount !== \"undefined\"));\n        });\n\n        return newRegistry;\n    }\n\n    /**\n     * Creates a registry of rules which had no error-free configs.\n     * The new registry is intended to be analyzed to determine whether its rules\n     * should be disabled or set to warning.\n     *\n     * @returns {Registry}  A registry of failing rules.\n     */\n    getFailingRulesRegistry() {\n        const ruleIds = Object.keys(this.rules),\n            failingRegistry = new Registry();\n\n        ruleIds.forEach(ruleId => {\n            const failingConfigs = this.rules[ruleId].filter(registryItem => (registryItem.errorCount > 0));\n\n            if (failingConfigs && failingConfigs.length === this.rules[ruleId].length) {\n                failingRegistry.rules[ruleId] = failingConfigs;\n            }\n        });\n\n        return failingRegistry;\n    }\n\n    /**\n     * Create an eslint config for any rules which only have one configuration\n     * in the registry.\n     *\n     * @returns {Object} An eslint config with rules section populated\n     */\n    createConfig() {\n        const ruleIds = Object.keys(this.rules),\n            config = { rules: {} };\n\n        ruleIds.forEach(ruleId => {\n            if (this.rules[ruleId].length === 1) {\n                config.rules[ruleId] = this.rules[ruleId][0].config;\n            }\n        });\n\n        return config;\n    }\n\n    /**\n     * Return a cloned registry containing only configs with a desired specificity\n     *\n     * @param   {number} specificity Only keep configs with this specificity\n     * @returns {Registry}           A registry of rules\n     */\n    filterBySpecificity(specificity) {\n        const ruleIds = Object.keys(this.rules),\n            newRegistry = new Registry();\n\n        newRegistry.rules = Object.assign({}, this.rules);\n        ruleIds.forEach(ruleId => {\n            newRegistry.rules[ruleId] = this.rules[ruleId].filter(registryItem => (registryItem.specificity === specificity));\n        });\n\n        return newRegistry;\n    }\n\n    /**\n     * Lint SourceCodes against all configurations in the registry, and record results\n     *\n     * @param   {Object[]} sourceCodes  SourceCode objects for each filename\n     * @param   {Object}   config       ESLint config object\n     * @param   {progressCallback} [cb] Optional callback for reporting execution status\n     * @returns {Registry}              New registry with errorCount populated\n     */\n    lintSourceCode(sourceCodes, config, cb) {\n        let ruleSetIdx,\n            lintedRegistry;\n\n        lintedRegistry = new Registry();\n        lintedRegistry.rules = Object.assign({}, this.rules);\n\n        const ruleSets = lintedRegistry.buildRuleSets();\n\n        lintedRegistry = lintedRegistry.stripExtraConfigs();\n\n        debug(\"Linting with all possible rule combinations\");\n\n        const filenames = Object.keys(sourceCodes);\n        const totalFilesLinting = filenames.length * ruleSets.length;\n\n        filenames.forEach(filename => {\n            debug(`Linting file: ${filename}`);\n\n            ruleSetIdx = 0;\n\n            ruleSets.forEach(ruleSet => {\n                const lintConfig = Object.assign({}, config, { rules: ruleSet });\n                const lintResults = eslint.verify(sourceCodes[filename], lintConfig);\n\n                lintResults.forEach(result => {\n\n                    // It is possible that the error is from a configuration comment\n                    // in a linted file, in which case there may not be a config\n                    // set in this ruleSetIdx.\n                    // (https://github.com/eslint/eslint/issues/5992)\n                    // (https://github.com/eslint/eslint/issues/7860)\n                    if (\n                        lintedRegistry.rules[result.ruleId] &&\n                        lintedRegistry.rules[result.ruleId][ruleSetIdx]\n                    ) {\n                        lintedRegistry.rules[result.ruleId][ruleSetIdx].errorCount += 1;\n                    }\n                });\n\n                ruleSetIdx += 1;\n\n                if (cb) {\n                    cb(totalFilesLinting);  // eslint-disable-line callback-return\n                }\n            });\n\n            // Deallocate for GC\n            sourceCodes[filename] = null;\n        });\n\n        return lintedRegistry;\n    }\n}\n\n/**\n * Extract rule configuration into eslint:recommended where possible.\n *\n * This will return a new config with `\"extends\": \"eslint:recommended\"` and\n * only the rules which have configurations different from the recommended config.\n *\n * @param   {Object} config config object\n * @returns {Object}        config object using `\"extends\": \"eslint:recommended\"`\n */\nfunction extendFromRecommended(config) {\n    const newConfig = Object.assign({}, config);\n\n    ConfigOps.normalizeToStrings(newConfig);\n\n    const recRules = Object.keys(recConfig.rules).filter(ruleId => ConfigOps.isErrorSeverity(recConfig.rules[ruleId]));\n\n    recRules.forEach(ruleId => {\n        if (lodash.isEqual(recConfig.rules[ruleId], newConfig.rules[ruleId])) {\n            delete newConfig.rules[ruleId];\n        }\n    });\n    newConfig.extends = RECOMMENDED_CONFIG_NAME;\n    return newConfig;\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    Registry,\n    extendFromRecommended\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/config-rule.js":"/**\n * @fileoverview Create configurations for a rule\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst rules = require(\"../rules\"),\n    loadRules = require(\"../load-rules\");\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Wrap all of the elements of an array into arrays.\n * @param   {*[]}     xs Any array.\n * @returns {Array[]}    An array of arrays.\n */\nfunction explodeArray(xs) {\n    return xs.reduce((accumulator, x) => {\n        accumulator.push([x]);\n        return accumulator;\n    }, []);\n}\n\n/**\n * Mix two arrays such that each element of the second array is concatenated\n * onto each element of the first array.\n *\n * For example:\n * combineArrays([a, [b, c]], [x, y]); // -> [[a, x], [a, y], [b, c, x], [b, c, y]]\n *\n * @param   {array} arr1 The first array to combine.\n * @param   {array} arr2 The second array to combine.\n * @returns {array}      A mixture of the elements of the first and second arrays.\n */\nfunction combineArrays(arr1, arr2) {\n    const res = [];\n\n    if (arr1.length === 0) {\n        return explodeArray(arr2);\n    }\n    if (arr2.length === 0) {\n        return explodeArray(arr1);\n    }\n    arr1.forEach(x1 => {\n        arr2.forEach(x2 => {\n            res.push([].concat(x1, x2));\n        });\n    });\n    return res;\n}\n\n/**\n * Group together valid rule configurations based on object properties\n *\n * e.g.:\n * groupByProperty([\n *     {before: true},\n *     {before: false},\n *     {after: true},\n *     {after: false}\n * ]);\n *\n * will return:\n * [\n *     [{before: true}, {before: false}],\n *     [{after: true}, {after: false}]\n * ]\n *\n * @param   {Object[]} objects Array of objects, each with one property/value pair\n * @returns {Array[]}          Array of arrays of objects grouped by property\n */\nfunction groupByProperty(objects) {\n    const groupedObj = objects.reduce((accumulator, obj) => {\n        const prop = Object.keys(obj)[0];\n\n        accumulator[prop] = accumulator[prop] ? accumulator[prop].concat(obj) : [obj];\n        return accumulator;\n    }, {});\n\n    return Object.keys(groupedObj).map(prop => groupedObj[prop]);\n}\n\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Configuration settings for a rule.\n *\n * A configuration can be a single number (severity), or an array where the first\n * element in the array is the severity, and is the only required element.\n * Configs may also have one or more additional elements to specify rule\n * configuration or options.\n *\n * @typedef {array|number} ruleConfig\n * @param {number}  0  The rule's severity (0, 1, 2).\n */\n\n/**\n * Object whose keys are rule names and values are arrays of valid ruleConfig items\n * which should be linted against the target source code to determine error counts.\n * (a ruleConfigSet.ruleConfigs).\n *\n * e.g. rulesConfig = {\n *     \"comma-dangle\": [2, [2, \"always\"], [2, \"always-multiline\"], [2, \"never\"]],\n *     \"no-console\": [2]\n * }\n * @typedef rulesConfig\n */\n\n\n/**\n * Create valid rule configurations by combining two arrays,\n * with each array containing multiple objects each with a\n * single property/value pair and matching properties.\n *\n * e.g.:\n * combinePropertyObjects(\n *     [{before: true}, {before: false}],\n *     [{after: true}, {after: false}]\n * );\n *\n * will return:\n * [\n *     {before: true, after: true},\n *     {before: true, after: false},\n *     {before: false, after: true},\n *     {before: false, after: false}\n * ]\n *\n * @param   {Object[]} objArr1 Single key/value objects, all with the same key\n * @param   {Object[]} objArr2 Single key/value objects, all with another key\n * @returns {Object[]}         Combined objects for each combination of input properties and values\n */\nfunction combinePropertyObjects(objArr1, objArr2) {\n    const res = [];\n\n    if (objArr1.length === 0) {\n        return objArr2;\n    }\n    if (objArr2.length === 0) {\n        return objArr1;\n    }\n    objArr1.forEach(obj1 => {\n        objArr2.forEach(obj2 => {\n            const combinedObj = {};\n            const obj1Props = Object.keys(obj1);\n            const obj2Props = Object.keys(obj2);\n\n            obj1Props.forEach(prop1 => {\n                combinedObj[prop1] = obj1[prop1];\n            });\n            obj2Props.forEach(prop2 => {\n                combinedObj[prop2] = obj2[prop2];\n            });\n            res.push(combinedObj);\n        });\n    });\n    return res;\n}\n\n /**\n  * Creates a new instance of a rule configuration set\n  *\n  * A rule configuration set is an array of configurations that are valid for a\n  * given rule.  For example, the configuration set for the \"semi\" rule could be:\n  *\n  * ruleConfigSet.ruleConfigs // -> [[2], [2, \"always\"], [2, \"never\"]]\n  *\n  * Rule configuration set class\n  */\nclass RuleConfigSet {\n\n    /**\n     * @param {ruleConfig[]} configs Valid rule configurations\n     */\n    constructor(configs) {\n\n        /**\n        * Stored valid rule configurations for this instance\n        * @type {array}\n        */\n        this.ruleConfigs = configs || [];\n    }\n\n    /**\n    * Add a severity level to the front of all configs in the instance.\n    * This should only be called after all configs have been added to the instance.\n    *\n    * @param {number} [severity=2] The level of severity for the rule (0, 1, 2)\n    * @returns {void}\n    */\n    addErrorSeverity(severity) {\n        severity = severity || 2;\n\n        this.ruleConfigs = this.ruleConfigs.map(config => {\n            config.unshift(severity);\n            return config;\n        });\n\n        // Add a single config at the beginning consisting of only the severity\n        this.ruleConfigs.unshift(severity);\n    }\n\n    /**\n    * Add rule configs from an array of strings (schema enums)\n    * @param  {string[]} enums Array of valid rule options (e.g. [\"always\", \"never\"])\n    * @returns {void}\n    */\n    addEnums(enums) {\n        this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, enums));\n    }\n\n    /**\n    * Add rule configurations from a schema object\n    * @param  {Object} obj Schema item with type === \"object\"\n    * @returns {boolean} true if at least one schema for the object could be generated, false otherwise\n    */\n    addObject(obj) {\n        const objectConfigSet = {\n            objectConfigs: [],\n            add(property, values) {\n                for (let idx = 0; idx < values.length; idx++) {\n                    const optionObj = {};\n\n                    optionObj[property] = values[idx];\n                    this.objectConfigs.push(optionObj);\n                }\n            },\n\n            combine() {\n                this.objectConfigs = groupByProperty(this.objectConfigs).reduce((accumulator, objArr) => combinePropertyObjects(accumulator, objArr), []);\n            }\n        };\n\n        /*\n         * The object schema could have multiple independent properties.\n         * If any contain enums or booleans, they can be added and then combined\n         */\n        Object.keys(obj.properties).forEach(prop => {\n            if (obj.properties[prop].enum) {\n                objectConfigSet.add(prop, obj.properties[prop].enum);\n            }\n            if (obj.properties[prop].type && obj.properties[prop].type === \"boolean\") {\n                objectConfigSet.add(prop, [true, false]);\n            }\n        });\n        objectConfigSet.combine();\n\n        if (objectConfigSet.objectConfigs.length > 0) {\n            this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, objectConfigSet.objectConfigs));\n            return true;\n        }\n\n        return false;\n    }\n}\n\n/**\n* Generate valid rule configurations based on a schema object\n* @param   {Object} schema  A rule's schema object\n* @returns {array[]}        Valid rule configurations\n*/\nfunction generateConfigsFromSchema(schema) {\n    const configSet = new RuleConfigSet();\n\n    if (Array.isArray(schema)) {\n        for (const opt of schema) {\n            if (opt.enum) {\n                configSet.addEnums(opt.enum);\n            } else if (opt.type && opt.type === \"object\") {\n                if (!configSet.addObject(opt)) {\n                    break;\n                }\n\n            // TODO (IanVS): support oneOf\n            } else {\n\n                // If we don't know how to fill in this option, don't fill in any of the following options.\n                break;\n            }\n        }\n    }\n    configSet.addErrorSeverity();\n    return configSet.ruleConfigs;\n}\n\n/**\n* Generate possible rule configurations for all of the core rules\n* @returns {rulesConfig} Hash of rule names and arrays of possible configurations\n*/\nfunction createCoreRuleConfigs() {\n    const ruleList = loadRules();\n\n    return Object.keys(ruleList).reduce((accumulator, id) => {\n        const rule = rules.get(id);\n        const schema = (typeof rule === \"function\") ? rule.schema : rule.meta.schema;\n\n        accumulator[id] = generateConfigsFromSchema(schema);\n        return accumulator;\n    }, {});\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    generateConfigsFromSchema,\n    createCoreRuleConfigs\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/config/config-initializer.js":"/**\n * @fileoverview Config initialization wizard.\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst util = require(\"util\"),\n    inquirer = require(\"inquirer\"),\n    ProgressBar = require(\"progress\"),\n    autoconfig = require(\"./autoconfig.js\"),\n    ConfigFile = require(\"./config-file\"),\n    ConfigOps = require(\"./config-ops\"),\n    getSourceCodeOfFiles = require(\"../util/source-code-util\").getSourceCodeOfFiles,\n    npmUtil = require(\"../util/npm-util\"),\n    recConfig = require(\"../../conf/eslint-recommended\"),\n    log = require(\"../logging\");\n\nconst debug = require(\"debug\")(\"eslint:config-initializer\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: hard to test fs function */\n/**\n * Create .eslintrc file in the current working directory\n * @param {Object} config object that contains user's answers\n * @param {string} format The file format to write to.\n * @returns {void}\n */\nfunction writeFile(config, format) {\n\n    // default is .js\n    let extname = \".js\";\n\n    if (format === \"YAML\") {\n        extname = \".yml\";\n    } else if (format === \"JSON\") {\n        extname = \".json\";\n    }\n\n    const installedESLint = config.installedESLint;\n\n    delete config.installedESLint;\n\n    ConfigFile.write(config, `./.eslintrc${extname}`);\n    log.info(`Successfully created .eslintrc${extname} file in ${process.cwd()}`);\n\n    if (installedESLint) {\n        log.info(\"ESLint was installed locally. We recommend using this local copy instead of your globally-installed copy.\");\n    }\n}\n\n/**\n * Synchronously install necessary plugins, configs, parsers, etc. based on the config\n * @param   {Object} config  config object\n * @returns {void}\n */\nfunction installModules(config) {\n    let modules = [];\n\n    // Create a list of modules which should be installed based on config\n    if (config.plugins) {\n        modules = modules.concat(config.plugins.map(name => `eslint-plugin-${name}`));\n    }\n    if (config.extends && config.extends.indexOf(\"eslint:\") === -1) {\n        modules.push(`eslint-config-${config.extends}`);\n    }\n\n    // Determine which modules are already installed\n    if (modules.length === 0) {\n        return;\n    }\n\n    // Add eslint to list in case user does not have it installed locally\n    modules.unshift(\"eslint\");\n\n    const installStatus = npmUtil.checkDevDeps(modules);\n\n    // Install packages which aren't already installed\n    const modulesToInstall = Object.keys(installStatus).filter(module => {\n        const notInstalled = installStatus[module] === false;\n\n        if (module === \"eslint\" && notInstalled) {\n            log.info(\"Local ESLint installation not found.\");\n            config.installedESLint = true;\n        }\n\n        return notInstalled;\n    });\n\n    if (modulesToInstall.length > 0) {\n        log.info(`Installing ${modulesToInstall.join(\", \")}`);\n        npmUtil.installSyncSaveDev(modulesToInstall);\n    }\n}\n\n/**\n * Set the `rules` of a config by examining a user's source code\n *\n * Note: This clones the config object and returns a new config to avoid mutating\n * the original config parameter.\n *\n * @param   {Object} answers  answers received from inquirer\n * @param   {Object} config   config object\n * @returns {Object}          config object with configured rules\n */\nfunction configureRules(answers, config) {\n    const BAR_TOTAL = 20,\n        BAR_SOURCE_CODE_TOTAL = 4,\n        newConfig = Object.assign({}, config),\n        disabledConfigs = {};\n    let sourceCodes,\n        registry;\n\n    // Set up a progress bar, as this process can take a long time\n    const bar = new ProgressBar(\"Determining Config: :percent [:bar] :elapseds elapsed, eta :etas \", {\n        width: 30,\n        total: BAR_TOTAL\n    });\n\n    bar.tick(0); // Shows the progress bar\n\n    // Get the SourceCode of all chosen files\n    const patterns = answers.patterns.split(/[\\s]+/);\n\n    try {\n        sourceCodes = getSourceCodeOfFiles(patterns, { baseConfig: newConfig, useEslintrc: false }, total => {\n            bar.tick((BAR_SOURCE_CODE_TOTAL / total));\n        });\n    } catch (e) {\n        log.info(\"\\n\");\n        throw e;\n    }\n    const fileQty = Object.keys(sourceCodes).length;\n\n    if (fileQty === 0) {\n        log.info(\"\\n\");\n        throw new Error(\"Automatic Configuration failed.  No files were able to be parsed.\");\n    }\n\n    // Create a registry of rule configs\n    registry = new autoconfig.Registry();\n    registry.populateFromCoreRules();\n\n    // Lint all files with each rule config in the registry\n    registry = registry.lintSourceCode(sourceCodes, newConfig, total => {\n        bar.tick((BAR_TOTAL - BAR_SOURCE_CODE_TOTAL) / total); // Subtract out ticks used at beginning\n    });\n    debug(`\\nRegistry: ${util.inspect(registry.rules, { depth: null })}`);\n\n    // Create a list of recommended rules, because we don't want to disable them\n    const recRules = Object.keys(recConfig.rules).filter(ruleId => ConfigOps.isErrorSeverity(recConfig.rules[ruleId]));\n\n    // Find and disable rules which had no error-free configuration\n    const failingRegistry = registry.getFailingRulesRegistry();\n\n    Object.keys(failingRegistry.rules).forEach(ruleId => {\n\n        // If the rule is recommended, set it to error, otherwise disable it\n        disabledConfigs[ruleId] = (recRules.indexOf(ruleId) !== -1) ? 2 : 0;\n    });\n\n    // Now that we know which rules to disable, strip out configs with errors\n    registry = registry.stripFailingConfigs();\n\n    // If there is only one config that results in no errors for a rule, we should use it.\n    // createConfig will only add rules that have one configuration in the registry.\n    const singleConfigs = registry.createConfig().rules;\n\n    // The \"sweet spot\" for number of options in a config seems to be two (severity plus one option).\n    // Very often, a third option (usually an object) is available to address\n    // edge cases, exceptions, or unique situations. We will prefer to use a config with\n    // specificity of two.\n    const specTwoConfigs = registry.filterBySpecificity(2).createConfig().rules;\n\n    // Maybe a specific combination using all three options works\n    const specThreeConfigs = registry.filterBySpecificity(3).createConfig().rules;\n\n    // If all else fails, try to use the default (severity only)\n    const defaultConfigs = registry.filterBySpecificity(1).createConfig().rules;\n\n    // Combine configs in reverse priority order (later take precedence)\n    newConfig.rules = Object.assign({}, disabledConfigs, defaultConfigs, specThreeConfigs, specTwoConfigs, singleConfigs);\n\n    // Make sure progress bar has finished (floating point rounding)\n    bar.update(BAR_TOTAL);\n\n    // Log out some stats to let the user know what happened\n    const finalRuleIds = Object.keys(newConfig.rules);\n    const totalRules = finalRuleIds.length;\n    const enabledRules = finalRuleIds.filter(ruleId => (newConfig.rules[ruleId] !== 0)).length;\n    const resultMessage = [\n        `\\nEnabled ${enabledRules} out of ${totalRules}`,\n        `rules based on ${fileQty}`,\n        `file${(fileQty === 1) ? \".\" : \"s.\"}`\n    ].join(\" \");\n\n    log.info(resultMessage);\n\n    ConfigOps.normalizeToStrings(newConfig);\n    return newConfig;\n}\n\n/**\n * process user's answers and create config object\n * @param {Object} answers answers received from inquirer\n * @returns {Object} config object\n */\nfunction processAnswers(answers) {\n    let config = { rules: {}, env: {} };\n\n    if (answers.es6) {\n        config.env.es6 = true;\n        if (answers.modules) {\n            config.parserOptions = config.parserOptions || {};\n            config.parserOptions.sourceType = \"module\";\n        }\n    }\n    if (answers.commonjs) {\n        config.env.commonjs = true;\n    }\n    answers.env.forEach(env => {\n        config.env[env] = true;\n    });\n    if (answers.jsx) {\n        config.parserOptions = config.parserOptions || {};\n        config.parserOptions.ecmaFeatures = config.parserOptions.ecmaFeatures || {};\n        config.parserOptions.ecmaFeatures.jsx = true;\n        if (answers.react) {\n            config.plugins = [\"react\"];\n            config.parserOptions.ecmaFeatures.experimentalObjectRestSpread = true;\n        }\n    }\n\n    if (answers.source === \"prompt\") {\n        config.extends = \"eslint:recommended\";\n        config.rules.indent = [\"error\", answers.indent];\n        config.rules.quotes = [\"error\", answers.quotes];\n        config.rules[\"linebreak-style\"] = [\"error\", answers.linebreak];\n        config.rules.semi = [\"error\", answers.semi ? \"always\" : \"never\"];\n    }\n\n    installModules(config);\n\n    if (answers.source === \"auto\") {\n        config = configureRules(answers, config);\n        config = autoconfig.extendFromRecommended(config);\n    }\n\n    ConfigOps.normalizeToStrings(config);\n    return config;\n}\n\n/**\n * process user's style guide of choice and return an appropriate config object.\n * @param {string} guide name of the chosen style guide\n * @returns {Object} config object\n */\nfunction getConfigForStyleGuide(guide) {\n    const guides = {\n        google: { extends: \"google\" },\n        airbnb: { extends: \"airbnb\", plugins: [\"react\", \"jsx-a11y\", \"import\"] },\n        \"airbnb-base\": { extends: \"airbnb-base\", plugins: [\"import\"] },\n        standard: { extends: \"standard\", plugins: [\"standard\", \"promise\"] }\n    };\n\n    if (!guides[guide]) {\n        throw new Error(\"You referenced an unsupported guide.\");\n    }\n\n    installModules(guides[guide]);\n\n    return guides[guide];\n}\n\n/* istanbul ignore next: no need to test inquirer*/\n/**\n * Ask use a few questions on command prompt\n * @param {Function} callback callback function when file has been written\n * @returns {void}\n */\nfunction promptUser(callback) {\n    let config;\n\n    inquirer.prompt([\n        {\n            type: \"list\",\n            name: \"source\",\n            message: \"How would you like to configure ESLint?\",\n            default: \"prompt\",\n            choices: [\n                { name: \"Answer questions about your style\", value: \"prompt\" },\n                { name: \"Use a popular style guide\", value: \"guide\" },\n                { name: \"Inspect your JavaScript file(s)\", value: \"auto\" }\n            ]\n        },\n        {\n            type: \"list\",\n            name: \"styleguide\",\n            message: \"Which style guide do you want to follow?\",\n            choices: [{ name: \"Google\", value: \"google\" }, { name: \"Airbnb\", value: \"airbnb\" }, { name: \"Standard\", value: \"standard\" }],\n            when(answers) {\n                answers.packageJsonExists = npmUtil.checkPackageJson();\n                return answers.source === \"guide\" && answers.packageJsonExists;\n            }\n        },\n        {\n            type: \"confirm\",\n            name: \"airbnbReact\",\n            message: \"Do you use React?\",\n            default: false,\n            when(answers) {\n                return answers.styleguide === \"airbnb\";\n            }\n        },\n        {\n            type: \"input\",\n            name: \"patterns\",\n            message: \"Which file(s), path(s), or glob(s) should be examined?\",\n            when(answers) {\n                return (answers.source === \"auto\");\n            },\n            validate(input) {\n                if (input.trim().length === 0 && input.trim() !== \",\") {\n                    return \"You must tell us what code to examine. Try again.\";\n                }\n                return true;\n            }\n        },\n        {\n            type: \"list\",\n            name: \"format\",\n            message: \"What format do you want your config file to be in?\",\n            default: \"JavaScript\",\n            choices: [\"JavaScript\", \"YAML\", \"JSON\"],\n            when(answers) {\n                return ((answers.source === \"guide\" && answers.packageJsonExists) || answers.source === \"auto\");\n            }\n        }\n    ], earlyAnswers => {\n\n        // early exit if you are using a style guide\n        if (earlyAnswers.source === \"guide\") {\n            if (!earlyAnswers.packageJsonExists) {\n                log.info(\"A package.json is necessary to install plugins such as style guides. Run `npm init` to create a package.json file and try again.\");\n                return;\n            }\n            if (earlyAnswers.styleguide === \"airbnb\" && !earlyAnswers.airbnbReact) {\n                earlyAnswers.styleguide = \"airbnb-base\";\n            }\n            try {\n                config = getConfigForStyleGuide(earlyAnswers.styleguide);\n                writeFile(config, earlyAnswers.format);\n            } catch (err) {\n                callback(err);\n                return;\n            }\n            return;\n        }\n\n        // continue with the questions otherwise...\n        inquirer.prompt([\n            {\n                type: \"confirm\",\n                name: \"es6\",\n                message: \"Are you using ECMAScript 6 features?\",\n                default: false\n            },\n            {\n                type: \"confirm\",\n                name: \"modules\",\n                message: \"Are you using ES6 modules?\",\n                default: false,\n                when(answers) {\n                    return answers.es6 === true;\n                }\n            },\n            {\n                type: \"checkbox\",\n                name: \"env\",\n                message: \"Where will your code run?\",\n                default: [\"browser\"],\n                choices: [{ name: \"Browser\", value: \"browser\" }, { name: \"Node\", value: \"node\" }]\n            },\n            {\n                type: \"confirm\",\n                name: \"commonjs\",\n                message: \"Do you use CommonJS?\",\n                default: false,\n                when(answers) {\n                    return answers.env.some(env => env === \"browser\");\n                }\n            },\n            {\n                type: \"confirm\",\n                name: \"jsx\",\n                message: \"Do you use JSX?\",\n                default: false\n            },\n            {\n                type: \"confirm\",\n                name: \"react\",\n                message: \"Do you use React?\",\n                default: false,\n                when(answers) {\n                    return answers.jsx;\n                }\n            }\n        ], secondAnswers => {\n\n            // early exit if you are using automatic style generation\n            if (earlyAnswers.source === \"auto\") {\n                try {\n                    const combinedAnswers = Object.assign({}, earlyAnswers, secondAnswers);\n\n                    config = processAnswers(combinedAnswers);\n                    installModules(config);\n                    writeFile(config, earlyAnswers.format);\n                } catch (err) {\n                    callback(err);\n                    return;\n                }\n                return;\n            }\n\n            // continue with the style questions otherwise...\n            inquirer.prompt([\n                {\n                    type: \"list\",\n                    name: \"indent\",\n                    message: \"What style of indentation do you use?\",\n                    default: \"tab\",\n                    choices: [{ name: \"Tabs\", value: \"tab\" }, { name: \"Spaces\", value: 4 }]\n                },\n                {\n                    type: \"list\",\n                    name: \"quotes\",\n                    message: \"What quotes do you use for strings?\",\n                    default: \"double\",\n                    choices: [{ name: \"Double\", value: \"double\" }, { name: \"Single\", value: \"single\" }]\n                },\n                {\n                    type: \"list\",\n                    name: \"linebreak\",\n                    message: \"What line endings do you use?\",\n                    default: \"unix\",\n                    choices: [{ name: \"Unix\", value: \"unix\" }, { name: \"Windows\", value: \"windows\" }]\n                },\n                {\n                    type: \"confirm\",\n                    name: \"semi\",\n                    message: \"Do you require semicolons?\",\n                    default: true\n                },\n                {\n                    type: \"list\",\n                    name: \"format\",\n                    message: \"What format do you want your config file to be in?\",\n                    default: \"JavaScript\",\n                    choices: [\"JavaScript\", \"YAML\", \"JSON\"]\n                }\n            ], answers => {\n                try {\n                    const totalAnswers = Object.assign({}, earlyAnswers, secondAnswers, answers);\n\n                    config = processAnswers(totalAnswers);\n                    installModules(config);\n                    writeFile(config, answers.format);\n                } catch (err) {\n                    callback(err); // eslint-disable-line callback-return\n                }\n            });\n        });\n    });\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst init = {\n    getConfigForStyleGuide,\n    processAnswers,\n    /* istanbul ignore next */initializeConfig(callback) {\n        promptUser(callback);\n    }\n};\n\nmodule.exports = init;\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/source-code-util.js":"/**\n * @fileoverview Tools for obtaining SourceCode objects.\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CLIEngine = require(\"../cli-engine\"),\n    eslint = require(\"../eslint\"),\n    globUtil = require(\"./glob-util\"),\n    baseDefaultOptions = require(\"../../conf/cli-options\");\n\nconst debug = require(\"debug\")(\"eslint:source-code-util\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the SourceCode object for a single file\n * @param   {string}     filename The fully resolved filename to get SourceCode from.\n * @param   {Object}     options  A CLIEngine options object.\n * @returns {Array}               Array of the SourceCode object representing the file\n *                                and fatal error message.\n */\nfunction getSourceCodeOfFile(filename, options) {\n    debug(\"getting sourceCode of\", filename);\n    const opts = Object.assign({}, options, { rules: {} });\n    const cli = new CLIEngine(opts);\n    const results = cli.executeOnFiles([filename]);\n\n    if (results && results.results[0] && results.results[0].messages[0] && results.results[0].messages[0].fatal) {\n        const msg = results.results[0].messages[0];\n\n        throw new Error(`(${filename}:${msg.line}:${msg.column}) ${msg.message}`);\n    }\n    const sourceCode = eslint.getSourceCode();\n\n    return sourceCode;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\n/**\n * This callback is used to measure execution status in a progress bar\n * @callback progressCallback\n * @param {number} The total number of times the callback will be called.\n */\n\n/**\n * Gets the SourceCode of a single file, or set of files.\n * @param   {string[]|string}  patterns   A filename, directory name, or glob,\n *                                        or an array of them\n * @param   {Object}           [options]  A CLIEngine options object. If not provided,\n *                                        the default cli options will be used.\n * @param   {progressCallback} [cb]       Callback for reporting execution status\n * @returns {Object}                      The SourceCode of all processed files.\n */\nfunction getSourceCodeOfFiles(patterns, options, cb) {\n    const sourceCodes = {};\n    let opts;\n\n    if (typeof patterns === \"string\") {\n        patterns = [patterns];\n    }\n\n    const defaultOptions = Object.assign({}, baseDefaultOptions, { cwd: process.cwd() });\n\n    if (typeof options === \"undefined\") {\n        opts = defaultOptions;\n    } else if (typeof options === \"function\") {\n        cb = options;\n        opts = defaultOptions;\n    } else if (typeof options === \"object\") {\n        opts = Object.assign({}, defaultOptions, options);\n    }\n    debug(\"constructed options:\", opts);\n    patterns = globUtil.resolveFileGlobPatterns(patterns, opts);\n\n    const filenames = globUtil.listFilesToProcess(patterns, opts)\n        .filter(fileInfo => !fileInfo.ignored)\n        .reduce((files, fileInfo) => files.concat(fileInfo.filename), []);\n\n    if (filenames.length === 0) {\n        debug(`Did not find any files matching pattern(s): ${patterns}`);\n    }\n    filenames.forEach(filename => {\n        const sourceCode = getSourceCodeOfFile(filename, opts);\n\n        if (sourceCode) {\n            debug(\"got sourceCode of\", filename);\n            sourceCodes[filename] = sourceCode;\n        }\n        if (cb) {\n            cb(filenames.length); // eslint-disable-line callback-return\n        }\n    });\n    return sourceCodes;\n}\n\nmodule.exports = {\n    getSourceCodeOfFiles\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/npm-util.js":"/**\n * @fileoverview Utility for executing npm commands.\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    shell = require(\"shelljs\"),\n    log = require(\"../logging\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Find the closest package.json file, starting at process.cwd (by default),\n * and working up to root.\n *\n * @param   {string} [startDir=process.cwd()] Starting directory\n * @returns {string}                          Absolute path to closest package.json file\n */\nfunction findPackageJson(startDir) {\n    let dir = path.resolve(startDir || process.cwd());\n\n    do {\n        const pkgfile = path.join(dir, \"package.json\");\n\n        if (!shell.test(\"-f\", pkgfile)) {\n            dir = path.join(dir, \"..\");\n            continue;\n        }\n        return pkgfile;\n    } while (dir !== path.resolve(dir, \"..\"));\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Install node modules synchronously and save to devDependencies in package.json\n * @param   {string|string[]} packages Node module or modules to install\n * @returns {void}\n */\nfunction installSyncSaveDev(packages) {\n    if (Array.isArray(packages)) {\n        packages = packages.join(\" \");\n    }\n    shell.exec(`npm i --save-dev ${packages}`, { stdio: \"inherit\" });\n}\n\n/**\n * Check whether node modules are include in a project's package.json.\n *\n * @param   {string[]} packages           Array of node module names\n * @param   {Object}  opt                 Options Object\n * @param   {boolean} opt.dependencies    Set to true to check for direct dependencies\n * @param   {boolean} opt.devDependencies Set to true to check for development dependencies\n * @param   {boolean} opt.startdir        Directory to begin searching from\n * @returns {Object}                      An object whose keys are the module names\n *                                        and values are booleans indicating installation.\n */\nfunction check(packages, opt) {\n    let deps = [];\n    const pkgJson = (opt) ? findPackageJson(opt.startDir) : findPackageJson();\n    let fileJson;\n\n    if (!pkgJson) {\n        throw new Error(\"Could not find a package.json file. Run 'npm init' to create one.\");\n    }\n\n    try {\n        fileJson = JSON.parse(fs.readFileSync(pkgJson, \"utf8\"));\n    } catch (e) {\n        log.info(\"Could not read package.json file. Please check that the file contains valid JSON.\");\n        throw new Error(e);\n    }\n\n    if (opt.devDependencies && typeof fileJson.devDependencies === \"object\") {\n        deps = deps.concat(Object.keys(fileJson.devDependencies));\n    }\n    if (opt.dependencies && typeof fileJson.dependencies === \"object\") {\n        deps = deps.concat(Object.keys(fileJson.dependencies));\n    }\n    return packages.reduce((status, pkg) => {\n        status[pkg] = deps.indexOf(pkg) !== -1;\n        return status;\n    }, {});\n}\n\n/**\n * Check whether node modules are included in the dependencies of a project's\n * package.json.\n *\n * Convienience wrapper around check().\n *\n * @param   {string[]} packages  Array of node modules to check.\n * @param   {string}   rootDir   The directory contianing a package.json\n * @returns {Object}             An object whose keys are the module names\n *                               and values are booleans indicating installation.\n */\nfunction checkDeps(packages, rootDir) {\n    return check(packages, { dependencies: true, startDir: rootDir });\n}\n\n/**\n * Check whether node modules are included in the devDependencies of a project's\n * package.json.\n *\n * Convienience wrapper around check().\n *\n * @param   {string[]} packages  Array of node modules to check.\n * @returns {Object}             An object whose keys are the module names\n *                               and values are booleans indicating installation.\n */\nfunction checkDevDeps(packages) {\n    return check(packages, { devDependencies: true });\n}\n\n/**\n * Check whether package.json is found in current path.\n *\n * @param   {string=} startDir Starting directory\n * @returns {boolean} Whether a package.json is found in current path.\n */\nfunction checkPackageJson(startDir) {\n    return !!findPackageJson(startDir);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    installSyncSaveDev,\n    checkDeps,\n    checkDevDeps,\n    checkPackageJson\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/checkstyle.js":"/**\n * @fileoverview CheckStyle XML reporter\n * @author Ian Christian Myers\n */\n\"use strict\";\n\nconst xmlEscape = require(\"../util/xml-escape\");\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns the severity of warning or error\n * @param {Object} message message object to examine\n * @returns {string} severity level\n * @private\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"error\";\n    }\n    return \"warning\";\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\";\n\n    output += \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\";\n    output += \"<checkstyle version=\\\"4.3\\\">\";\n\n    results.forEach(result => {\n        const messages = result.messages;\n\n        output += `<file name=\"${xmlEscape(result.filePath)}\">`;\n\n        messages.forEach(message => {\n            output += [\n                `<error line=\"${xmlEscape(message.line)}\"`,\n                `column=\"${xmlEscape(message.column)}\"`,\n                `severity=\"${xmlEscape(getMessageType(message))}\"`,\n                `message=\"${xmlEscape(message.message)}${message.ruleId ? ` (${message.ruleId})` : \"\"}\"`,\n                `source=\"${message.ruleId ? xmlEscape(`eslint.rules.${message.ruleId}`) : \"\"}\" />`\n            ].join(\" \");\n        });\n\n        output += \"</file>\";\n\n    });\n\n    output += \"</checkstyle>\";\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/util/xml-escape.js":"/**\n * @fileoverview XML character escaper\n * @author George Chung\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Returns the escaped value for a character\n * @param {string} s string to examine\n * @returns {string} severity level\n * @private\n */\nmodule.exports = function(s) {\n    return (`${s}`).replace(/[<>&\"'\\x00-\\x1F\\x7F\\u0080-\\uFFFF]/g, c => { // eslint-disable-line no-control-regex\n        switch (c) {\n            case \"<\":\n                return \"&lt;\";\n            case \">\":\n                return \"&gt;\";\n            case \"&\":\n                return \"&amp;\";\n            case \"\\\"\":\n                return \"&quot;\";\n            case \"'\":\n                return \"&apos;\";\n            default:\n                return `&#${c.charCodeAt(0)};`;\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/codeframe.js":"/**\n * @fileoverview Codeframe reporter\n * @author Vitor Balocco\n */\n\"use strict\";\n\nconst chalk = require(\"chalk\");\nconst codeFrame = require(\"babel-code-frame\");\nconst path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Given a word and a count, append an s if count is not one.\n * @param   {string} word  A word in its singular form.\n * @param   {number} count A number controlling whether word should be pluralized.\n * @returns {string}       The original word with an s on the end if count is not one.\n */\nfunction pluralize(word, count) {\n    return (count === 1 ? word : `${word}s`);\n}\n\n/**\n * Gets a formatted relative file path from an absolute path and a line/column in the file.\n * @param   {string} filePath The absolute file path to format.\n * @param   {number} line     The line from the file to use for formatting.\n * @param   {number} column   The column from the file to use for formatting.\n * @returns {string}          The formatted file path.\n */\nfunction formatFilePath(filePath, line, column) {\n    let relPath = path.relative(process.cwd(), filePath);\n\n    if (line && column) {\n        relPath += `:${line}:${column}`;\n    }\n\n    return chalk.green(relPath);\n}\n\n/**\n * Gets the formatted output for a given message.\n * @param   {Object} message      The object that represents this message.\n * @param   {Object} parentResult The result object that this message belongs to.\n * @returns {string}              The formatted output.\n */\nfunction formatMessage(message, parentResult) {\n    const type = (message.fatal || message.severity === 2) ? chalk.red(\"error\") : chalk.yellow(\"warning\");\n    const msg = `${chalk.bold(message.message.replace(/\\.$/, \"\"))}`;\n    const ruleId = message.fatal ? \"\" : chalk.dim(`(${message.ruleId})`);\n    const filePath = formatFilePath(parentResult.filePath, message.line, message.column);\n    const sourceCode = parentResult.output ? parentResult.output : parentResult.source;\n\n    const firstLine = [\n        `${type}:`,\n        `${msg}`,\n        ruleId ? `${ruleId}` : \"\",\n        sourceCode ? `at ${filePath}:` : `at ${filePath}`\n    ].filter(String).join(\" \");\n\n    const result = [firstLine];\n\n    if (sourceCode) {\n        result.push(\n            codeFrame(sourceCode, message.line, message.column, { highlightCode: false })\n        );\n    }\n\n    return result.join(\"\\n\");\n}\n\n/**\n * Gets the formatted output summary for a given number of errors and warnings.\n * @param   {number} errors   The number of errors.\n * @param   {number} warnings The number of warnings.\n * @returns {string}          The formatted output summary.\n */\nfunction formatSummary(errors, warnings) {\n    const summaryColor = errors > 0 ? \"red\" : \"yellow\";\n    const summary = [];\n\n    if (errors > 0) {\n        summary.push(`${errors} ${pluralize(\"error\", errors)}`);\n    }\n\n    if (warnings > 0) {\n        summary.push(`${warnings} ${pluralize(\"warning\", warnings)}`);\n    }\n\n    return chalk[summaryColor].bold(`${summary.join(\" and \")} found.`);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n    let errors = 0;\n    let warnings = 0;\n    const resultsWithMessages = results.filter(result => result.messages.length > 0);\n\n    let output = resultsWithMessages.reduce((resultsOutput, result) => {\n        const messages = result.messages.map(message => `${formatMessage(message, result)}\\n\\n`);\n\n        errors += result.errorCount;\n        warnings += result.warningCount;\n\n        return resultsOutput.concat(messages);\n    }, []).join(\"\\n\");\n\n    output += \"\\n\";\n    output += formatSummary(errors, warnings);\n\n    return (errors + warnings) > 0 ? output : \"\";\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/compact.js":"/**\n * @fileoverview Compact reporter\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns the severity of warning or error\n * @param {Object} message message object to examine\n * @returns {string} severity level\n * @private\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"Error\";\n    }\n    return \"Warning\";\n\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\",\n        total = 0;\n\n    results.forEach(result => {\n\n        const messages = result.messages;\n\n        total += messages.length;\n\n        messages.forEach(message => {\n\n            output += `${result.filePath}: `;\n            output += `line ${message.line || 0}`;\n            output += `, col ${message.column || 0}`;\n            output += `, ${getMessageType(message)}`;\n            output += ` - ${message.message}`;\n            output += message.ruleId ? ` (${message.ruleId})` : \"\";\n            output += \"\\n\";\n\n        });\n\n    });\n\n    if (total > 0) {\n        output += `\\n${total} problem${total !== 1 ? \"s\" : \"\"}`;\n    }\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/html.js":"/**\n * @fileoverview HTML reporter\n * @author Julian Laval\n */\n\"use strict\";\n\nconst lodash = require(\"lodash\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst pageTemplate = lodash.template(fs.readFileSync(path.join(__dirname, \"html-template-page.html\"), \"utf-8\"));\nconst messageTemplate = lodash.template(fs.readFileSync(path.join(__dirname, \"html-template-message.html\"), \"utf-8\"));\nconst resultTemplate = lodash.template(fs.readFileSync(path.join(__dirname, \"html-template-result.html\"), \"utf-8\"));\n\n/**\n * Given a word and a count, append an s if count is not one.\n * @param {string} word A word in its singular form.\n * @param {int} count A number controlling whether word should be pluralized.\n * @returns {string} The original word with an s on the end if count is not one.\n */\nfunction pluralize(word, count) {\n    return (count === 1 ? word : `${word}s`);\n}\n\n/**\n * Renders text along the template of x problems (x errors, x warnings)\n * @param {string} totalErrors Total errors\n * @param {string} totalWarnings Total warnings\n * @returns {string} The formatted string, pluralized where necessary\n */\nfunction renderSummary(totalErrors, totalWarnings) {\n    const totalProblems = totalErrors + totalWarnings;\n    let renderedText = `${totalProblems} ${pluralize(\"problem\", totalProblems)}`;\n\n    if (totalProblems !== 0) {\n        renderedText += ` (${totalErrors} ${pluralize(\"error\", totalErrors)}, ${totalWarnings} ${pluralize(\"warning\", totalWarnings)})`;\n    }\n    return renderedText;\n}\n\n/**\n * Get the color based on whether there are errors/warnings...\n * @param {string} totalErrors Total errors\n * @param {string} totalWarnings Total warnings\n * @returns {int} The color code (0 = green, 1 = yellow, 2 = red)\n */\nfunction renderColor(totalErrors, totalWarnings) {\n    if (totalErrors !== 0) {\n        return 2;\n    } else if (totalWarnings !== 0) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n * Get HTML (table rows) describing the messages.\n * @param {Array} messages Messages.\n * @param {int} parentIndex Index of the parent HTML row.\n * @returns {string} HTML (table rows) describing the messages.\n */\nfunction renderMessages(messages, parentIndex) {\n\n    /**\n     * Get HTML (table row) describing a message.\n     * @param {Object} message Message.\n     * @returns {string} HTML (table row) describing a message.\n     */\n    return lodash.map(messages, message => {\n        const lineNumber = message.line || 0;\n        const columnNumber = message.column || 0;\n\n        return messageTemplate({\n            parentIndex,\n            lineNumber,\n            columnNumber,\n            severityNumber: message.severity,\n            severityName: message.severity === 1 ? \"Warning\" : \"Error\",\n            message: message.message,\n            ruleId: message.ruleId\n        });\n    }).join(\"\\n\");\n}\n\n/**\n * @param {Array} results Test results.\n * @returns {string} HTML string describing the results.\n */\nfunction renderResults(results) {\n    return lodash.map(results, (result, index) => resultTemplate({\n        index,\n        color: renderColor(result.errorCount, result.warningCount),\n        filePath: result.filePath,\n        summary: renderSummary(result.errorCount, result.warningCount)\n\n    }) + renderMessages(result.messages, index)).join(\"\\n\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n    let totalErrors,\n        totalWarnings;\n\n    totalErrors = 0;\n    totalWarnings = 0;\n\n    // Iterate over results to get totals\n    results.forEach(result => {\n        totalErrors += result.errorCount;\n        totalWarnings += result.warningCount;\n    });\n\n    return pageTemplate({\n        date: new Date(),\n        reportColor: renderColor(totalErrors, totalWarnings),\n        reportSummary: renderSummary(totalErrors, totalWarnings),\n        results: renderResults(results)\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/jslint-xml.js":"/**\n * @fileoverview JSLint XML reporter\n * @author Ian Christian Myers\n */\n\"use strict\";\n\nconst xmlEscape = require(\"../util/xml-escape\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\";\n\n    output += \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\";\n    output += \"<jslint>\";\n\n    results.forEach(result => {\n        const messages = result.messages;\n\n        output += `<file name=\"${result.filePath}\">`;\n\n        messages.forEach(message => {\n            output += [\n                `<issue line=\"${message.line}\"`,\n                `char=\"${message.column}\"`,\n                `evidence=\"${xmlEscape(message.source || \"\")}\"`,\n                `reason=\"${xmlEscape(message.message || \"\")}${message.ruleId ? ` (${message.ruleId})` : \"\"}\" />`\n            ].join(\" \");\n        });\n\n        output += \"</file>\";\n\n    });\n\n    output += \"</jslint>\";\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/json.js":"/**\n * @fileoverview JSON reporter\n * @author Burak Yigit Kaya aka BYK\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n    return JSON.stringify(results);\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/junit.js":"/**\n * @fileoverview jUnit Reporter\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst xmlEscape = require(\"../util/xml-escape\");\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns the severity of warning or error\n * @param {Object} message message object to examine\n * @returns {string} severity level\n * @private\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"Error\";\n    }\n    return \"Warning\";\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\";\n\n    output += \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\";\n    output += \"<testsuites>\\n\";\n\n    results.forEach(result => {\n\n        const messages = result.messages;\n\n        if (messages.length) {\n            output += `<testsuite package=\"org.eslint\" time=\"0\" tests=\"${messages.length}\" errors=\"${messages.length}\" name=\"${result.filePath}\">\\n`;\n        }\n\n        messages.forEach(message => {\n            const type = message.fatal ? \"error\" : \"failure\";\n\n            output += `<testcase time=\"0\" name=\"org.eslint.${message.ruleId || \"unknown\"}\">`;\n            output += `<${type} message=\"${xmlEscape(message.message || \"\")}\">`;\n            output += \"<![CDATA[\";\n            output += `line ${message.line || 0}, col `;\n            output += `${message.column || 0}, ${getMessageType(message)}`;\n            output += ` - ${xmlEscape(message.message || \"\")}`;\n            output += (message.ruleId ? ` (${message.ruleId})` : \"\");\n            output += \"]]>\";\n            output += `</${type}>`;\n            output += \"</testcase>\\n\";\n        });\n\n        if (messages.length) {\n            output += \"</testsuite>\\n\";\n        }\n\n    });\n\n    output += \"</testsuites>\\n\";\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/stylish.js":"/**\n * @fileoverview Stylish reporter\n * @author Sindre Sorhus\n */\n\"use strict\";\n\nconst chalk = require(\"chalk\"),\n    table = require(\"text-table\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Given a word and a count, append an s if count is not one.\n * @param {string} word A word in its singular form.\n * @param {int} count A number controlling whether word should be pluralized.\n * @returns {string} The original word with an s on the end if count is not one.\n */\nfunction pluralize(word, count) {\n    return (count === 1 ? word : `${word}s`);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\\n\",\n        errors = 0,\n        warnings = 0,\n        summaryColor = \"yellow\";\n\n    results.forEach(result => {\n        const messages = result.messages;\n\n        if (messages.length === 0) {\n            return;\n        }\n\n        errors += result.errorCount;\n        warnings += result.warningCount;\n\n        output += `${chalk.underline(result.filePath)}\\n`;\n\n        output += `${table(\n            messages.map(message => {\n                let messageType;\n\n                if (message.fatal || message.severity === 2) {\n                    messageType = chalk.red(\"error\");\n                    summaryColor = \"red\";\n                } else {\n                    messageType = chalk.yellow(\"warning\");\n                }\n\n                return [\n                    \"\",\n                    message.line || 0,\n                    message.column || 0,\n                    messageType,\n                    message.message.replace(/\\.$/, \"\"),\n                    chalk.dim(message.ruleId || \"\")\n                ];\n            }),\n            {\n                align: [\"\", \"r\", \"l\"],\n                stringLength(str) {\n                    return chalk.stripColor(str).length;\n                }\n            }\n        ).split(\"\\n\").map(el => el.replace(/(\\d+)\\s+(\\d+)/, (m, p1, p2) => chalk.dim(`${p1}:${p2}`))).join(\"\\n\")}\\n\\n`;\n    });\n\n    const total = errors + warnings;\n\n    if (total > 0) {\n        output += chalk[summaryColor].bold([\n            \"\\u2716 \", total, pluralize(\" problem\", total),\n            \" (\", errors, pluralize(\" error\", errors), \", \",\n            warnings, pluralize(\" warning\", warnings), \")\\n\"\n        ].join(\"\"));\n    }\n\n    return total > 0 ? output : \"\";\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/table.js":"/**\n * @fileoverview \"table reporter.\n * @author Gajus Kuizinas <gajus@gajus.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst chalk = require(\"chalk\"),\n    table = require(\"table\").default,\n    pluralize = require(\"pluralize\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Draws text table.\n * @param {Array<Object>} messages Error messages relating to a specific file.\n * @returns {string} A text table.\n */\nfunction drawTable(messages) {\n    const rows = [];\n\n    if (messages.length === 0) {\n        return \"\";\n    }\n\n    rows.push([\n        chalk.bold(\"Line\"),\n        chalk.bold(\"Column\"),\n        chalk.bold(\"Type\"),\n        chalk.bold(\"Message\"),\n        chalk.bold(\"Rule ID\")\n    ]);\n\n    messages.forEach(message => {\n        let messageType;\n\n        if (message.fatal || message.severity === 2) {\n            messageType = chalk.red(\"error\");\n        } else {\n            messageType = chalk.yellow(\"warning\");\n        }\n\n        rows.push([\n            message.line || 0,\n            message.column || 0,\n            messageType,\n            message.message,\n            message.ruleId || \"\"\n        ]);\n    });\n\n    return table(rows, {\n        columns: {\n            0: {\n                width: 8,\n                wrapWord: true\n            },\n            1: {\n                width: 8,\n                wrapWord: true\n            },\n            2: {\n                width: 8,\n                wrapWord: true\n            },\n            3: {\n                paddingRight: 5,\n                width: 50,\n                wrapWord: true\n            },\n            4: {\n                width: 20,\n                wrapWord: true\n            }\n        },\n        drawHorizontalLine(index) {\n            return index === 1;\n        }\n    });\n}\n\n/**\n * Draws a report (multiple tables).\n * @param {Array} results Report results for every file.\n * @returns {string} A column of text tables.\n */\nfunction drawReport(results) {\n    let files;\n\n    files = results.map(result => {\n        if (!result.messages.length) {\n            return \"\";\n        }\n\n        return `\\n${result.filePath}\\n\\n${drawTable(result.messages)}`;\n    });\n\n    files = files.filter(content => content.trim());\n\n    return files.join(\"\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(report) {\n    let result,\n        errorCount,\n        warningCount;\n\n    result = \"\";\n    errorCount = 0;\n    warningCount = 0;\n\n    report.forEach(fileReport => {\n        errorCount += fileReport.errorCount;\n        warningCount += fileReport.warningCount;\n    });\n\n    if (errorCount || warningCount) {\n        result = drawReport(report);\n    }\n\n    result += `\\n${table([\n        [\n            chalk.red(pluralize(\"Error\", errorCount, true))\n        ],\n        [\n            chalk.yellow(pluralize(\"Warning\", warningCount, true))\n        ]\n    ], {\n        columns: {\n            0: {\n                width: 110,\n                wrapWord: true\n            }\n        },\n        drawHorizontalLine() {\n            return true;\n        }\n    })}`;\n\n    return result;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/tap.js":"/**\n * @fileoverview TAP reporter\n * @author Jonathan Kingston\n */\n\"use strict\";\n\nconst yaml = require(\"js-yaml\");\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns a canonical error level string based upon the error message passed in.\n * @param {Object} message Individual error message provided by eslint\n * @returns {string} Error level string\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"error\";\n    }\n    return \"warning\";\n\n}\n\n/**\n * Takes in a JavaScript object and outputs a TAP diagnostics string\n * @param {Object} diagnostic JavaScript object to be embedded as YAML into output.\n * @returns {string} diagnostics string with YAML embedded - TAP version 13 compliant\n */\nfunction outputDiagnostics(diagnostic) {\n    const prefix = \"  \";\n    let output = `${prefix}---\\n`;\n\n    output += prefix + yaml.safeDump(diagnostic).split(\"\\n\").join(`\\n${prefix}`);\n    output += \"...\\n\";\n    return output;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n    let output = `TAP version 13\\n1..${results.length}\\n`;\n\n    results.forEach((result, id) => {\n        const messages = result.messages;\n        let testResult = \"ok\";\n        let diagnostics = {};\n\n        if (messages.length > 0) {\n            testResult = \"not ok\";\n\n            messages.forEach(message => {\n                const diagnostic = {\n                    message: message.message,\n                    severity: getMessageType(message),\n                    data: {\n                        line: message.line || 0,\n                        column: message.column || 0,\n                        ruleId: message.ruleId || \"\"\n                    }\n                };\n\n                // If we have multiple messages place them under a messages key\n                // The first error will be logged as message key\n                // This is to adhere to TAP 13 loosely defined specification of having a message key\n                if (\"message\" in diagnostics) {\n                    if (typeof diagnostics.messages === \"undefined\") {\n                        diagnostics.messages = [];\n                    }\n                    diagnostics.messages.push(diagnostic);\n                } else {\n                    diagnostics = diagnostic;\n                }\n            });\n        }\n\n        output += `${testResult} ${id + 1} - ${result.filePath}\\n`;\n\n        // If we have an error include diagnostics\n        if (messages.length > 0) {\n            output += outputDiagnostics(diagnostics);\n        }\n\n    });\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/unix.js":"/**\n * @fileoverview unix-style formatter.\n * @author oshi-shinobu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns a canonical error level string based upon the error message passed in.\n * @param {Object} message Individual error message provided by eslint\n * @returns {string} Error level string\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"Error\";\n    }\n    return \"Warning\";\n\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\",\n        total = 0;\n\n    results.forEach(result => {\n\n        const messages = result.messages;\n\n        total += messages.length;\n\n        messages.forEach(message => {\n\n            output += `${result.filePath}:`;\n            output += `${message.line || 0}:`;\n            output += `${message.column || 0}:`;\n            output += ` ${message.message} `;\n            output += `[${getMessageType(message)}${message.ruleId ? `/${message.ruleId}` : \"\"}]`;\n            output += \"\\n\";\n\n        });\n\n    });\n\n    if (total > 0) {\n        output += `\\n${total} problem${total !== 1 ? \"s\" : \"\"}`;\n    }\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/formatters/visualstudio.js":"/**\n * @fileoverview Visual Studio compatible formatter\n * @author Ronald Pijnacker\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns the severity of warning or error\n * @param {Object} message message object to examine\n * @returns {string} severity level\n * @private\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"error\";\n    }\n    return \"warning\";\n\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\",\n        total = 0;\n\n    results.forEach(result => {\n\n        const messages = result.messages;\n\n        total += messages.length;\n\n        messages.forEach(message => {\n\n            output += result.filePath;\n            output += `(${message.line || 0}`;\n            output += message.column ? `,${message.column}` : \"\";\n            output += `): ${getMessageType(message)}`;\n            output += message.ruleId ? ` ${message.ruleId}` : \"\";\n            output += ` : ${message.message}`;\n            output += \"\\n\";\n\n        });\n\n    });\n\n    if (total === 0) {\n        output += \"no problems\";\n    } else {\n        output += `\\n${total} problem${total !== 1 ? \"s\" : \"\"}`;\n    }\n\n    return output;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/node_modules/eslint/lib/internal-rules/internal-no-invalid-meta.js":"/**\n * @fileoverview Internal rule to prevent missing or invalid meta property in core rules.\n * @author Vitor Balocco\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets the property of the Object node passed in that has the name specified.\n *\n * @param {string} property Name of the property to return.\n * @param {ASTNode} node The ObjectExpression node.\n * @returns {ASTNode} The Property node or null if not found.\n */\nfunction getPropertyFromObject(property, node) {\n    const properties = node.properties;\n\n    for (let i = 0; i < properties.length; i++) {\n        if (properties[i].key.name === property) {\n            return properties[i];\n        }\n    }\n\n    return null;\n}\n\n/**\n * Extracts the `meta` property from the ObjectExpression that all rules export.\n *\n * @param {ASTNode} exportsNode ObjectExpression node that the rule exports.\n * @returns {ASTNode} The `meta` Property node or null if not found.\n */\nfunction getMetaPropertyFromExportsNode(exportsNode) {\n    return getPropertyFromObject(\"meta\", exportsNode);\n}\n\n/**\n * Whether this `meta` ObjectExpression has a `docs` property defined or not.\n *\n * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.\n * @returns {boolean} `true` if a `docs` property exists.\n */\nfunction hasMetaDocs(metaPropertyNode) {\n    return Boolean(getPropertyFromObject(\"docs\", metaPropertyNode.value));\n}\n\n/**\n * Whether this `meta` ObjectExpression has a `docs.description` property defined or not.\n *\n * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.\n * @returns {boolean} `true` if a `docs.description` property exists.\n */\nfunction hasMetaDocsDescription(metaPropertyNode) {\n    const metaDocs = getPropertyFromObject(\"docs\", metaPropertyNode.value);\n\n    return metaDocs && getPropertyFromObject(\"description\", metaDocs.value);\n}\n\n/**\n * Whether this `meta` ObjectExpression has a `docs.category` property defined or not.\n *\n * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.\n * @returns {boolean} `true` if a `docs.category` property exists.\n */\nfunction hasMetaDocsCategory(metaPropertyNode) {\n    const metaDocs = getPropertyFromObject(\"docs\", metaPropertyNode.value);\n\n    return metaDocs && getPropertyFromObject(\"category\", metaDocs.value);\n}\n\n/**\n * Whether this `meta` ObjectExpression has a `docs.recommended` property defined or not.\n *\n * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.\n * @returns {boolean} `true` if a `docs.recommended` property exists.\n */\nfunction hasMetaDocsRecommended(metaPropertyNode) {\n    const metaDocs = getPropertyFromObject(\"docs\", metaPropertyNode.value);\n\n    return metaDocs && getPropertyFromObject(\"recommended\", metaDocs.value);\n}\n\n/**\n * Whether this `meta` ObjectExpression has a `schema` property defined or not.\n *\n * @param {ASTNode} metaPropertyNode The `meta` ObjectExpression for this rule.\n * @returns {boolean} `true` if a `schema` property exists.\n */\nfunction hasMetaSchema(metaPropertyNode) {\n    return getPropertyFromObject(\"schema\", metaPropertyNode.value);\n}\n\n/**\n * Checks the validity of the meta definition of this rule and reports any errors found.\n *\n * @param {RuleContext} context The ESLint rule context.\n * @param {ASTNode} exportsNode ObjectExpression node that the rule exports.\n * @param {boolean} ruleIsFixable whether the rule is fixable or not.\n * @returns {void}\n */\nfunction checkMetaValidity(context, exportsNode) {\n    const metaProperty = getMetaPropertyFromExportsNode(exportsNode);\n\n    if (!metaProperty) {\n        context.report(exportsNode, \"Rule is missing a meta property.\");\n        return;\n    }\n\n    if (!hasMetaDocs(metaProperty)) {\n        context.report(metaProperty, \"Rule is missing a meta.docs property.\");\n        return;\n    }\n\n    if (!hasMetaDocsDescription(metaProperty)) {\n        context.report(metaProperty, \"Rule is missing a meta.docs.description property.\");\n        return;\n    }\n\n    if (!hasMetaDocsCategory(metaProperty)) {\n        context.report(metaProperty, \"Rule is missing a meta.docs.category property.\");\n        return;\n    }\n\n    if (!hasMetaDocsRecommended(metaProperty)) {\n        context.report(metaProperty, \"Rule is missing a meta.docs.recommended property.\");\n        return;\n    }\n\n    if (!hasMetaSchema(metaProperty)) {\n        context.report(metaProperty, \"Rule is missing a meta.schema property.\");\n    }\n}\n\n/**\n * Whether this node is the correct format for a rule definition or not.\n *\n * @param {ASTNode} node node that the rule exports.\n * @returns {boolean} `true` if the exported node is the correct format for a rule definition\n */\nfunction isCorrectExportsFormat(node) {\n    return node.type === \"ObjectExpression\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce correct use of `meta` property in core rules\",\n            category: \"Internal\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        let exportsNode;\n\n        return {\n            AssignmentExpression(node) {\n                if (node.left &&\n                    node.right &&\n                    node.left.type === \"MemberExpression\" &&\n                    node.left.object.name === \"module\" &&\n                    node.left.property.name === \"exports\") {\n\n                    exportsNode = node.right;\n                }\n            },\n\n            \"Program:exit\"() {\n                if (!isCorrectExportsFormat(exportsNode)) {\n                    context.report({ node: exportsNode, message: \"Rule does not export an Object. Make sure the rule follows the new rule format.\" });\n                    return;\n                }\n\n                checkMetaValidity(context, exportsNode);\n            }\n        };\n    }\n};\n"}