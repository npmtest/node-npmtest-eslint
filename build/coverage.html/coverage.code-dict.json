{"/home/travis/build/npmtest/node-npmtest-eslint/test.js":"/* istanbul instrument in package npmtest_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/lib.npmtest_eslint.js":"/* istanbul instrument in package npmtest_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_eslint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_eslint.__dirname +\n                    '/lib.npmtest_eslint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/api.js":"/**\n * @fileoverview Expose out ESLint and CLI to require.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\nmodule.exports = {\n    linter: require(\"./eslint\"),\n    CLIEngine: require(\"./cli-engine\"),\n    RuleTester: require(\"./testers/rule-tester\"),\n    SourceCode: require(\"./util/source-code\")\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/eslint.js":"/**\n * @fileoverview Main ESLint object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    EventEmitter = require(\"events\").EventEmitter,\n    escope = require(\"escope\"),\n    levn = require(\"levn\"),\n    blankScriptAST = require(\"../conf/blank-script.json\"),\n    DEFAULT_PARSER = require(\"../conf/eslint-recommended\").parser,\n    replacements = require(\"../conf/replacements.json\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    validator = require(\"./config/config-validator\"),\n    Environments = require(\"./config/environments\"),\n    CommentEventGenerator = require(\"./util/comment-event-generator\"),\n    NodeEventGenerator = require(\"./util/node-event-generator\"),\n    SourceCode = require(\"./util/source-code\"),\n    Traverser = require(\"./util/traverser\"),\n    RuleContext = require(\"./rule-context\"),\n    rules = require(\"./rules\"),\n    timing = require(\"./timing\"),\n\n    pkg = require(\"../package.json\");\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The result of a parsing operation from parseForESLint()\n * @typedef {Object} CustomParseResult\n * @property {ASTNode} ast The ESTree AST Program node.\n * @property {Object} services An object containing additional services related\n *      to the parser.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Parses a list of \"name:boolean_value\" or/and \"name\" options divided by comma or\n * whitespace.\n * @param {string} string The string to parse.\n * @param {Comment} comment The comment node which has the string.\n * @returns {Object} Result map object of names and boolean values\n */\nfunction parseBooleanConfig(string, comment) {\n    const items = {};\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n    string = string.replace(/\\s*([:,])\\s*/g, \"$1\");\n\n    string.split(/\\s|,+/).forEach(name => {\n        if (!name) {\n            return;\n        }\n        const pos = name.indexOf(\":\");\n        let value;\n\n        if (pos !== -1) {\n            value = name.substring(pos + 1, name.length);\n            name = name.substring(0, pos);\n        }\n\n        items[name] = {\n            value: (value === \"true\"),\n            comment\n        };\n\n    });\n    return items;\n}\n\n/**\n * Parses a JSON-like config.\n * @param {string} string The string to parse.\n * @param {Object} location Start line and column of comments for potential error message.\n * @param {Object[]} messages The messages queue for potential error message.\n * @returns {Object} Result map object\n */\nfunction parseJsonConfig(string, location, messages) {\n    let items = {};\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n    try {\n        items = levn.parse(\"Object\", string) || {};\n\n        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n        // Also, commaless notations have invalid severity:\n        //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n        // Should ignore that case as well.\n        if (ConfigOps.isEverySeverityValid(items)) {\n            return items;\n        }\n    } catch (ex) {\n\n        // ignore to parse the string by a fallback.\n    }\n\n    // Optionator cannot parse commaless notations.\n    // But we are supporting that. So this is a fallback for that.\n    items = {};\n    string = string.replace(/([a-zA-Z0-9\\-/]+):/g, \"\\\"$1\\\":\").replace(/(]|[0-9])\\s+(?=\")/, \"$1,\");\n    try {\n        items = JSON.parse(`{${string}}`);\n    } catch (ex) {\n\n        messages.push({\n            ruleId: null,\n            fatal: true,\n            severity: 2,\n            source: null,\n            message: `Failed to parse JSON from '${string}': ${ex.message}`,\n            line: location.start.line,\n            column: location.start.column + 1\n        });\n\n    }\n\n    return items;\n}\n\n/**\n * Parses a config of values separated by comma.\n * @param {string} string The string to parse.\n * @returns {Object} Result map of values and true values\n */\nfunction parseListConfig(string) {\n    const items = {};\n\n    // Collapse whitespace around ,\n    string = string.replace(/\\s*,\\s*/g, \",\");\n\n    string.split(/,+/).forEach(name => {\n        name = name.trim();\n        if (!name) {\n            return;\n        }\n        items[name] = true;\n    });\n    return items;\n}\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {ASTNode} program The top node of the AST.\n * @param {Scope} globalScope The global scope.\n * @param {Object} config The existing configuration data.\n * @returns {void}\n */\nfunction addDeclaredGlobals(program, globalScope, config) {\n    const declaredGlobals = {},\n        exportedGlobals = {},\n        explicitGlobals = {},\n        builtin = Environments.get(\"builtin\");\n\n    Object.assign(declaredGlobals, builtin);\n\n    Object.keys(config.env).forEach(name => {\n        if (config.env[name]) {\n            const env = Environments.get(name),\n                environmentGlobals = env && env.globals;\n\n            if (environmentGlobals) {\n                Object.assign(declaredGlobals, environmentGlobals);\n            }\n        }\n    });\n\n    Object.assign(exportedGlobals, config.exported);\n    Object.assign(declaredGlobals, config.globals);\n    Object.assign(explicitGlobals, config.astGlobals);\n\n    Object.keys(declaredGlobals).forEach(name => {\n        let variable = globalScope.set.get(name);\n\n        if (!variable) {\n            variable = new escope.Variable(name, globalScope);\n            variable.eslintExplicitGlobal = false;\n            globalScope.variables.push(variable);\n            globalScope.set.set(name, variable);\n        }\n        variable.writeable = declaredGlobals[name];\n    });\n\n    Object.keys(explicitGlobals).forEach(name => {\n        let variable = globalScope.set.get(name);\n\n        if (!variable) {\n            variable = new escope.Variable(name, globalScope);\n            variable.eslintExplicitGlobal = true;\n            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;\n            globalScope.variables.push(variable);\n            globalScope.set.set(name, variable);\n        }\n        variable.writeable = explicitGlobals[name].value;\n    });\n\n    // mark all exported variables as such\n    Object.keys(exportedGlobals).forEach(name => {\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(reference => {\n        const name = reference.identifier.name;\n        const variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * Add data to reporting configuration to disable reporting for list of rules\n * starting from start location\n * @param  {Object[]} reportingConfig Current reporting configuration\n * @param  {Object} start Position to start\n * @param  {string[]} rulesToDisable List of rules\n * @returns {void}\n */\nfunction disableReporting(reportingConfig, start, rulesToDisable) {\n\n    if (rulesToDisable.length) {\n        rulesToDisable.forEach(rule => {\n            reportingConfig.push({\n                start,\n                end: null,\n                rule\n            });\n        });\n    } else {\n        reportingConfig.push({\n            start,\n            end: null,\n            rule: null\n        });\n    }\n}\n\n/**\n * Add data to reporting configuration to enable reporting for list of rules\n * starting from start location\n * @param  {Object[]} reportingConfig Current reporting configuration\n * @param  {Object} start Position to start\n * @param  {string[]} rulesToEnable List of rules\n * @returns {void}\n */\nfunction enableReporting(reportingConfig, start, rulesToEnable) {\n    let i;\n\n    if (rulesToEnable.length) {\n        rulesToEnable.forEach(rule => {\n            for (i = reportingConfig.length - 1; i >= 0; i--) {\n                if (!reportingConfig[i].end && reportingConfig[i].rule === rule) {\n                    reportingConfig[i].end = start;\n                    break;\n                }\n            }\n        });\n    } else {\n\n        // find all previous disabled locations if they was started as list of rules\n        let prevStart;\n\n        for (i = reportingConfig.length - 1; i >= 0; i--) {\n            if (prevStart && prevStart !== reportingConfig[i].start) {\n                break;\n            }\n\n            if (!reportingConfig[i].end) {\n                reportingConfig[i].end = start;\n                prevStart = reportingConfig[i].start;\n            }\n        }\n    }\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {Object} config The existing configuration data.\n * @param {Object[]} reportingConfig The existing reporting configuration data.\n * @param {Object[]} messages The messages queue.\n * @returns {Object} Modified config object\n */\nfunction modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {\n\n    let commentConfig = {\n        exported: {},\n        astGlobals: {},\n        rules: {},\n        env: {}\n    };\n    const commentRules = {};\n\n    ast.comments.forEach(comment => {\n\n        let value = comment.value.trim();\n        const match = /^(eslint(-\\w+){0,3}|exported|globals?)(\\s|$)/.exec(value);\n\n        if (match) {\n            value = value.substring(match.index + match[1].length);\n\n            if (comment.type === \"Block\") {\n                switch (match[1]) {\n                    case \"exported\":\n                        Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));\n                        break;\n\n                    case \"globals\":\n                    case \"global\":\n                        Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));\n                        break;\n\n                    case \"eslint-env\":\n                        Object.assign(commentConfig.env, parseListConfig(value));\n                        break;\n\n                    case \"eslint-disable\":\n                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                        break;\n\n                    case \"eslint-enable\":\n                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                        break;\n\n                    case \"eslint\": {\n                        const items = parseJsonConfig(value, comment.loc, messages);\n\n                        Object.keys(items).forEach(name => {\n                            const ruleValue = items[name];\n\n                            validator.validateRuleOptions(name, ruleValue, `${filename} line ${comment.loc.start.line}`);\n                            commentRules[name] = ruleValue;\n                        });\n                        break;\n                    }\n\n                    // no default\n                }\n            } else {        // comment.type === \"Line\"\n                if (match[1] === \"eslint-disable-line\") {\n                    disableReporting(reportingConfig, { line: comment.loc.start.line, column: 0 }, Object.keys(parseListConfig(value)));\n                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));\n                } else if (match[1] === \"eslint-disable-next-line\") {\n                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                    enableReporting(reportingConfig, { line: comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));\n                }\n            }\n        }\n    });\n\n    // apply environment configs\n    Object.keys(commentConfig.env).forEach(name => {\n        const env = Environments.get(name);\n\n        if (env) {\n            commentConfig = ConfigOps.merge(commentConfig, env);\n        }\n    });\n    Object.assign(commentConfig.rules, commentRules);\n\n    return ConfigOps.merge(config, commentConfig);\n}\n\n/**\n * Check if message of rule with ruleId should be ignored in location\n * @param  {Object[]} reportingConfig  Collection of ignore records\n * @param  {string} ruleId   Id of rule\n * @param  {Object} location Location of message\n * @returns {boolean}          True if message should be ignored, false otherwise\n */\nfunction isDisabledByReportingConfig(reportingConfig, ruleId, location) {\n\n    for (let i = 0, c = reportingConfig.length; i < c; i++) {\n\n        const ignore = reportingConfig[i];\n\n        if ((!ignore.rule || ignore.rule === ruleId) &&\n            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&\n            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @param  {boolean} isModule Whether the source type is module or not\n * @returns {number} normalized ECMAScript version\n */\nfunction normalizeEcmaVersion(ecmaVersion, isModule) {\n\n    // Need at least ES6 for modules\n    if (isModule && (!ecmaVersion || ecmaVersion < 6)) {\n        ecmaVersion = 6;\n    }\n\n    // Calculate ECMAScript edition number from official year version starting with\n    // ES2015, which corresponds with ES6 (or a difference of 2009).\n    if (ecmaVersion >= 2015) {\n        ecmaVersion -= 2009;\n    }\n\n    return ecmaVersion;\n}\n\n/**\n * Process initial config to make it safe to extend by file comment config\n * @param  {Object} config Initial config\n * @returns {Object}        Processed config\n */\nfunction prepareConfig(config) {\n\n    config.globals = config.globals || config.global || {};\n    delete config.global;\n\n    const copiedRules = {};\n    let parserOptions = {};\n\n    if (typeof config.rules === \"object\") {\n        Object.keys(config.rules).forEach(k => {\n            const rule = config.rules[k];\n\n            if (rule === null) {\n                throw new Error(`Invalid config for rule '${k}'.`);\n            }\n            if (Array.isArray(rule)) {\n                copiedRules[k] = rule.slice();\n            } else {\n                copiedRules[k] = rule;\n            }\n        });\n    }\n\n    // merge in environment parserOptions\n    if (typeof config.env === \"object\") {\n        Object.keys(config.env).forEach(envName => {\n            const env = Environments.get(envName);\n\n            if (config.env[envName] && env && env.parserOptions) {\n                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);\n            }\n        });\n    }\n\n    const preparedConfig = {\n        rules: copiedRules,\n        parser: config.parser || DEFAULT_PARSER,\n        globals: ConfigOps.merge({}, config.globals),\n        env: ConfigOps.merge({}, config.env || {}),\n        settings: ConfigOps.merge({}, config.settings || {}),\n        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})\n    };\n    const isModule = preparedConfig.parserOptions.sourceType === \"module\";\n\n    if (isModule) {\n        if (!preparedConfig.parserOptions.ecmaFeatures) {\n            preparedConfig.parserOptions.ecmaFeatures = {};\n        }\n\n        // can't have global return inside of modules\n        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;\n    }\n\n    preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);\n\n    return preparedConfig;\n}\n\n/**\n * Provide a stub rule with a given message\n * @param  {string} message The message to be displayed for the rule\n * @returns {Function}      Stub rule function\n */\nfunction createStubRule(message) {\n\n    /**\n     * Creates a fake rule object\n     * @param {Object} context context object for each rule\n     * @returns {Object} collection of node to listen on\n     */\n    function createRuleModule(context) {\n        return {\n            Program(node) {\n                context.report(node, message);\n            }\n        };\n    }\n\n    if (message) {\n        return createRuleModule;\n    }\n    throw new Error(\"No message passed to stub rule\");\n\n}\n\n/**\n * Provide a rule replacement message\n * @param  {string} ruleId Name of the rule\n * @returns {string}       Message detailing rule replacement\n */\nfunction getRuleReplacementMessage(ruleId) {\n    if (ruleId in replacements.rules) {\n        const newRules = replacements.rules[ruleId];\n\n        return `Rule '${ruleId}' was removed and replaced by: ${newRules.join(\", \")}`;\n    }\n\n    return null;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//g;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    let match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text))) {\n        retv = Object.assign(retv || {}, parseListConfig(match[1]));\n    }\n\n    return retv;\n}\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\nmodule.exports = (function() {\n\n    const api = Object.create(new EventEmitter());\n    let messages = [],\n        currentConfig = null,\n        currentScopes = null,\n        scopeManager = null,\n        currentFilename = null,\n        traverser = null,\n        reportingConfig = [],\n        sourceCode = null;\n\n    /**\n     * Parses text into an AST. Moved out here because the try-catch prevents\n     * optimization of functions, so it's best to keep the try-catch as isolated\n     * as possible\n     * @param {string} text The text to parse.\n     * @param {Object} config The ESLint configuration object.\n     * @param {string} filePath The path to the file being parsed.\n     * @returns {ASTNode|CustomParseResult} The AST or parse result if successful,\n     *      or null if not.\n     * @private\n     */\n    function parse(text, config, filePath) {\n\n        let parser,\n            parserOptions = {\n                loc: true,\n                range: true,\n                raw: true,\n                tokens: true,\n                comment: true,\n                attachComment: true,\n                filePath\n            };\n\n        try {\n            parser = require(config.parser);\n        } catch (ex) {\n            messages.push({\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                source: null,\n                message: ex.message,\n                line: 0,\n                column: 0\n            });\n\n            return null;\n        }\n\n        // merge in any additional parser options\n        if (config.parserOptions) {\n            parserOptions = Object.assign({}, config.parserOptions, parserOptions);\n        }\n\n        /*\n         * Check for parsing errors first. If there's a parsing error, nothing\n         * else can happen. However, a parsing error does not throw an error\n         * from this method - it's just considered a fatal error message, a\n         * problem that ESLint identified just like any other.\n         */\n        try {\n            if (typeof parser.parseForESLint === \"function\") {\n                return parser.parseForESLint(text, parserOptions);\n            }\n            return parser.parse(text, parserOptions);\n\n        } catch (ex) {\n\n            // If the message includes a leading line number, strip it:\n            const message = ex.message.replace(/^line \\d+:/i, \"\").trim();\n            const source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;\n\n            messages.push({\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                source,\n                message: `Parsing error: ${message}`,\n\n                line: ex.lineNumber,\n                column: ex.column\n            });\n\n            return null;\n        }\n    }\n\n    /**\n     * Get the severity level of a rule (0 - none, 1 - warning, 2 - error)\n     * Returns 0 if the rule config is not valid (an Array or a number)\n     * @param {Array|number} ruleConfig rule configuration\n     * @returns {number} 0, 1, or 2, indicating rule severity\n     */\n    function getRuleSeverity(ruleConfig) {\n        if (typeof ruleConfig === \"number\") {\n            return ruleConfig;\n        } else if (Array.isArray(ruleConfig)) {\n            return ruleConfig[0];\n        }\n        return 0;\n\n    }\n\n    /**\n     * Get the options for a rule (not including severity), if any\n     * @param {Array|number} ruleConfig rule configuration\n     * @returns {Array} of rule options, empty Array if none\n     */\n    function getRuleOptions(ruleConfig) {\n        if (Array.isArray(ruleConfig)) {\n            return ruleConfig.slice(1);\n        }\n        return [];\n\n    }\n\n    // set unlimited listeners (see https://github.com/eslint/eslint/issues/524)\n    api.setMaxListeners(0);\n\n    /**\n     * Resets the internal state of the object.\n     * @returns {void}\n     */\n    api.reset = function() {\n        this.removeAllListeners();\n        messages = [];\n        currentConfig = null;\n        currentScopes = null;\n        scopeManager = null;\n        traverser = null;\n        reportingConfig = [];\n        sourceCode = null;\n    };\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globalsto the code.\n     */\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.\n     *      Mostly useful for testing purposes.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {\n        const text = (typeof textOrSourceCode === \"string\") ? textOrSourceCode : null;\n        let ast,\n            parseResult,\n            shebang,\n            allowInlineConfig;\n\n        // evaluate arguments\n        if (typeof filenameOrOptions === \"object\") {\n            currentFilename = filenameOrOptions.filename;\n            allowInlineConfig = filenameOrOptions.allowInlineConfig;\n            saveState = filenameOrOptions.saveState;\n        } else {\n            currentFilename = filenameOrOptions;\n        }\n\n        if (!saveState) {\n            this.reset();\n        }\n\n        // search and apply \"eslint-env *\".\n        const envInFile = findEslintEnv(text || textOrSourceCode.text);\n\n        config = Object.assign({}, config);\n\n        if (envInFile) {\n            if (config.env) {\n                config.env = Object.assign({}, config.env, envInFile);\n            } else {\n                config.env = envInFile;\n            }\n        }\n\n        // process initial config to make it safe to extend\n        config = prepareConfig(config);\n\n        // only do this for text\n        if (text !== null) {\n\n            // there's no input, just exit here\n            if (text.trim().length === 0) {\n                sourceCode = new SourceCode(text, blankScriptAST);\n                return messages;\n            }\n\n            parseResult = parse(\n                stripUnicodeBOM(text).replace(/^#!([^\\r\\n]+)/, (match, captured) => {\n                    shebang = captured;\n                    return `//${captured}`;\n                }),\n                config,\n                currentFilename\n            );\n\n            // if this result is from a parseForESLint() method, normalize\n            if (parseResult && parseResult.ast) {\n                ast = parseResult.ast;\n            } else {\n                ast = parseResult;\n                parseResult = null;\n            }\n\n            if (ast) {\n                sourceCode = new SourceCode(text, ast);\n            }\n\n        } else {\n            sourceCode = textOrSourceCode;\n            ast = sourceCode.ast;\n        }\n\n        // if espree failed to parse the file, there's no sense in setting up rules\n        if (ast) {\n\n            // parse global comments and modify config\n            if (allowInlineConfig !== false) {\n                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);\n            }\n\n            // ensure that severities are normalized in the config\n            ConfigOps.normalize(config);\n\n            // enable appropriate rules\n            Object.keys(config.rules).filter(key => getRuleSeverity(config.rules[key]) > 0).forEach(key => {\n                let ruleCreator;\n\n                ruleCreator = rules.get(key);\n\n                if (!ruleCreator) {\n                    const replacementMsg = getRuleReplacementMessage(key);\n\n                    if (replacementMsg) {\n                        ruleCreator = createStubRule(replacementMsg);\n                    } else {\n                        ruleCreator = createStubRule(`Definition for rule '${key}' was not found`);\n                    }\n                    rules.define(key, ruleCreator);\n                }\n\n                const severity = getRuleSeverity(config.rules[key]);\n                const options = getRuleOptions(config.rules[key]);\n\n                try {\n                    const ruleContext = new RuleContext(\n                        key, api, severity, options,\n                        config.settings, config.parserOptions, config.parser,\n                        ruleCreator.meta,\n                        (parseResult && parseResult.services ? parseResult.services : {})\n                    );\n\n                    const rule = ruleCreator.create ? ruleCreator.create(ruleContext)\n                        : ruleCreator(ruleContext);\n\n                    // add all the selectors from the rule as listeners\n                    Object.keys(rule).forEach(selector => {\n                        api.on(selector, timing.enabled\n                            ? timing.time(key, rule[selector])\n                            : rule[selector]\n                        );\n                    });\n                } catch (ex) {\n                    ex.message = `Error while loading rule '${key}': ${ex.message}`;\n                    throw ex;\n                }\n            });\n\n            // save config so rules can access as necessary\n            currentConfig = config;\n            traverser = new Traverser();\n\n            const ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};\n            const ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;\n\n            // gather scope data that may be needed by the rules\n            scopeManager = escope.analyze(ast, {\n                ignoreEval: true,\n                nodejsScope: ecmaFeatures.globalReturn,\n                impliedStrict: ecmaFeatures.impliedStrict,\n                ecmaVersion,\n                sourceType: currentConfig.parserOptions.sourceType || \"script\",\n                fallback: Traverser.getKeys\n            });\n\n            currentScopes = scopeManager.scopes;\n\n            // augment global scope with declared global variables\n            addDeclaredGlobals(ast, currentScopes[0], currentConfig);\n\n            // remove shebang comments\n            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {\n                ast.comments.splice(0, 1);\n\n                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {\n                    ast.body[0].leadingComments.splice(0, 1);\n                }\n            }\n\n            let eventGenerator = new NodeEventGenerator(api);\n\n            eventGenerator = new CodePathAnalyzer(eventGenerator);\n            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);\n\n            /*\n             * Each node has a type property. Whenever a particular type of\n             * node is found, an event is fired. This allows any listeners to\n             * automatically be informed that this type of node has been found\n             * and react accordingly.\n             */\n            traverser.traverse(ast, {\n                enter(node, parent) {\n                    node.parent = parent;\n                    eventGenerator.enterNode(node);\n                },\n                leave(node) {\n                    eventGenerator.leaveNode(node);\n                }\n            });\n        }\n\n        // sort by line and column\n        messages.sort((a, b) => {\n            const lineDiff = a.line - b.line;\n\n            if (lineDiff === 0) {\n                return a.column - b.column;\n            }\n            return lineDiff;\n\n        });\n\n        return messages;\n    };\n\n    /**\n     * Reports a message from one of the rules.\n     * @param {string} ruleId The ID of the rule causing the message.\n     * @param {number} severity The severity level of the rule as configured.\n     * @param {ASTNode} node The AST node that the message relates to.\n     * @param {Object=} location An object containing the error line and column\n     *      numbers. If location is not provided the node's start location will\n     *      be used.\n     * @param {string} message The actual message.\n     * @param {Object} opts Optional template data which produces a formatted message\n     *     with symbols being replaced by this object's values.\n     * @param {Object} fix A fix command description.\n     * @param {Object} meta Metadata of the rule\n     * @returns {void}\n     */\n    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {\n        if (node) {\n            assert.strictEqual(typeof node, \"object\", \"Node must be an object\");\n        }\n\n        if (typeof location === \"string\") {\n            assert.ok(node, \"Node must be provided when reporting error if location is not provided\");\n\n            meta = fix;\n            fix = opts;\n            opts = message;\n            message = location;\n            location = node.loc.start;\n        }\n\n        // Store end location.\n        const endLocation = location.end;\n\n        location = location.start || location;\n\n        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {\n            return;\n        }\n\n        if (opts) {\n            message = message.replace(/\\{\\{\\s*([^{}]+?)\\s*\\}\\}/g, (fullMatch, term) => {\n                if (term in opts) {\n                    return opts[term];\n                }\n\n                // Preserve old behavior: If parameter name not provided, don't replace it.\n                return fullMatch;\n            });\n        }\n\n        const problem = {\n            ruleId,\n            severity,\n            message,\n            line: location.line,\n            column: location.column + 1,   // switch to 1-base instead of 0-base\n            nodeType: node && node.type,\n            source: sourceCode.lines[location.line - 1] || \"\"\n        };\n\n        // Define endLine and endColumn if exists.\n        if (endLocation) {\n            problem.endLine = endLocation.line;\n            problem.endColumn = endLocation.column + 1;   // switch to 1-base instead of 0-base\n        }\n\n        // ensure there's range and text properties, otherwise it's not a valid fix\n        if (fix && Array.isArray(fix.range) && (typeof fix.text === \"string\")) {\n\n            // If rule uses fix, has metadata, but has no metadata.fixable, we should throw\n            if (meta && !meta.fixable) {\n                throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n            }\n\n            problem.fix = fix;\n        }\n\n        messages.push(problem);\n    };\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    api.getSourceCode = function() {\n        return sourceCode;\n    };\n\n    // methods that exist on SourceCode object\n    const externalMethods = {\n        getSource: \"getText\",\n        getSourceLines: \"getLines\",\n        getAllComments: \"getAllComments\",\n        getNodeByRangeIndex: \"getNodeByRangeIndex\",\n        getComments: \"getComments\",\n        getJSDocComment: \"getJSDocComment\",\n        getFirstToken: \"getFirstToken\",\n        getFirstTokens: \"getFirstTokens\",\n        getLastToken: \"getLastToken\",\n        getLastTokens: \"getLastTokens\",\n        getTokenAfter: \"getTokenAfter\",\n        getTokenBefore: \"getTokenBefore\",\n        getTokenByRangeStart: \"getTokenByRangeStart\",\n        getTokens: \"getTokens\",\n        getTokensAfter: \"getTokensAfter\",\n        getTokensBefore: \"getTokensBefore\",\n        getTokensBetween: \"getTokensBetween\"\n    };\n\n    // copy over methods\n    Object.keys(externalMethods).forEach(methodName => {\n        const exMethodName = externalMethods[methodName];\n\n        // All functions expected to have less arguments than 5.\n        api[methodName] = function(a, b, c, d, e) {\n            if (sourceCode) {\n                return sourceCode[exMethodName](a, b, c, d, e);\n            }\n            return null;\n        };\n    });\n\n    /**\n     * Gets nodes that are ancestors of current node.\n     * @returns {ASTNode[]} Array of objects representing ancestors.\n     */\n    api.getAncestors = function() {\n        return traverser.parents();\n    };\n\n    /**\n     * Gets the scope for the current node.\n     * @returns {Object} An object representing the current node's scope.\n     */\n    api.getScope = function() {\n        const parents = traverser.parents();\n\n        // Don't do this for Program nodes - they have no parents\n        if (parents.length) {\n\n            // if current node introduces a scope, add it to the list\n            const current = traverser.current();\n\n            if (currentConfig.parserOptions.ecmaVersion >= 6) {\n                if ([\"BlockStatement\", \"SwitchStatement\", \"CatchClause\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(current.type) >= 0) {\n                    parents.push(current);\n                }\n            } else {\n                if ([\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(current.type) >= 0) {\n                    parents.push(current);\n                }\n            }\n\n            // Ascend the current node's parents\n            for (let i = parents.length - 1; i >= 0; --i) {\n\n                // Get the innermost scope\n                const scope = scopeManager.acquire(parents[i], true);\n\n                if (scope) {\n                    if (scope.type === \"function-expression-name\") {\n                        return scope.childScopes[0];\n                    }\n                    return scope;\n\n                }\n\n            }\n\n        }\n\n        return currentScopes[0];\n    };\n\n    /**\n     * Record that a particular variable has been used in code\n     * @param {string} name The name of the variable to mark as used\n     * @returns {boolean} True if the variable was found and marked as used,\n     *      false if not.\n     */\n    api.markVariableAsUsed = function(name) {\n        const hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,\n            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === \"module\";\n        let scope = this.getScope(),\n            i,\n            len;\n\n        // Special Node.js scope means we need to start one level deeper\n        if (scope.type === \"global\" && specialScope) {\n            scope = scope.childScopes[0];\n        }\n\n        do {\n            const variables = scope.variables;\n\n            for (i = 0, len = variables.length; i < len; i++) {\n                if (variables[i].name === name) {\n                    variables[i].eslintUsed = true;\n                    return true;\n                }\n            }\n        } while ((scope = scope.upper));\n\n        return false;\n    };\n\n    /**\n     * Gets the filename for the currently parsed source.\n     * @returns {string} The filename associated with the source being parsed.\n     *     Defaults to \"<input>\" if no filename info is present.\n     */\n    api.getFilename = function() {\n        if (typeof currentFilename === \"string\") {\n            return currentFilename;\n        }\n        return \"<input>\";\n\n    };\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    const defineRule = api.defineRule = function(ruleId, ruleModule) {\n        rules.define(ruleId, ruleModule);\n    };\n\n    /**\n     * Defines many new linting rules.\n     * @param {Object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    api.defineRules = function(rulesToDefine) {\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n            defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    };\n\n    /**\n     * Gets the default eslint configuration.\n     * @returns {Object} Object mapping rule IDs to their default configurations\n     */\n    api.defaults = function() {\n        return require(\"../conf/eslint-recommended\");\n    };\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map} All loaded rules\n     */\n    api.getRules = function() {\n        return rules.getAllLoadedRules();\n    };\n\n    api.version = pkg.version;\n\n    /**\n     * Gets variables that are declared by a specified node.\n     *\n     * The variables are its `defs[].node` or `defs[].parent` is same as the specified node.\n     * Specifically, below:\n     *\n     * - `VariableDeclaration` - variables of its all declarators.\n     * - `VariableDeclarator` - variables.\n     * - `FunctionDeclaration`/`FunctionExpression` - its function name and parameters.\n     * - `ArrowFunctionExpression` - its parameters.\n     * - `ClassDeclaration`/`ClassExpression` - its class name.\n     * - `CatchClause` - variables of its exception.\n     * - `ImportDeclaration` - variables of  its all specifiers.\n     * - `ImportSpecifier`/`ImportDefaultSpecifier`/`ImportNamespaceSpecifier` - a variable.\n     * - others - always an empty array.\n     *\n     * @param {ASTNode} node A node to get.\n     * @returns {escope.Variable[]} Variables that are declared by the node.\n     */\n    api.getDeclaredVariables = function(node) {\n        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];\n    };\n\n    return api;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/conf/eslint-recommended.js":"/**\n * @fileoverview Configuration applied when a user configuration extends from\n * eslint:recommended.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/* eslint sort-keys: [\"error\", \"asc\"], quote-props: [\"error\", \"consistent\"] */\n/* eslint-disable sort-keys */\n\nmodule.exports = {\n    parser: \"espree\",\n    ecmaFeatures: {},\n\n    rules: {\n\n        /* eslint-enable sort-keys */\n        \"accessor-pairs\": \"off\",\n        \"array-bracket-spacing\": \"off\",\n        \"array-callback-return\": \"off\",\n        \"arrow-body-style\": \"off\",\n        \"arrow-parens\": \"off\",\n        \"arrow-spacing\": \"off\",\n        \"block-scoped-var\": \"off\",\n        \"block-spacing\": \"off\",\n        \"brace-style\": \"off\",\n        \"callback-return\": \"off\",\n        \"camelcase\": \"off\",\n        \"capitalized-comments\": \"off\",\n        \"class-methods-use-this\": \"off\",\n        \"comma-dangle\": \"off\",\n        \"comma-spacing\": \"off\",\n        \"comma-style\": \"off\",\n        \"complexity\": \"off\",\n        \"computed-property-spacing\": \"off\",\n        \"consistent-return\": \"off\",\n        \"consistent-this\": \"off\",\n        \"constructor-super\": \"error\",\n        \"curly\": \"off\",\n        \"default-case\": \"off\",\n        \"dot-location\": \"off\",\n        \"dot-notation\": \"off\",\n        \"eol-last\": \"off\",\n        \"eqeqeq\": \"off\",\n        \"func-call-spacing\": \"off\",\n        \"func-name-matching\": \"off\",\n        \"func-names\": \"off\",\n        \"func-style\": \"off\",\n        \"generator-star-spacing\": \"off\",\n        \"global-require\": \"off\",\n        \"guard-for-in\": \"off\",\n        \"handle-callback-err\": \"off\",\n        \"id-blacklist\": \"off\",\n        \"id-length\": \"off\",\n        \"id-match\": \"off\",\n        \"indent\": \"off\",\n        \"init-declarations\": \"off\",\n        \"jsx-quotes\": \"off\",\n        \"key-spacing\": \"off\",\n        \"keyword-spacing\": \"off\",\n        \"line-comment-position\": \"off\",\n        \"linebreak-style\": \"off\",\n        \"lines-around-comment\": \"off\",\n        \"lines-around-directive\": \"off\",\n        \"max-depth\": \"off\",\n        \"max-len\": \"off\",\n        \"max-lines\": \"off\",\n        \"max-nested-callbacks\": \"off\",\n        \"max-params\": \"off\",\n        \"max-statements\": \"off\",\n        \"max-statements-per-line\": \"off\",\n        \"multiline-ternary\": \"off\",\n        \"new-cap\": \"off\",\n        \"new-parens\": \"off\",\n        \"newline-after-var\": \"off\",\n        \"newline-before-return\": \"off\",\n        \"newline-per-chained-call\": \"off\",\n        \"no-alert\": \"off\",\n        \"no-array-constructor\": \"off\",\n        \"no-await-in-loop\": \"off\",\n        \"no-bitwise\": \"off\",\n        \"no-caller\": \"off\",\n        \"no-case-declarations\": \"error\",\n        \"no-catch-shadow\": \"off\",\n        \"no-class-assign\": \"error\",\n        \"no-compare-neg-zero\": \"off\",\n        \"no-cond-assign\": \"error\",\n        \"no-confusing-arrow\": \"off\",\n        \"no-console\": \"error\",\n        \"no-const-assign\": \"error\",\n        \"no-constant-condition\": \"error\",\n        \"no-continue\": \"off\",\n        \"no-control-regex\": \"error\",\n        \"no-debugger\": \"error\",\n        \"no-delete-var\": \"error\",\n        \"no-div-regex\": \"off\",\n        \"no-dupe-args\": \"error\",\n        \"no-dupe-class-members\": \"error\",\n        \"no-dupe-keys\": \"error\",\n        \"no-duplicate-case\": \"error\",\n        \"no-duplicate-imports\": \"off\",\n        \"no-else-return\": \"off\",\n        \"no-empty\": \"error\",\n        \"no-empty-character-class\": \"error\",\n        \"no-empty-function\": \"off\",\n        \"no-empty-pattern\": \"error\",\n        \"no-eq-null\": \"off\",\n        \"no-eval\": \"off\",\n        \"no-ex-assign\": \"error\",\n        \"no-extend-native\": \"off\",\n        \"no-extra-bind\": \"off\",\n        \"no-extra-boolean-cast\": \"error\",\n        \"no-extra-label\": \"off\",\n        \"no-extra-parens\": \"off\",\n        \"no-extra-semi\": \"error\",\n        \"no-fallthrough\": \"error\",\n        \"no-floating-decimal\": \"off\",\n        \"no-func-assign\": \"error\",\n        \"no-global-assign\": \"error\",\n        \"no-implicit-coercion\": \"off\",\n        \"no-implicit-globals\": \"off\",\n        \"no-implied-eval\": \"off\",\n        \"no-inline-comments\": \"off\",\n        \"no-inner-declarations\": \"error\",\n        \"no-invalid-regexp\": \"error\",\n        \"no-invalid-this\": \"off\",\n        \"no-irregular-whitespace\": \"error\",\n        \"no-iterator\": \"off\",\n        \"no-label-var\": \"off\",\n        \"no-labels\": \"off\",\n        \"no-lone-blocks\": \"off\",\n        \"no-lonely-if\": \"off\",\n        \"no-loop-func\": \"off\",\n        \"no-magic-numbers\": \"off\",\n        \"no-mixed-operators\": \"off\",\n        \"no-mixed-requires\": \"off\",\n        \"no-mixed-spaces-and-tabs\": \"error\",\n        \"no-multi-assign\": \"off\",\n        \"no-multi-spaces\": \"off\",\n        \"no-multi-str\": \"off\",\n        \"no-multiple-empty-lines\": \"off\",\n        \"no-native-reassign\": \"off\",\n        \"no-negated-condition\": \"off\",\n        \"no-negated-in-lhs\": \"off\",\n        \"no-nested-ternary\": \"off\",\n        \"no-new\": \"off\",\n        \"no-new-func\": \"off\",\n        \"no-new-object\": \"off\",\n        \"no-new-require\": \"off\",\n        \"no-new-symbol\": \"error\",\n        \"no-new-wrappers\": \"off\",\n        \"no-obj-calls\": \"error\",\n        \"no-octal\": \"error\",\n        \"no-octal-escape\": \"off\",\n        \"no-param-reassign\": \"off\",\n        \"no-path-concat\": \"off\",\n        \"no-plusplus\": \"off\",\n        \"no-process-env\": \"off\",\n        \"no-process-exit\": \"off\",\n        \"no-proto\": \"off\",\n        \"no-prototype-builtins\": \"off\",\n        \"no-redeclare\": \"error\",\n        \"no-regex-spaces\": \"error\",\n        \"no-restricted-globals\": \"off\",\n        \"no-restricted-imports\": \"off\",\n        \"no-restricted-modules\": \"off\",\n        \"no-restricted-properties\": \"off\",\n        \"no-restricted-syntax\": \"off\",\n        \"no-return-assign\": \"off\",\n        \"no-return-await\": \"off\",\n        \"no-script-url\": \"off\",\n        \"no-self-assign\": \"error\",\n        \"no-self-compare\": \"off\",\n        \"no-sequences\": \"off\",\n        \"no-shadow\": \"off\",\n        \"no-shadow-restricted-names\": \"off\",\n        \"no-spaced-func\": \"off\",\n        \"no-sparse-arrays\": \"error\",\n        \"no-sync\": \"off\",\n        \"no-tabs\": \"off\",\n        \"no-template-curly-in-string\": \"off\",\n        \"no-ternary\": \"off\",\n        \"no-this-before-super\": \"error\",\n        \"no-throw-literal\": \"off\",\n        \"no-trailing-spaces\": \"off\",\n        \"no-undef\": \"error\",\n        \"no-undef-init\": \"off\",\n        \"no-undefined\": \"off\",\n        \"no-underscore-dangle\": \"off\",\n        \"no-unexpected-multiline\": \"error\",\n        \"no-unmodified-loop-condition\": \"off\",\n        \"no-unneeded-ternary\": \"off\",\n        \"no-unreachable\": \"error\",\n        \"no-unsafe-finally\": \"error\",\n        \"no-unsafe-negation\": \"error\",\n        \"no-unused-expressions\": \"off\",\n        \"no-unused-labels\": \"error\",\n        \"no-unused-vars\": \"error\",\n        \"no-use-before-define\": \"off\",\n        \"no-useless-call\": \"off\",\n        \"no-useless-computed-key\": \"off\",\n        \"no-useless-concat\": \"off\",\n        \"no-useless-constructor\": \"off\",\n        \"no-useless-escape\": \"off\",\n        \"no-useless-rename\": \"off\",\n        \"no-useless-return\": \"off\",\n        \"no-var\": \"off\",\n        \"no-void\": \"off\",\n        \"no-warning-comments\": \"off\",\n        \"no-whitespace-before-property\": \"off\",\n        \"no-with\": \"off\",\n        \"nonblock-statement-body-position\": \"off\",\n        \"object-curly-newline\": \"off\",\n        \"object-curly-spacing\": [\"off\", \"never\"],\n        \"object-property-newline\": \"off\",\n        \"object-shorthand\": \"off\",\n        \"one-var\": \"off\",\n        \"one-var-declaration-per-line\": \"off\",\n        \"operator-assignment\": \"off\",\n        \"operator-linebreak\": \"off\",\n        \"padded-blocks\": \"off\",\n        \"prefer-arrow-callback\": \"off\",\n        \"prefer-const\": \"off\",\n        \"prefer-destructuring\": \"off\",\n        \"prefer-numeric-literals\": \"off\",\n        \"prefer-promise-reject-errors\": \"off\",\n        \"prefer-reflect\": \"off\",\n        \"prefer-rest-params\": \"off\",\n        \"prefer-spread\": \"off\",\n        \"prefer-template\": \"off\",\n        \"quote-props\": \"off\",\n        \"quotes\": \"off\",\n        \"radix\": \"off\",\n        \"require-await\": \"off\",\n        \"require-jsdoc\": \"off\",\n        \"require-yield\": \"error\",\n        \"rest-spread-spacing\": \"off\",\n        \"semi\": \"off\",\n        \"semi-spacing\": \"off\",\n        \"sort-imports\": \"off\",\n        \"sort-keys\": \"off\",\n        \"sort-vars\": \"off\",\n        \"space-before-blocks\": \"off\",\n        \"space-before-function-paren\": \"off\",\n        \"space-in-parens\": \"off\",\n        \"space-infix-ops\": \"off\",\n        \"space-unary-ops\": \"off\",\n        \"spaced-comment\": \"off\",\n        \"strict\": \"off\",\n        \"symbol-description\": \"off\",\n        \"template-curly-spacing\": \"off\",\n        \"template-tag-spacing\": \"off\",\n        \"unicode-bom\": \"off\",\n        \"use-isnan\": \"error\",\n        \"valid-jsdoc\": \"off\",\n        \"valid-typeof\": \"error\",\n        \"vars-on-top\": \"off\",\n        \"wrap-iife\": \"off\",\n        \"wrap-regex\": \"off\",\n        \"yield-star-spacing\": \"off\",\n        \"yoda\": \"off\"\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/code-path-analyzer.js":"/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n *\n * @param {ASTNode} node - A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n *\n * @param {ASTNode} node - An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const currentSegments = state.currentSegments;\n    const headSegments = state.headSegments;\n    const end = Math.max(currentSegments.length, headSegments.length);\n    let i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node);\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node);\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    const state = CodePath.getState(analyzer.codePath);\n    const currentSegments = state.currentSegments;\n\n    for (let i = 0; i < currentSegments.length; ++i) {\n        const currentSegment = currentSegments[i];\n\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node);\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (parent.type) {\n        case \"LogicalExpression\":\n            if (parent.right === node) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    let codePath = analyzer.codePath;\n    let state = codePath && CodePath.getState(codePath);\n    const parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(`onCodePathStart ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"LogicalExpression\":\n            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                astUtils.getLabel(node));\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, astUtils.getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    const codePath = analyzer.codePath;\n    const state = CodePath.getState(codePath);\n    let dontForward = false;\n\n    switch (node.type) {\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n        case \"LogicalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    if (!dontForward) {\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\": {\n            let codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(`onCodePathEnd ${codePath.id}`);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n        }\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\nclass CodePathAnalyzer {\n\n    /**\n     * @param {EventGenerator} eventGenerator - An event generator to wrap.\n     */\n    constructor(eventGenerator) {\n        this.original = eventGenerator;\n        this.emitter = eventGenerator.emitter;\n        this.codePath = null;\n        this.idGenerator = new IdGenerator(\"s\");\n        this.currentNode = null;\n        this.onLooped = this.onLooped.bind(this);\n    }\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is entering.\n     * @returns {void}\n     */\n    enterNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        // Updates the code path.\n        // And emits onCodePathStart/onCodePathSegmentStart events.\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.currentNode = node;\n\n        // Updates the code path.\n        // And emits onCodePathStart/onCodePathSegmentStart events.\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    }\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     *\n     * @param {CodePathSegment} fromSegment - A segment of prev.\n     * @param {CodePathSegment} toSegment - A segment of next.\n     * @returns {void}\n     */\n    onLooped(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n}\n\nmodule.exports = CodePathAnalyzer;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/code-path.js":"/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    /**\n     * @param {string} id - An identifier.\n     * @param {CodePath|null} upper - The code path of the upper function scope.\n     * @param {Function} onLooped - A callback function to notify looping.\n     */\n    constructor(id, upper, onLooped) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) });\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     *\n     * @param {CodePath} codePath - A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments.\n     * This array is a mix of `returnedSegments` and `thrownSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments which is with `return` statements.\n     * This array contains the last path segment if it's reachable.\n     * Since the reachable last path returns `undefined`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments which is with `throw` statements.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Current code path segments.\n     * @type {CodePathSegment[]}\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments(function(segment, controller) {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` object has two methods.\n     *\n     * - `controller.skip()` - Skip the following segments in this branch.\n     * - `controller.break()` - Skip all following segments.\n     *\n     * @param {Object} [options] - Omittable.\n     * @param {CodePathSegment} [options.first] - The first segment to traverse.\n     * @param {CodePathSegment} [options.last] - The last segment to traverse.\n     * @param {Function} callback - A callback function.\n     * @returns {void}\n     */\n    traverseSegments(options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = null;\n        }\n\n        options = options || {};\n        const startSegment = options.first || this.internal.initialSegment;\n        const lastSegment = options.last;\n\n        let item = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n        const visited = Object.create(null);\n        const stack = [[startSegment, 0]];\n        let skippedSegment = null;\n        let broken = false;\n        const controller = {\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment - A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited[prevSegment.id] ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        while (stack.length > 0) {\n            item = stack[stack.length - 1];\n            segment = item[0];\n            index = item[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited[segment.id]) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the flag of skipping if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n                    skippedSegment = null;\n                }\n                visited[segment.id] = true;\n\n                // Call the callback when the first time.\n                if (!skippedSegment) {\n                    callback.call(this, segment, controller); // eslint-disable-line callback-return\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n                item[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n                item[0] = segment.nextSegments[index];\n                item[1] = 0;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/code-path-state.js":"/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n *\n * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments - Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    let context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    let context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    let context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n *\n * @param {any[]} xs - An array to remove the specific element.\n * @param {any} x - An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n *\n * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (let i = 0; i < prevSegments.length; ++i) {\n        const prevSegment = prevSegments[i];\n        const nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n *\n * @param {CodePathState} state - The instance.\n * @param {CodePathSegment[]} fromSegments - Segments which are source.\n * @param {CodePathSegment[]} toSegments - Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, fromSegments, toSegments) {\n    const end = Math.min(fromSegments.length, toSegments.length);\n\n    for (let i = 0; i < end; ++i) {\n        const fromSegment = fromSegments[i];\n        const toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n *\n * @param {LoopContext} context - A loop context to modify.\n * @param {ChoiceContext} choiceContext - A choice context of this loop.\n * @param {CodePathSegment[]} head - The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\nclass CodePathState {\n\n    /**\n     * @param {IdGenerator} idGenerator - An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped - A callback function to notify looping.\n     */\n    constructor(idGenerator, onLooped) {\n        this.idGenerator = idGenerator;\n        this.notifyLooped = onLooped;\n        this.forkContext = ForkContext.newRoot(idGenerator);\n        this.choiceContext = null;\n        this.switchContext = null;\n        this.tryContext = null;\n        this.loopContext = null;\n        this.breakContext = null;\n\n        this.currentSegments = [];\n        this.initialSegment = this.forkContext.head[ 0 ];\n\n        // returnedSegments and thrownSegments push elements into finalSegments also.\n        const final = this.finalSegments = [];\n        const returned = this.returnedForkContext = [];\n        const thrown = this.thrownForkContext = [];\n\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    }\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        const current = this.forkContext;\n\n        return current && current.upper;\n    }\n\n    /**\n     * Creates and stacks new forking context.\n     *\n     * @param {boolean} forkLeavingPath - A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    }\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext() {\n        const lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    }\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    }\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     *\n     * @returns {void}\n     */\n    forkBypassPath() {\n        this.forkContext.add(this.parentForkContext.head);\n    }\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression,\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     *\n     * @param {string} kind - A kind string.\n     *   If the new context is LogicalExpression's, this is `\"&&\"` or `\"||\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult - A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind,\n            isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    }\n\n    /**\n     * Pops the last choice context and finalizes it.\n     *\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext() {\n        const context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    const parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        const prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    }\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     *\n     * @returns {void}\n     */\n    makeLogicalRight() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            const prevForkContext =\n                context.kind === \"&&\" ? context.trueForkContext\n                /* kind === \"||\" */ : context.falseForkContext;\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            if (context.kind === \"&&\") {\n\n                // The path does short-circuit if false.\n                context.falseForkContext.add(forkContext.head);\n            } else {\n\n                // The path does short-circuit if true.\n                context.trueForkContext.add(forkContext.head);\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment of the `if` block.\n     *\n     * @returns {void}\n     */\n    makeIfConsequent() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    }\n\n    /**\n     * Makes a code path segment of the `else` block.\n     *\n     * @returns {void}\n     */\n    makeIfAlternate() {\n        const context = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    }\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     *\n     * @param {boolean} hasCase - `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label - The label text.\n     * @returns {void}\n     */\n    pushSwitchContext(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    }\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     *\n     * @returns {void}\n     */\n    popSwitchContext() {\n        const context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        const lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        const lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (let i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     *\n     * @param {boolean} isEmpty - `true` if the body is empty.\n     * @param {boolean} isDefault - `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody(isEmpty, isDefault) {\n        const context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        const parentForkContext = this.forkContext;\n        const forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    }\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     *\n     * @param {boolean} hasFinalizer - `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    }\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popTryContext() {\n        const context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        const headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        // If both paths of the `try` block and the `catch` block are\n        // unreachable, the next path becomes unreachable as well.\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    }\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeCatchBlock() {\n        const context = this.tryContext;\n        const forkContext = this.forkContext;\n        const thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        const thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    }\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeFinallyBlock() {\n        const context = this.tryContext;\n        let forkContext = this.forkContext;\n        const returned = context.returnedForkContext;\n        const thrown = context.thrownForkContext;\n        const headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        const segments = forkContext.makeNext(-1, -1);\n        let j;\n\n        for (let i = 0; i < forkContext.count; ++i) {\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(CodePathSegment.newNext(\n                this.idGenerator.next(),\n                prevSegsOfLeavingSegment));\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    }\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     *\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock() {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     *\n     * @param {string} type - The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label - A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext(type, label) {\n        const forkContext = this.forkContext;\n        const breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type,\n                    label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(`unknown type: \"${type}\"`);\n        }\n    }\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popLoopContext() {\n        const context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        const forkContext = this.forkContext;\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\n        let choiceContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                choiceContext = this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments);\n                break;\n\n            case \"DoWhileStatement\": {\n                choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (let i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments);\n                }\n                break;\n            }\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments);\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     *\n     * @returns {void}\n     */\n    makeWhileBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    }\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     *\n     * @returns {void}\n     */\n    makeDoWhileBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            const testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    }\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest(test) {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const endOfInitSegments = forkContext.head;\n        const testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    }\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForUpdate() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head);\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForBody() {\n        const context = this.loopContext;\n        const choiceContext = this.choiceContext;\n        const forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments);\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head);\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        let bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            const prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    }\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfLeft() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    }\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfRight() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        const rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    }\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfBody() {\n        const context = this.loopContext;\n        const forkContext = this.forkContext;\n        const temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        const bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     *\n     * @param {boolean} breakable - The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label - The label of this context.\n     * @returns {Object} The new context.\n     */\n    pushBreakContext(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable,\n            label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    }\n\n    /**\n     * Removes the top item of the break context stack.\n     *\n     * @returns {Object} The removed context.\n     */\n    popBreakContext() {\n        const context = this.breakContext;\n        const forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            const brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    }\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue(label) {\n        const forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        const context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeReturn() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeThrow() {\n        const forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    }\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal() {\n        const segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n}\n\nmodule.exports = CodePathState;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/code-path-segment.js":"/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Replaces unused segments with the previous segments of each unused segment.\n *\n * @param {CodePathSegment[]} segments - An array of segments to replace.\n * @returns {CodePathSegment[]} The replaced array.\n */\nfunction flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n\n    for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        // Ignores duplicated.\n        if (done[segment.id]) {\n            continue;\n        }\n\n        // Use previous segments if unused.\n        if (!segment.internal.used) {\n            for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                const prevSegment = segment.allPrevSegments[j];\n\n                if (!done[prevSegment.id]) {\n                    done[prevSegment.id] = true;\n                    retv.push(prevSegment);\n                }\n            }\n        } else {\n            done[segment.id] = true;\n            retv.push(segment);\n        }\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n */\nclass CodePathSegment {\n\n    /**\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable - A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of the next segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of the previous segments.\n         * This array includes unreachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n                used: false,\n                loopedPrevSegments: []\n            }\n        });\n\n        /* istanbul ignore if */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n            this.internal.exitNodes = [];\n        }\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     *\n     * @param {CodePathSegment} segment - A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n\n    /**\n     * Creates the root segment.\n     *\n     * @param {string} id - An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Creates an unreachable segment that follows given segments.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);\n\n        // In `if (a) return a; foo();` case, the unreachable segment preceded by\n        // the return statement is not used but must not be remove.\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     *\n     * @param {string} id - An identifier.\n     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Makes a given segment being used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     *\n     * @param {CodePathSegment} segment - A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     *\n     * @param {CodePathSegment} segment - A segment.\n     * @param {CodePathSegment} prevSegment - A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n}\n\nmodule.exports = CodePathSegment;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/debug-helpers.js":"/**\n * @fileoverview Helpers to debug for code path analysis.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets id of a given segment.\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {string} Id of the segment.\n */\n/* istanbul ignore next */\nfunction getId(segment) { // eslint-disable-line require-jsdoc\n    return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * A flag that debug dumping is enabled or not.\n     * @type {boolean}\n     */\n    enabled: debug.enabled,\n\n    /**\n     * Dumps given objects.\n     *\n     * @param {...any} args - objects to dump.\n     * @returns {void}\n     */\n    dump: debug,\n\n    /**\n     * Dumps the current analyzing state.\n     *\n     * @param {ASTNode} node - A node to dump.\n     * @param {CodePathState} state - A state to dump.\n     * @param {boolean} leaving - A flag whether or not it's leaving\n     * @returns {void}\n     */\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\n        for (let i = 0; i < state.currentSegments.length; ++i) {\n            const segInternal = state.currentSegments[i].internal;\n\n            if (leaving) {\n                segInternal.exitNodes.push(node);\n            } else {\n                segInternal.nodes.push(node);\n            }\n        }\n\n        debug([\n            `${state.currentSegments.map(getId).join(\",\")})`,\n            `${node.type}${leaving ? \":exit\" : \"\"}`\n        ].join(\" \"));\n    },\n\n    /**\n     * Dumps a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     *\n     * @param {CodePath} codePath - A code path to dump.\n     * @returns {void}\n     * @see http://www.graphviz.org\n     * @see http://www.webgraphviz.com\n     */\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\n        let text =\n            \"\\n\" +\n            \"digraph {\\n\" +\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n        if (codePath.returnedSegments.length > 0) {\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n        }\n        if (codePath.thrownSegments.length > 0) {\n            text += \"thrown[label=\\\"\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n        }\n\n        const traceMap = Object.create(null);\n        const arrows = this.makeDotArrows(codePath, traceMap);\n\n        for (const id in traceMap) { // eslint-disable-line guard-for-in\n            const segment = traceMap[id];\n\n            text += `${id}[`;\n\n            if (segment.reachable) {\n                text += \"label=\\\"\";\n            } else {\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n            }\n\n            if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {\n                text += [].concat(\n                    segment.internal.nodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type} (${node.name})`;\n                            case \"Literal\": return `${node.type} (${node.value})`;\n                            default: return node.type;\n                        }\n                    }),\n                    segment.internal.exitNodes.map(node => {\n                        switch (node.type) {\n                            case \"Identifier\": return `${node.type}:exit (${node.name})`;\n                            case \"Literal\": return `${node.type}:exit (${node.value})`;\n                            default: return `${node.type}:exit`;\n                        }\n                    })\n                ).join(\"\\\\n\");\n            } else {\n                text += \"????\";\n            }\n\n            text += \"\\\"];\\n\";\n        }\n\n        text += `${arrows}\\n`;\n        text += \"}\";\n        debug(\"DOT\", text);\n    },\n\n    /**\n     * Makes a DOT code of a given code path.\n     * The DOT code can be visialized with Graphvis.\n     *\n     * @param {CodePath} codePath - A code path to make DOT.\n     * @param {Object} traceMap - Optional. A map to check whether or not segments had been done.\n     * @returns {string} A DOT code of the code path.\n     */\n    makeDotArrows(codePath, traceMap) {\n        const stack = [[codePath.initialSegment, 0]];\n        const done = traceMap || Object.create(null);\n        let lastId = codePath.initialSegment.id;\n        let text = `initial->${codePath.initialSegment.id}`;\n\n        while (stack.length > 0) {\n            const item = stack.pop();\n            const segment = item[0];\n            const index = item[1];\n\n            if (done[segment.id] && index === 0) {\n                continue;\n            }\n            done[segment.id] = segment;\n\n            const nextSegment = segment.allNextSegments[index];\n\n            if (!nextSegment) {\n                continue;\n            }\n\n            if (lastId === segment.id) {\n                text += `->${nextSegment.id}`;\n            } else {\n                text += `;\\n${segment.id}->${nextSegment.id}`;\n            }\n            lastId = nextSegment.id;\n\n            stack.unshift([segment, 1 + index]);\n            stack.push([nextSegment, 0]);\n        }\n\n        codePath.returnedSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->final\";\n            } else {\n                text += `;\\n${finalSegment.id}->final`;\n            }\n            lastId = null;\n        });\n\n        codePath.thrownSegments.forEach(finalSegment => {\n            if (lastId === finalSegment.id) {\n                text += \"->thrown\";\n            } else {\n                text += `;\\n${finalSegment.id}->thrown`;\n            }\n            lastId = null;\n        });\n\n        return `${text};`;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/fork-context.js":"/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n *\n * @param {ForkContext} context - An instance.\n * @param {number} begin - The first index of the previous segments.\n * @param {number} end - The last index of the previous segments.\n * @param {Function} create - A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    const list = context.segmentsList;\n\n    if (begin < 0) {\n        begin = list.length + begin;\n    }\n    if (end < 0) {\n        end = list.length + end;\n    }\n\n    const segments = [];\n\n    for (let i = 0; i < context.count; ++i) {\n        const allPrevSegments = [];\n\n        for (let j = begin; j <= end; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n *\n * @param {ForkContext} context - An instance.\n * @param {CodePathSegment[]} segments - Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    while (segments.length > context.count) {\n        const merged = [];\n\n        for (let i = 0, length = segments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [segments[i], segments[i + length]]\n            ));\n        }\n        segments = merged;\n    }\n    return segments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n */\nclass ForkContext {\n\n    /**\n     * @param {IdGenerator} idGenerator - An identifier generator for segments.\n     * @param {ForkContext|null} upper - An upper fork context.\n     * @param {number} count - A number of parallel segments.\n     */\n    constructor(idGenerator, upper, count) {\n        this.idGenerator = idGenerator;\n        this.upper = upper;\n        this.count = count;\n        this.segmentsList = [];\n    }\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        const list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    }\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    }\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        const segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    }\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    }\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    add(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    replaceHead(segments) {\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    }\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     *\n     * @param {ForkContext} context - A fork context to add.\n     * @returns {void}\n     */\n    addAll(context) {\n        assert(context.count === this.count);\n\n        const source = context.segmentsList;\n\n        for (let i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    }\n\n    /**\n     * Clears all secments in this context.\n     *\n     * @returns {void}\n     */\n    clear() {\n        this.segmentsList = [];\n    }\n\n    /**\n     * Creates the root fork context.\n     *\n     * @param {IdGenerator} idGenerator - An identifier generator for segments.\n     * @returns {ForkContext} New fork context.\n     */\n    static newRoot(idGenerator) {\n        const context = new ForkContext(idGenerator, null, 1);\n\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n        return context;\n    }\n\n    /**\n     * Creates an empty fork context preceded by a given context.\n     *\n     * @param {ForkContext} parentContext - The parent fork context.\n     * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.\n     * @returns {ForkContext} New fork context.\n     */\n    static newEmpty(parentContext, forkLeavingPath) {\n        return new ForkContext(\n            parentContext.idGenerator,\n            parentContext,\n            (forkLeavingPath ? 2 : 1) * parentContext.count);\n    }\n}\n\nmodule.exports = ForkContext;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/code-path-analysis/id-generator.js":"/**\n * @fileoverview A class of identifiers generator for code path segments.\n *\n * Each rule uses the identifier of code path segments to store additional\n * information of the code path.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A generator for unique ids.\n */\nclass IdGenerator {\n\n    /**\n     * @param {string} prefix - Optional. A prefix of generated ids.\n     */\n    constructor(prefix) {\n        this.prefix = String(prefix);\n        this.n = 0;\n    }\n\n    /**\n     * Generates id.\n     *\n     * @returns {string} A generated id.\n     */\n    next() {\n        this.n = 1 + this.n | 0;\n\n        /* istanbul ignore if */\n        if (this.n < 0) {\n            this.n = 1;\n        }\n\n        return this.prefix + this.n;\n    }\n}\n\nmodule.exports = IdGenerator;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/ast-utils.js":"/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;\nconst arrayOrTypedArrayPattern = /Array$/;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;\nconst breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;\nconst thisTagPattern = /^[\\s*]*@this/m;\n\n\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\nconst LINEBREAK_MATCHER = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\n\n// A set of node types that can contain a list of statements\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"SwitchCase\"]);\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference - A reference to check.\n * @param {int} index - The index of the reference in the references.\n * @param {Reference[]} references - The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n *\n * @param {string} s - The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node - A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node - A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    while (node) {\n        if (anyFunctionPattern.test(node.type)) {\n            return node;\n        }\n        node = node.parent;\n    }\n    return null;\n}\n\n/**\n * Checks whether a given node is a function node or not.\n * The following types are function nodes:\n *\n * - ArrowFunctionExpression\n * - FunctionDeclaration\n * - FunctionExpression\n *\n * @param {ASTNode|null} node - A node to check.\n * @returns {boolean} `true` if the node is a function node.\n */\nfunction isFunction(node) {\n    return Boolean(node && anyFunctionPattern.test(node.type));\n}\n\n/**\n * Checks whether a given node is a loop node or not.\n * The following types are loop nodes:\n *\n * - DoWhileStatement\n * - ForInStatement\n * - ForOfStatement\n * - ForStatement\n * - WhileStatement\n *\n * @param {ASTNode|null} node - A node to check.\n * @returns {boolean} `true` if the node is a loop node.\n */\nfunction isLoop(node) {\n    return Boolean(node && anyLoopPattern.test(node.type));\n}\n\n/**\n * Checks whether the given node is in a loop or not.\n *\n * @param {ASTNode} node - The node to check.\n * @returns {boolean} `true` if the node is in a loop.\n */\nfunction isInLoop(node) {\n    while (node && !isFunction(node)) {\n        if (isLoop(node)) {\n            return true;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        module.exports.isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reflect.apply`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    while (node) {\n        if (node.type === \"Identifier\") {\n            return arrayMethodPattern.test(node.name);\n        }\n        if (node.type === \"MemberExpression\" && !node.computed) {\n            node = node.property;\n            continue;\n        }\n\n        break;\n    }\n\n    return false;\n}\n\n/**\n * Creates the negate function of the given function.\n * @param {Function} f - The function to negate.\n * @returns {Function} Negated function.\n */\nfunction negate(f) {\n    return token => !f(token);\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node - A node to check.\n * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getComments(node).leading.some(comment => thisTagPattern.test(comment.value));\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if the given token is an arrow token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an arrow token.\n */\nfunction isArrowToken(token) {\n    return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comma token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comma token.\n */\nfunction isCommaToken(token) {\n    return token.value === \",\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a semicolon token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a semicolon token.\n */\nfunction isSemicolonToken(token) {\n    return token.value === \";\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a colon token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a colon token.\n */\nfunction isColonToken(token) {\n    return token.value === \":\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening parenthesis token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening parenthesis token.\n */\nfunction isOpeningParenToken(token) {\n    return token.value === \"(\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing parenthesis token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing parenthesis token.\n */\nfunction isClosingParenToken(token) {\n    return token.value === \")\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening square bracket token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening square bracket token.\n */\nfunction isOpeningBracketToken(token) {\n    return token.value === \"[\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing square bracket token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing square bracket token.\n */\nfunction isClosingBracketToken(token) {\n    return token.value === \"]\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is an opening brace token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is an opening brace token.\n */\nfunction isOpeningBraceToken(token) {\n    return token.value === \"{\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a closing brace token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a closing brace token.\n */\nfunction isClosingBraceToken(token) {\n    return token.value === \"}\" && token.type === \"Punctuator\";\n}\n\n/**\n * Checks if the given token is a comment token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a comment token.\n */\nfunction isCommentToken(token) {\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n\n/**\n * Checks if the given token is a keyword token or not.\n *\n * @param {Token} token - The token to check.\n * @returns {boolean} `true` if the token is a keyword token.\n */\nfunction isKeywordToken(token) {\n    return token.type === \"Keyword\";\n}\n\n/**\n * Gets the `(` token of the given function node.\n *\n * @param {ASTNode} node - The function node to get.\n * @param {SourceCode} sourceCode - The source code object to get tokens.\n * @returns {Token} `(` token.\n */\nfunction getOpeningParenOfParams(node, sourceCode) {\n    return node.id\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n\n/**\n * Creates a version of the LINEBREAK_MATCHER regex with the global flag.\n * Global regexes are mutable, so this needs to be a function instead of a constant.\n * @returns {RegExp} A global regular expression that matches line terminators\n */\nfunction createGlobalLinebreakMatcher() {\n    return new RegExp(LINEBREAK_MATCHER.source, \"g\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    COMMENTS_IGNORE_PATTERN,\n    LINEBREAKS,\n    LINEBREAK_MATCHER,\n    STATEMENT_LIST_PARENTS,\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isFunction,\n    isLoop,\n    isInLoop,\n    isArrayFromMethod,\n    isParenthesised,\n    createGlobalLinebreakMatcher,\n\n    isArrowToken,\n    isClosingBraceToken,\n    isClosingBracketToken,\n    isClosingParenToken,\n    isColonToken,\n    isCommaToken,\n    isCommentToken,\n    isKeywordToken,\n    isNotClosingBraceToken: negate(isClosingBraceToken),\n    isNotClosingBracketToken: negate(isClosingBracketToken),\n    isNotClosingParenToken: negate(isClosingParenToken),\n    isNotColonToken: negate(isColonToken),\n    isNotCommaToken: negate(isCommaToken),\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\n    isNotOpeningParenToken: negate(isOpeningParenToken),\n    isNotSemicolonToken: negate(isSemicolonToken),\n    isOpeningBraceToken,\n    isOpeningBracketToken,\n    isOpeningParenToken,\n    isSemicolonToken,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     *\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets the label if the parent node of a given node is a LabeledStatement.\n     *\n     * @param {ASTNode} node - A node to get.\n     * @returns {string|null} The label or `null`.\n     */\n    getLabel(node) {\n        if (node.parent.type === \"LabeledStatement\") {\n            return node.parent.label.name;\n        }\n        return null;\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references - An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {LineComment|BlockComment} node The node to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     *\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     *\n     * @param {escope.Scope} initScope - A scope to start find.\n     * @param {string} name - A variable name to find.\n     * @returns {escope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase (it's a constructor).\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     *\n     * @param {ASTNode} node - A function node to check.\n     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode) {\n        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n\n        while (node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    node = parent;\n                    break;\n\n                // If the upper function is IIFE, checks the destination of the return value.\n                // e.g.\n                //   obj.foo = (function() {\n                //     // setup...\n                //     return function foo() { ... };\n                //   })();\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    node = func.parent;\n                    break;\n                }\n\n                // e.g.\n                //   var obj = { foo() { ... } };\n                //   var obj = { foo: function() { ... } };\n                //   class A { constructor() { ... } }\n                //   class A { foo() { ... } }\n                //   class A { get foo() { ... } }\n                //   class A { set foo() { ... } }\n                //   class A { static foo() { ... } }\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.value !== node;\n\n                // e.g.\n                //   obj.foo = function foo() { ... };\n                //   Foo = function() { ... };\n                //   [obj.foo = function foo() { ... }] = a;\n                //   [Foo = function() { ... }] = a;\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.right === node) {\n                        if (parent.left.type === \"MemberExpression\") {\n                            return false;\n                        }\n                        if (isAnonymous &&\n                            parent.left.type === \"Identifier\" &&\n                            startsWithUpperCase(parent.left.name)\n                        ) {\n                            return false;\n                        }\n                    }\n                    return true;\n\n                // e.g.\n                //   var Foo = function() { ... };\n                case \"VariableDeclarator\":\n                    return !(\n                        isAnonymous &&\n                        parent.init === node &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                // e.g.\n                //   var foo = function foo() { ... }.bind(obj);\n                //   (function foo() { ... }).call(obj);\n                //   (function foo() { ... }).apply(obj, []);\n                case \"MemberExpression\":\n                    return (\n                        parent.object !== node ||\n                        parent.property.type !== \"Identifier\" ||\n                        !bindOrCallOrApplyPattern.test(parent.property.name) ||\n                        !isCallee(parent) ||\n                        parent.parent.arguments.length === 0 ||\n                        isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                // e.g.\n                //   Reflect.apply(function() {}, obj, []);\n                //   Array.from([], function() {}, obj);\n                //   list.forEach(function() {}, obj);\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== node ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n                    case \"**\":\n                        return 15;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 16;\n\n            case \"UpdateExpression\":\n                return 17;\n\n            case \"CallExpression\":\n\n                // IIFE is allowed to have parens in any position (#655)\n                if (node.callee.type === \"FunctionExpression\") {\n                    return -1;\n                }\n                return 18;\n\n            case \"NewExpression\":\n                return 19;\n\n            // no default\n        }\n        return 20;\n    },\n\n    /**\n     * Checks whether the given node is an empty block node or not.\n     *\n     * @param {ASTNode|null} node - The node to check.\n     * @returns {boolean} `true` if the node is an empty block.\n     */\n    isEmptyBlock(node) {\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n    },\n\n    /**\n     * Checks whether the given node is an empty function node or not.\n     *\n     * @param {ASTNode|null} node - The node to check.\n     * @returns {boolean} `true` if the node is an empty function.\n     */\n    isEmptyFunction(node) {\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\n    },\n\n    /**\n     * Gets the property name of a given node.\n     * The node can be a MemberExpression, a Property, or a MethodDefinition.\n     *\n     * If the name is dynamic, this returns `null`.\n     *\n     * For examples:\n     *\n     *     a.b           // => \"b\"\n     *     a[\"b\"]        // => \"b\"\n     *     a['b']        // => \"b\"\n     *     a[`b`]        // => \"b\"\n     *     a[100]        // => \"100\"\n     *     a[b]          // => null\n     *     a[\"a\" + \"b\"]  // => null\n     *     a[tag`b`]     // => null\n     *     a[`${b}`]     // => null\n     *\n     *     let a = {b: 1}            // => \"b\"\n     *     let a = {[\"b\"]: 1}        // => \"b\"\n     *     let a = {['b']: 1}        // => \"b\"\n     *     let a = {[`b`]: 1}        // => \"b\"\n     *     let a = {[100]: 1}        // => \"100\"\n     *     let a = {[b]: 1}          // => null\n     *     let a = {[\"a\" + \"b\"]: 1}  // => null\n     *     let a = {[tag`b`]: 1}     // => null\n     *     let a = {[`${b}`]: 1}     // => null\n     *\n     * @param {ASTNode} node - The node to get.\n     * @returns {string|null} The property name if static. Otherwise, null.\n     */\n    getStaticPropertyName(node) {\n        let prop;\n\n        switch (node && node.type) {\n            case \"Property\":\n            case \"MethodDefinition\":\n                prop = node.key;\n                break;\n\n            case \"MemberExpression\":\n                prop = node.property;\n                break;\n\n            // no default\n        }\n\n        switch (prop && prop.type) {\n            case \"Literal\":\n                return String(prop.value);\n\n            case \"TemplateLiteral\":\n                if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n                    return prop.quasis[0].value.cooked;\n                }\n                break;\n\n            case \"Identifier\":\n                if (!node.computed) {\n                    return prop.name;\n                }\n                break;\n\n            // no default\n        }\n\n        return null;\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node - The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            // Do not check arrow functions with implicit return.\n            // `() => \"use strict\";` returns the string `\"use strict\"`.\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 5       // true\n     * 5.      // false\n     * 5.0     // false\n     * 05      // false\n     * 0x5     // false\n     * 0b101   // false\n     * 0o5     // false\n     * 5e0     // false\n     * '5'     // false\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" && /^(0|[1-9]\\d*)$/.test(node.raw);\n    },\n\n    /**\n     * Gets the name and kind of the given function node.\n     *\n     * - `function foo() {}`  .................... `function 'foo'`\n     * - `(function foo() {})`  .................. `function 'foo'`\n     * - `(function() {})`  ...................... `function`\n     * - `function* foo() {}`  ................... `generator function 'foo'`\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\n     * - `(function*() {})`  ..................... `generator function`\n     * - `() => {}`  ............................. `arrow function`\n     * - `async () => {}`  ....................... `async arrow function`\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\n     * - `({ [foo]: function() {} })`  ........... `method`\n     * - `({ foo() {} })`  ....................... `method 'foo'`\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\n     * - `({ [foo]: async function() {} })`  ..... `async method`\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\n     * - `class A { constructor() {} }`  ......... `constructor`\n     * - `class A { foo() {} }`  ................. `method 'foo'`\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\n     * - `class A { [foo]() {} }`  ............... `method`\n     * - `class A { *[foo]() {} }`  .............. `generator method`\n     * - `class A { async [foo]() {} }`  ......... `async method`\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\n     *\n     * @param {ASTNode} node - The function node to get.\n     * @returns {string} The name and kind of the function node.\n     */\n    getFunctionNameWithKind(node) {\n        const parent = node.parent;\n        const tokens = [];\n\n        if (parent.type === \"MethodDefinition\" && parent.static) {\n            tokens.push(\"static\");\n        }\n        if (node.async) {\n            tokens.push(\"async\");\n        }\n        if (node.generator) {\n            tokens.push(\"generator\");\n        }\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            tokens.push(\"arrow\", \"function\");\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            if (parent.kind === \"constructor\") {\n                return \"constructor\";\n            } else if (parent.kind === \"get\") {\n                tokens.push(\"getter\");\n            } else if (parent.kind === \"set\") {\n                tokens.push(\"setter\");\n            } else {\n                tokens.push(\"method\");\n            }\n        } else {\n            tokens.push(\"function\");\n        }\n\n        if (node.id) {\n            tokens.push(`'${node.id.name}'`);\n        } else {\n            const name = module.exports.getStaticPropertyName(parent);\n\n            if (name) {\n                tokens.push(`'${name}'`);\n            }\n        }\n\n        return tokens.join(\" \");\n    },\n\n    /**\n     * Gets the location of the given function node for reporting.\n     *\n     * - `function foo() {}`\n     *    ^^^^^^^^^^^^\n     * - `(function foo() {})`\n     *     ^^^^^^^^^^^^\n     * - `(function() {})`\n     *     ^^^^^^^^\n     * - `function* foo() {}`\n     *    ^^^^^^^^^^^^^\n     * - `(function* foo() {})`\n     *     ^^^^^^^^^^^^^\n     * - `(function*() {})`\n     *     ^^^^^^^^^\n     * - `() => {}`\n     *       ^^\n     * - `async () => {}`\n     *             ^^\n     * - `({ foo: function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ foo: function() {} })`\n     *       ^^^^^^^^^^^^^\n     * - `({ ['foo']: function() {} })`\n     *       ^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function() {} })`\n     *       ^^^^^^^^^^^^^^^\n     * - `({ foo() {} })`\n     *       ^^^\n     * - `({ foo: function* foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ foo: function*() {} })`\n     *       ^^^^^^^^^^^^^^\n     * - `({ ['foo']: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: function*() {} })`\n     *       ^^^^^^^^^^^^^^^^\n     * - `({ *foo() {} })`\n     *       ^^^^\n     * - `({ foo: async function foo() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ foo: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^\n     * - `({ ['foo']: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\n     * - `({ [foo]: async function() {} })`\n     *       ^^^^^^^^^^^^^^^^^^^^^\n     * - `({ async foo() {} })`\n     *       ^^^^^^^^^\n     * - `({ get foo() {} })`\n     *       ^^^^^^^\n     * - `({ set foo(a) {} })`\n     *       ^^^^^^^\n     * - `class A { constructor() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { foo() {} }`\n     *              ^^^\n     * - `class A { *foo() {} }`\n     *              ^^^^\n     * - `class A { async foo() {} }`\n     *              ^^^^^^^^^\n     * - `class A { ['foo']() {} }`\n     *              ^^^^^^^\n     * - `class A { *['foo']() {} }`\n     *              ^^^^^^^^\n     * - `class A { async ['foo']() {} }`\n     *              ^^^^^^^^^^^^^\n     * - `class A { [foo]() {} }`\n     *              ^^^^^\n     * - `class A { *[foo]() {} }`\n     *              ^^^^^^\n     * - `class A { async [foo]() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { get foo() {} }`\n     *              ^^^^^^^\n     * - `class A { set foo(a) {} }`\n     *              ^^^^^^^\n     * - `class A { static foo() {} }`\n     *              ^^^^^^^^^^\n     * - `class A { static *foo() {} }`\n     *              ^^^^^^^^^^^\n     * - `class A { static async foo() {} }`\n     *              ^^^^^^^^^^^^^^^^\n     * - `class A { static get foo() {} }`\n     *              ^^^^^^^^^^^^^^\n     * - `class A { static set foo(a) {} }`\n     *              ^^^^^^^^^^^^^^\n     *\n     * @param {ASTNode} node - The function node to get.\n     * @param {SourceCode} sourceCode - The source code object to get tokens.\n     * @returns {string} The location of the function node for reporting.\n     */\n    getFunctionHeadLoc(node, sourceCode) {\n        const parent = node.parent;\n        let start = null;\n        let end = null;\n\n        if (node.type === \"ArrowFunctionExpression\") {\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n\n            start = arrowToken.loc.start;\n            end = arrowToken.loc.end;\n        } else if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n            start = parent.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        } else {\n            start = node.loc.start;\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\n        }\n\n        return {\n            start: Object.assign({}, start),\n            end: Object.assign({}, end)\n        };\n    },\n\n    /**\n    * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\n    * surrounding the node.\n    * @param {SourceCode} sourceCode The source code object\n    * @param {ASTNode} node An expression node\n    * @returns {string} The text representing the node, with all surrounding parentheses included\n    */\n    getParenthesisedText(sourceCode, node) {\n        let leftToken = sourceCode.getFirstToken(node);\n        let rightToken = sourceCode.getLastToken(node);\n\n        while (\n            sourceCode.getTokenBefore(leftToken) &&\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\n            sourceCode.getTokenAfter(rightToken) &&\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\n            sourceCode.getTokenAfter(rightToken).value === \")\"\n        ) {\n            leftToken = sourceCode.getTokenBefore(leftToken);\n            rightToken = sourceCode.getTokenAfter(rightToken);\n        }\n\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n    },\n\n    /*\n     * Determine if a node has a possiblity to be an Error object\n     * @param  {ASTNode} node  ASTNode to check\n     * @returns {boolean} True if there is a chance it contains an Error obj\n     */\n    couldBeError(node) {\n        switch (node.type) {\n            case \"Identifier\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"MemberExpression\":\n            case \"TaggedTemplateExpression\":\n            case \"YieldExpression\":\n            case \"AwaitExpression\":\n                return true; // possibly an error object.\n\n            case \"AssignmentExpression\":\n                return module.exports.couldBeError(node.right);\n\n            case \"SequenceExpression\": {\n                const exprs = node.expressions;\n\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n            }\n\n            case \"LogicalExpression\":\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n            case \"ConditionalExpression\":\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n            default:\n                return false;\n        }\n    },\n\n    /**\n     * Determines whether the given node is a `null` literal.\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a `null` literal\n     */\n    isNullLiteral(node) {\n\n        /*\n         * Checking `node.value === null` does not guarantee that a literal is a null literal.\n         * When parsing values that cannot be represented in the current environment (e.g. unicode\n         * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\n         * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\n         * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\n         */\n        return node.type === \"Literal\" && node.value === null && !node.regex;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/config/config-ops.js":"/**\n * @fileoverview Config file operations. This file must be usable in the browser,\n * so no Node-specific code can be here.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Environments = require(\"./environments\");\n\nconst debug = require(\"debug\")(\"eslint:config-ops\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst RULE_SEVERITY_STRINGS = [\"off\", \"warn\", \"error\"],\n    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {\n        map[value] = index;\n        return map;\n    }, {}),\n    VALID_SEVERITIES = [0, 1, 2, \"off\", \"warn\", \"error\"];\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * Creates an empty configuration object suitable for merging as a base.\n     * @returns {Object} A configuration object.\n     */\n    createEmptyConfig() {\n        return {\n            globals: {},\n            env: {},\n            rules: {},\n            parserOptions: {}\n        };\n    },\n\n    /**\n     * Creates an environment config based on the specified environments.\n     * @param {Object<string,boolean>} env The environment settings.\n     * @returns {Object} A configuration object with the appropriate rules and globals\n     *      set.\n     */\n    createEnvironmentConfig(env) {\n\n        const envConfig = this.createEmptyConfig();\n\n        if (env) {\n\n            envConfig.env = env;\n\n            Object.keys(env).filter(name => env[name]).forEach(name => {\n                const environment = Environments.get(name);\n\n                if (environment) {\n                    debug(`Creating config for environment ${name}`);\n                    if (environment.globals) {\n                        Object.assign(envConfig.globals, environment.globals);\n                    }\n\n                    if (environment.parserOptions) {\n                        Object.assign(envConfig.parserOptions, environment.parserOptions);\n                    }\n                }\n            });\n        }\n\n        return envConfig;\n    },\n\n    /**\n     * Given a config with environment settings, applies the globals and\n     * ecmaFeatures to the configuration and returns the result.\n     * @param {Object} config The configuration information.\n     * @returns {Object} The updated configuration information.\n     */\n    applyEnvironments(config) {\n        if (config.env && typeof config.env === \"object\") {\n            debug(\"Apply environment settings to config\");\n            return this.merge(this.createEnvironmentConfig(config.env), config);\n        }\n\n        return config;\n    },\n\n    /**\n     * Merges two config objects. This will not only add missing keys, but will also modify values to match.\n     * @param {Object} target config object\n     * @param {Object} src config object. Overrides in this config object will take priority over base.\n     * @param {boolean} [combine] Whether to combine arrays or not\n     * @param {boolean} [isRule] Whether its a rule\n     * @returns {Object} merged config object.\n     */\n    merge: function deepmerge(target, src, combine, isRule) {\n\n        /*\n         The MIT License (MIT)\n\n         Copyright (c) 2012 Nicholas Fisher\n\n         Permission is hereby granted, free of charge, to any person obtaining a copy\n         of this software and associated documentation files (the \"Software\"), to deal\n         in the Software without restriction, including without limitation the rights\n         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n         copies of the Software, and to permit persons to whom the Software is\n         furnished to do so, subject to the following conditions:\n\n         The above copyright notice and this permission notice shall be included in\n         all copies or substantial portions of the Software.\n\n         THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n         THE SOFTWARE.\n         */\n\n        /*\n         * This code is taken from deepmerge repo\n         * (https://github.com/KyleAMathews/deepmerge)\n         * and modified to meet our needs.\n         */\n        const array = Array.isArray(src) || Array.isArray(target);\n        let dst = array && [] || {};\n\n        combine = !!combine;\n        isRule = !!isRule;\n        if (array) {\n            target = target || [];\n\n            // src could be a string, so check for array\n            if (isRule && Array.isArray(src) && src.length > 1) {\n                dst = dst.concat(src);\n            } else {\n                dst = dst.concat(target);\n            }\n            if (typeof src !== \"object\" && !Array.isArray(src)) {\n                src = [src];\n            }\n            Object.keys(src).forEach((e, i) => {\n                e = src[i];\n                if (typeof dst[i] === \"undefined\") {\n                    dst[i] = e;\n                } else if (typeof e === \"object\") {\n                    if (isRule) {\n                        dst[i] = e;\n                    } else {\n                        dst[i] = deepmerge(target[i], e, combine, isRule);\n                    }\n                } else {\n                    if (!combine) {\n                        dst[i] = e;\n                    } else {\n                        if (dst.indexOf(e) === -1) {\n                            dst.push(e);\n                        }\n                    }\n                }\n            });\n        } else {\n            if (target && typeof target === \"object\") {\n                Object.keys(target).forEach(key => {\n                    dst[key] = target[key];\n                });\n            }\n            Object.keys(src).forEach(key => {\n                if (Array.isArray(src[key]) || Array.isArray(target[key])) {\n                    dst[key] = deepmerge(target[key], src[key], key === \"plugins\", isRule);\n                } else if (typeof src[key] !== \"object\" || !src[key] || key === \"exported\" || key === \"astGlobals\") {\n                    dst[key] = src[key];\n                } else {\n                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === \"rules\");\n                }\n            });\n        }\n\n        return dst;\n    },\n\n    /**\n     * Converts new-style severity settings (off, warn, error) into old-style\n     * severity settings (0, 1, 2) for all rules. Assumption is that severity\n     * values have already been validated as correct.\n     * @param {Object} config The config object to normalize.\n     * @returns {void}\n     */\n    normalize(config) {\n\n        if (config.rules) {\n            Object.keys(config.rules).forEach(ruleId => {\n                const ruleConfig = config.rules[ruleId];\n\n                if (typeof ruleConfig === \"string\") {\n                    config.rules[ruleId] = RULE_SEVERITY[ruleConfig.toLowerCase()] || 0;\n                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"string\") {\n                    ruleConfig[0] = RULE_SEVERITY[ruleConfig[0].toLowerCase()] || 0;\n                }\n            });\n        }\n    },\n\n    /**\n     * Converts old-style severity settings (0, 1, 2) into new-style\n     * severity settings (off, warn, error) for all rules. Assumption is that severity\n     * values have already been validated as correct.\n     * @param {Object} config The config object to normalize.\n     * @returns {void}\n     */\n    normalizeToStrings(config) {\n\n        if (config.rules) {\n            Object.keys(config.rules).forEach(ruleId => {\n                const ruleConfig = config.rules[ruleId];\n\n                if (typeof ruleConfig === \"number\") {\n                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];\n                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === \"number\") {\n                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];\n                }\n            });\n        }\n    },\n\n    /**\n     * Determines if the severity for the given rule configuration represents an error.\n     * @param {int|string|Array} ruleConfig The configuration for an individual rule.\n     * @returns {boolean} True if the rule represents an error, false if not.\n     */\n    isErrorSeverity(ruleConfig) {\n\n        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (typeof severity === \"string\") {\n            severity = RULE_SEVERITY[severity.toLowerCase()] || 0;\n        }\n\n        return (typeof severity === \"number\" && severity === 2);\n    },\n\n    /**\n     * Checks whether a given config has valid severity or not.\n     * @param {number|string|Array} ruleConfig - The configuration for an individual rule.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isValidSeverity(ruleConfig) {\n        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;\n\n        if (typeof severity === \"string\") {\n            severity = severity.toLowerCase();\n        }\n        return VALID_SEVERITIES.indexOf(severity) !== -1;\n    },\n\n    /**\n     * Checks whether every rule of a given config has valid severity or not.\n     * @param {Object} config - The configuration for rules.\n     * @returns {boolean} `true` if the configuration has valid severity.\n     */\n    isEverySeverityValid(config) {\n        return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/config/environments.js":"/**\n * @fileoverview Environments manager\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst envs = require(\"../../conf/environments\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nlet environments = new Map();\n\n/**\n * Loads the default environments.\n * @returns {void}\n * @private\n */\nfunction load() {\n    Object.keys(envs).forEach(envName => {\n        environments.set(envName, envs[envName]);\n    });\n}\n\n// always load default environments upfront\nload();\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    load,\n\n    /**\n     * Gets the environment with the given name.\n     * @param {string} name The name of the environment to retrieve.\n     * @returns {Object?} The environment object or null if not found.\n     */\n    get(name) {\n        return environments.get(name) || null;\n    },\n\n    /**\n     * Defines an environment.\n     * @param {string} name The name of the environment.\n     * @param {Object} env The environment settings.\n     * @returns {void}\n     */\n    define(name, env) {\n        environments.set(name, env);\n    },\n\n    /**\n     * Imports all environments from a plugin.\n     * @param {Object} plugin The plugin object.\n     * @param {string} pluginName The name of the plugin.\n     * @returns {void}\n     */\n    importPlugin(plugin, pluginName) {\n        if (plugin.environments) {\n            Object.keys(plugin.environments).forEach(envName => {\n                this.define(`${pluginName}/${envName}`, plugin.environments[envName]);\n            });\n        }\n    },\n\n    /**\n     * Resets all environments. Only use for tests!\n     * @returns {void}\n     */\n    testReset() {\n        environments = new Map();\n        load();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/conf/environments.js":"/**\n * @fileoverview Defines environment settings and globals.\n * @author Elan Shanker\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst globals = require(\"globals\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    builtin: globals.es5,\n    browser: {\n        globals: globals.browser\n    },\n    node: {\n        globals: globals.node,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    commonjs: {\n        globals: globals.commonjs,\n        parserOptions: {\n            ecmaFeatures: {\n                globalReturn: true\n            }\n        }\n    },\n    \"shared-node-browser\": {\n        globals: globals[\"shared-node-browser\"]\n    },\n    worker: {\n        globals: globals.worker\n    },\n    amd: {\n        globals: globals.amd\n    },\n    mocha: {\n        globals: globals.mocha\n    },\n    jasmine: {\n        globals: globals.jasmine\n    },\n    jest: {\n        globals: globals.jest\n    },\n    phantomjs: {\n        globals: globals.phantomjs\n    },\n    jquery: {\n        globals: globals.jquery\n    },\n    qunit: {\n        globals: globals.qunit\n    },\n    prototypejs: {\n        globals: globals.prototypejs\n    },\n    shelljs: {\n        globals: globals.shelljs\n    },\n    meteor: {\n        globals: globals.meteor\n    },\n    mongo: {\n        globals: globals.mongo\n    },\n    protractor: {\n        globals: globals.protractor\n    },\n    applescript: {\n        globals: globals.applescript\n    },\n    nashorn: {\n        globals: globals.nashorn\n    },\n    serviceworker: {\n        globals: globals.serviceworker\n    },\n    atomtest: {\n        globals: globals.atomtest\n    },\n    embertest: {\n        globals: globals.embertest\n    },\n    webextensions: {\n        globals: globals.webextensions\n    },\n    es6: {\n        globals: globals.es6,\n        parserOptions: {\n            ecmaVersion: 6\n        }\n    },\n    greasemonkey: {\n        globals: globals.greasemonkey\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/config/config-validator.js":"/**\n * @fileoverview Validates configs.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst rules = require(\"../rules\"),\n    Environments = require(\"./environments\"),\n    schemaValidator = require(\"is-my-json-valid\"),\n    util = require(\"util\");\n\nconst validators = {\n    rules: Object.create(null)\n};\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Gets a complete options schema for a rule.\n * @param {string} id The rule's unique name.\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(id) {\n    const rule = rules.get(id),\n        schema = rule && rule.schema || rule && rule.meta && rule.meta.schema;\n\n    // Given a tuple of schemas, insert warning level at the beginning\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n        return {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 0\n        };\n\n    }\n\n    // Given a full schema, leave it alone\n    return schema || null;\n}\n\n/**\n* Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\n* @param {options} options The given options for the rule.\n* @returns {number|string} The rule's severity value\n*/\nfunction validateRuleSeverity(options) {\n    const severity = Array.isArray(options) ? options[0] : options;\n\n    if (severity !== 0 && severity !== 1 && severity !== 2 && !(typeof severity === \"string\" && /^(?:off|warn|error)$/i.test(severity))) {\n        throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/g, \"\\\"\").replace(/\\n/g, \"\")}').\\n`);\n    }\n\n    return severity;\n}\n\n/**\n* Validates the non-severity options passed to a rule, based on its schema.\n* @param {string} id The rule's unique name\n* @param {array} localOptions The options for the rule, excluding severity\n* @returns {void}\n*/\nfunction validateRuleSchema(id, localOptions) {\n    const schema = getRuleOptionsSchema(id);\n\n    if (!validators.rules[id] && schema) {\n        validators.rules[id] = schemaValidator(schema, { verbose: true });\n    }\n\n    const validateRule = validators.rules[id];\n\n    if (validateRule) {\n        validateRule(localOptions);\n        if (validateRule.errors) {\n            throw new Error(validateRule.errors.map(error => `\\tValue \"${error.value}\" ${error.message}.\\n`).join(\"\"));\n        }\n    }\n}\n\n/**\n * Validates a rule's options against its schema.\n * @param {string} id The rule's unique name.\n * @param {array|number} options The given options for the rule.\n * @param {string} source The name of the configuration source.\n * @returns {void}\n */\nfunction validateRuleOptions(id, options, source) {\n    try {\n        const severity = validateRuleSeverity(options);\n\n        if (severity !== 0 && !(typeof severity === \"string\" && severity.toLowerCase() === \"off\")) {\n            validateRuleSchema(id, Array.isArray(options) ? options.slice(1) : []);\n        }\n    } catch (err) {\n        throw new Error(`${source}:\\n\\tConfiguration for rule \"${id}\" is invalid:\\n${err.message}`);\n    }\n}\n\n/**\n * Validates an environment object\n * @param {Object} environment The environment config object to validate.\n * @param {string} source The location to report with any errors.\n * @returns {void}\n */\nfunction validateEnvironment(environment, source) {\n\n    // not having an environment is ok\n    if (!environment) {\n        return;\n    }\n\n    if (Array.isArray(environment)) {\n        throw new Error(\"Environment must not be an array\");\n    }\n\n    if (typeof environment === \"object\") {\n        Object.keys(environment).forEach(env => {\n            if (!Environments.get(env)) {\n                const message = [\n                    source, \":\\n\",\n                    \"\\tEnvironment key \\\"\", env, \"\\\" is unknown\\n\"\n                ];\n\n                throw new Error(message.join(\"\"));\n            }\n        });\n    } else {\n        throw new Error(\"Environment must be an object\");\n    }\n}\n\n/**\n * Validates an entire config object.\n * @param {Object} config The config object to validate.\n * @param {string} source The location to report with any errors.\n * @returns {void}\n */\nfunction validate(config, source) {\n\n    if (typeof config.rules === \"object\") {\n        Object.keys(config.rules).forEach(id => {\n            validateRuleOptions(id, config.rules[id], source);\n        });\n    }\n\n    validateEnvironment(config.env, source);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    getRuleOptionsSchema,\n    validate,\n    validateRuleOptions\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/rules.js":"/**\n * @fileoverview Defines a storage for rules.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst loadRules = require(\"./load-rules\");\n\n//------------------------------------------------------------------------------\n// Privates\n//------------------------------------------------------------------------------\n\nlet rules = Object.create(null);\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Registers a rule module for rule id in storage.\n * @param {string} ruleId Rule id (file name).\n * @param {Function} ruleModule Rule handler.\n * @returns {void}\n */\nfunction define(ruleId, ruleModule) {\n    rules[ruleId] = ruleModule;\n}\n\n/**\n * Loads and registers all rules from passed rules directory.\n * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.\n * @param {string} cwd Current working directory\n * @returns {void}\n */\nfunction load(rulesDir, cwd) {\n    const newRules = loadRules(rulesDir, cwd);\n\n    Object.keys(newRules).forEach(ruleId => {\n        define(ruleId, newRules[ruleId]);\n    });\n}\n\n/**\n * Registers all given rules of a plugin.\n * @param {Object} plugin The plugin object to import.\n * @param {string} pluginName The name of the plugin without prefix (`eslint-plugin-`).\n * @returns {void}\n */\nfunction importPlugin(plugin, pluginName) {\n    if (plugin.rules) {\n        Object.keys(plugin.rules).forEach(ruleId => {\n            const qualifiedRuleId = `${pluginName}/${ruleId}`,\n                rule = plugin.rules[ruleId];\n\n            define(qualifiedRuleId, rule);\n        });\n    }\n}\n\n/**\n * Access rule handler by id (file name).\n * @param {string} ruleId Rule id (file name).\n * @returns {Function} Rule handler.\n */\nfunction getHandler(ruleId) {\n    if (typeof rules[ruleId] === \"string\") {\n        return require(rules[ruleId]);\n    }\n    return rules[ruleId];\n\n}\n\n/**\n * Get an object with all currently loaded rules\n * @returns {Map} All loaded rules\n */\nfunction getAllLoadedRules() {\n    const allRules = new Map();\n\n    Object.keys(rules).forEach(name => {\n        const rule = getHandler(name);\n\n        allRules.set(name, rule);\n    });\n    return allRules;\n}\n\n/**\n * Reset rules storage.\n * Should be used only in tests.\n * @returns {void}\n */\nfunction testClear() {\n    rules = Object.create(null);\n}\n\nmodule.exports = {\n    define,\n    load,\n    importPlugin,\n    get: getHandler,\n    getAllLoadedRules,\n    testClear,\n\n    /**\n     * Resets rules to its starting state. Use for tests only.\n     * @returns {void}\n     */\n    testReset() {\n        testClear();\n        load();\n    }\n};\n\n//------------------------------------------------------------------------------\n// Initialization\n//------------------------------------------------------------------------------\n\n// loads built-in rules\nload();\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/load-rules.js":"/**\n * @fileoverview Module for loading rules from files and directories.\n * @author Michael Ficarra\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Load all rule modules from specified directory.\n * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.\n * @param {string} cwd Current working directory\n * @returns {Object} Loaded rule modules by rule ids (file names).\n */\nmodule.exports = function(rulesDir, cwd) {\n    if (!rulesDir) {\n        rulesDir = path.join(__dirname, \"rules\");\n    } else {\n        rulesDir = path.resolve(cwd, rulesDir);\n    }\n\n    const rules = Object.create(null);\n\n    fs.readdirSync(rulesDir).forEach(file => {\n        if (path.extname(file) !== \".js\") {\n            return;\n        }\n        rules[file.slice(0, -3)] = path.join(rulesDir, file);\n    });\n    return rules;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/comment-event-generator.js":"/**\n * @fileoverview The event generator for comments.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check collection of comments to prevent double event for comment as\n * leading and trailing, then emit event if passing\n * @param {ASTNode[]} comments - Collection of comment nodes\n * @param {EventEmitter} emitter - The event emitter which is the destination of events.\n * @param {Object[]} locs - List of locations of previous comment nodes\n * @param {string} eventName - Event name postfix\n * @returns {void}\n */\nfunction emitComments(comments, emitter, locs, eventName) {\n    if (comments.length > 0) {\n        comments.forEach(node => {\n            const index = locs.indexOf(node.loc);\n\n            if (index >= 0) {\n                locs.splice(index, 1);\n            } else {\n                locs.push(node.loc);\n                emitter.emit(node.type + eventName, node);\n            }\n        });\n    }\n}\n\n/**\n * Shortcut to check and emit enter of comment nodes\n * @param {CommentEventGenerator} generator - A generator to emit.\n * @param {ASTNode[]} comments - Collection of comment nodes\n * @returns {void}\n */\nfunction emitCommentsEnter(generator, comments) {\n    emitComments(\n        comments,\n        generator.emitter,\n        generator.commentLocsEnter,\n        \"Comment\");\n}\n\n/**\n * Shortcut to check and emit exit of comment nodes\n * @param {CommentEventGenerator} generator - A generator to emit.\n * @param {ASTNode[]} comments Collection of comment nodes\n * @returns {void}\n */\nfunction emitCommentsExit(generator, comments) {\n    emitComments(\n        comments,\n        generator.emitter,\n        generator.commentLocsExit,\n        \"Comment:exit\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for comments.\n * This is the decorator pattern.\n * This generates events of comments before/after events which are generated the original generator.\n *\n * Comment event generator class\n */\nclass CommentEventGenerator {\n\n    /**\n     * @param {EventGenerator} originalEventGenerator - An event generator which is the decoration target.\n     * @param {SourceCode} sourceCode - A source code which has comments.\n     */\n    constructor(originalEventGenerator, sourceCode) {\n        this.original = originalEventGenerator;\n        this.emitter = originalEventGenerator.emitter;\n        this.sourceCode = sourceCode;\n        this.commentLocsEnter = [];\n        this.commentLocsExit = [];\n    }\n\n    /**\n     * Emits an event of entering comments.\n     * @param {ASTNode} node - A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        const comments = this.sourceCode.getComments(node);\n\n        emitCommentsEnter(this, comments.leading);\n        this.original.enterNode(node);\n        emitCommentsEnter(this, comments.trailing);\n    }\n\n    /**\n     * Emits an event of leaving comments.\n     * @param {ASTNode} node - A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        const comments = this.sourceCode.getComments(node);\n\n        emitCommentsExit(this, comments.trailing);\n        this.original.leaveNode(node);\n        emitCommentsExit(this, comments.leading);\n    }\n}\n\nmodule.exports = CommentEventGenerator;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/node-event-generator.js":"/**\n * @fileoverview The event generator for AST nodes.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An object describing an AST selector\n * @typedef {Object} ASTSelector\n * @property {string} rawSelector The string that was parsed into this selector\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\n * or `null` if all node types could cause a match\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\n * @property {number} identifierCount The total number of identifier queries in this selector\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n* Gets the possible types of a selector\n* @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\n* @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\n*/\nfunction getPossibleTypes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"identifier\":\n            return [parsedSelector.value];\n\n        case \"matches\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n            if (typesForComponents.every(typesForComponent => typesForComponent)) {\n                return lodash.union.apply(null, typesForComponents);\n            }\n            return null;\n        }\n\n        case \"compound\": {\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\n\n            // If all of the components could match any type, then the compound could also match any type.\n            if (!typesForComponents.length) {\n                return null;\n            }\n\n            /*\n             * If at least one of the components could only match a particular type, the compound could only match\n             * the intersection of those types.\n             */\n            return lodash.intersection.apply(null, typesForComponents);\n        }\n\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return getPossibleTypes(parsedSelector.right);\n\n        default:\n            return null;\n\n    }\n}\n\n/**\n * Counts the number of class, pseudo-class, and attribute queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\n */\nfunction countClassAttributes(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n        case \"attribute\":\n        case \"field\":\n        case \"nth-child\":\n        case \"nth-last-child\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Counts the number of identifier queries in this selector\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\n * @returns {number} The number of identifier queries\n */\nfunction countIdentifiers(parsedSelector) {\n    switch (parsedSelector.type) {\n        case \"child\":\n        case \"descendant\":\n        case \"sibling\":\n        case \"adjacent\":\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n        case \"compound\":\n        case \"not\":\n        case \"matches\":\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n        case \"identifier\":\n            return 1;\n\n        default:\n            return 0;\n    }\n}\n\n/**\n * Compares the specificity of two selector objects, with CSS-like rules.\n * @param {ASTSelector} selectorA An AST selector descriptor\n * @param {ASTSelector} selectorB Another AST selector descriptor\n * @returns {number}\n * a value less than 0 if selectorA is less specific than selectorB\n * a value greater than 0 if selectorA is more specific than selectorB\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\n */\nfunction compareSpecificity(selectorA, selectorB) {\n    return selectorA.attributeCount - selectorB.attributeCount ||\n        selectorA.identifierCount - selectorB.identifierCount ||\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n\n/**\n * Parses a raw selector string, and throws a useful error if parsing fails.\n * @param {string} rawSelector A raw AST selector\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\n * @throws {Error} An error if the selector is invalid\n */\nfunction tryParseSelector(rawSelector) {\n    try {\n        return esquery.parse(rawSelector.replace(/:exit$/, \"\"));\n    } catch (err) {\n        if (typeof err.offset === \"number\") {\n            throw new Error(`Syntax error in selector \"${rawSelector}\" at position ${err.offset}: ${err.message}`);\n        }\n        throw err;\n    }\n}\n\n/**\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\n * @param {string} rawSelector A raw AST selector\n * @returns {ASTSelector} A selector descriptor\n */\nconst parseSelector = lodash.memoize(rawSelector => {\n    const parsedSelector = tryParseSelector(rawSelector);\n\n    return {\n        rawSelector,\n        isExit: rawSelector.endsWith(\":exit\"),\n        parsedSelector,\n        listenerTypes: getPossibleTypes(parsedSelector),\n        attributeCount: countClassAttributes(parsedSelector),\n        identifierCount: countIdentifiers(parsedSelector)\n    };\n});\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The event generator for AST nodes.\n * This implements below interface.\n *\n * ```ts\n * interface EventGenerator {\n *     emitter: EventEmitter;\n *     enterNode(node: ASTNode): void;\n *     leaveNode(node: ASTNode): void;\n * }\n * ```\n */\nclass NodeEventGenerator {\n\n    /**\n    * @param {EventEmitter} emitter - An event emitter which is the destination of events. This emitter must already\n    * have registered listeners for all of the events that it needs to listen for.\n    * @returns {NodeEventGenerator} new instance\n    */\n    constructor(emitter) {\n        this.emitter = emitter;\n        this.currentAncestry = [];\n        this.enterSelectorsByNodeType = new Map();\n        this.exitSelectorsByNodeType = new Map();\n        this.anyTypeEnterSelectors = [];\n        this.anyTypeExitSelectors = [];\n\n        const eventNames = typeof emitter.eventNames === \"function\"\n\n            // Use the built-in eventNames() function if available (Node 6+)\n            ? emitter.eventNames()\n\n            /*\n             * Otherwise, use the private _events property.\n             * Using a private property isn't ideal here, but this seems to\n             * be the best way to get a list of event names without overriding\n             * addEventListener, which would hurt performance. This property\n             * is widely used and unlikely to be removed in a future version\n             * (see https://github.com/nodejs/node/issues/1817). Also, future\n             * node versions will have eventNames() anyway.\n             */\n            : Object.keys(emitter._events); // eslint-disable-line no-underscore-dangle\n\n        eventNames.forEach(rawSelector => {\n            const selector = parseSelector(rawSelector);\n\n            if (selector.listenerTypes) {\n                selector.listenerTypes.forEach(nodeType => {\n                    const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n\n                    if (!typeMap.has(nodeType)) {\n                        typeMap.set(nodeType, []);\n                    }\n                    typeMap.get(nodeType).push(selector);\n                });\n            } else {\n                (selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(selector);\n            }\n        });\n\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\n        this.anyTypeExitSelectors.sort(compareSpecificity);\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    }\n\n    /**\n     * Checks a selector against a node, and emits it if it matches\n     * @param {ASTNode} node The node to check\n     * @param {ASTSelector} selector An AST selector descriptor\n     * @returns {void}\n     */\n    applySelector(node, selector) {\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {\n            this.emitter.emit(selector.rawSelector, node);\n        }\n    }\n\n    /**\n     * Applies all appropriate selectors to a node, in specificity order\n     * @param {ASTNode} node The node to check\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\n     * @returns {void}\n     */\n    applySelectors(node, isExit) {\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n\n        /*\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\n         * Iterate through each of them, applying selectors in the right order.\n         */\n        let selectorsByTypeIndex = 0;\n        let anyTypeSelectorsIndex = 0;\n\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n            if (\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\n            ) {\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n            } else {\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n            }\n        }\n    }\n\n    /**\n     * Emits an event of entering AST node.\n     * @param {ASTNode} node - A node which was entered.\n     * @returns {void}\n     */\n    enterNode(node) {\n        if (node.parent) {\n            this.currentAncestry.unshift(node.parent);\n        }\n        this.applySelectors(node, false);\n    }\n\n    /**\n     * Emits an event of leaving AST node.\n     * @param {ASTNode} node - A node which was left.\n     * @returns {void}\n     */\n    leaveNode(node) {\n        this.applySelectors(node, true);\n        this.currentAncestry.shift();\n    }\n}\n\nmodule.exports = NodeEventGenerator;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/source-code.js":"/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst TokenStore = require(\"../token-store\"),\n    Traverser = require(\"./traverser\"),\n    astUtils = require(\"../ast-utils\"),\n    lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Finds a JSDoc comment node in an array of comment nodes.\n * @param {ASTNode[]} comments The array of comment nodes to search.\n * @param {int} line Line number to look around\n * @returns {ASTNode} The node if found, null if not.\n * @private\n */\nfunction findJSDocComment(comments, line) {\n\n    if (comments) {\n        for (let i = comments.length - 1; i >= 0; i--) {\n            if (comments[i].type === \"Block\" && comments[i].value.charAt(0) === \"*\") {\n\n                if (line - comments[i].loc.end.line <= 1) {\n                    return comments[i];\n                }\n                break;\n\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * Check to see if its a ES6 export declaration\n * @param {ASTNode} astNode - any node\n * @returns {boolean} whether the given node represents a export declaration\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n/**\n * Merges two sorted lists into a larger sorted list in O(n) time\n * @param {Token[]} tokens The list of tokens\n * @param {Token[]} comments The list of comments\n * @returns {Token[]} A sorted list of tokens and comments\n */\nfunction sortedMerge(tokens, comments) {\n    const result = [];\n    let tokenIndex = 0;\n    let commentIndex = 0;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n            result.push(tokens[tokenIndex++]);\n        } else {\n            result.push(comments[commentIndex++]);\n        }\n    }\n\n    return result;\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Represents parsed source code.\n * @param {string} text - The source code text.\n * @param {ASTNode} ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n * @constructor\n */\nfunction SourceCode(text, ast) {\n    validate(ast);\n\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type boolean\n     */\n    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type string\n     */\n    this.text = (this.hasBOM ? text.slice(1) : text);\n\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n    this.ast = ast;\n\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n    this.lines = [];\n    this.lineStartIndices = [0];\n\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n\n    /*\n     * Previously, this was implemented using a regex that\n     * matched a sequence of non-linebreak characters followed by a\n     * linebreak, then adding the lengths of the matches. However,\n     * this caused a catastrophic backtracking issue when the end\n     * of a file contained a large number of non-newline characters.\n     * To avoid this, the current implementation just matches newlines\n     * and uses match.index to get the correct line start indices.\n     */\n    while ((match = lineEndingPattern.exec(this.text))) {\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n        this.lineStartIndices.push(match.index + match[0].length);\n    }\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\n\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n\n    // create token store methods\n    const tokenStore = new TokenStore(ast.tokens, ast.comments);\n\n    for (const methodName of TokenStore.PUBLIC_METHODS) {\n        this[methodName] = tokenStore[methodName].bind(tokenStore);\n    }\n\n    // don't allow modification of this object\n    Object.freeze(this);\n    Object.freeze(this.lines);\n}\n\n/**\n * Split the source code into multiple lines based on the line delimiters\n * @param {string} text Source code as a string\n * @returns {string[]} Array of source code lines\n * @public\n */\nSourceCode.splitLines = function(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n};\n\nSourceCode.prototype = {\n    constructor: SourceCode,\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     */\n    getText(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        }\n        return this.text;\n\n\n    },\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     */\n    getLines() {\n        return this.lines;\n    },\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     */\n    getAllComments() {\n        return this.ast.comments;\n    },\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} The list of comments indexed by their position.\n     * @public\n     */\n    getComments(node) {\n\n        let leadingComments = node.leadingComments || [];\n        const trailingComments = node.trailingComments || [];\n\n        /*\n         * espree adds a \"comments\" array on Program nodes rather than\n         * leadingComments/trailingComments. Comments are only left in the\n         * Program node comments array if there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                leadingComments = node.comments;\n            }\n        }\n\n        return {\n            leading: leadingComments,\n            trailing: trailingComments\n        };\n    },\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {ASTNode} The BlockComment node containing the JSDoc for the\n     *      given node or null if not found.\n     * @public\n     */\n    getJSDocComment(node) {\n\n        let parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                if (looksLikeExport(parent)) {\n                    return findJSDocComment(parent.leadingComments, parent.loc.start.line);\n                }\n                return findJSDocComment(node.leadingComments, node.loc.start.line);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (parent && !parent.leadingComments && !/Function/.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n                        parent = parent.parent;\n                    }\n\n                    return parent && (parent.type !== \"FunctionDeclaration\") ? findJSDocComment(parent.leadingComments, parent.loc.start.line) : null;\n                } else if (node.leadingComments) {\n                    return findJSDocComment(node.leadingComments, node.loc.start.line);\n                }\n\n            // falls through\n\n            default:\n                return null;\n        }\n    },\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     */\n    getNodeByRangeIndex(index) {\n        let result = null,\n            resultParent = null;\n        const traverser = new Traverser();\n\n        traverser.traverse(this.ast, {\n            enter(node, parent) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                    resultParent = parent;\n                } else {\n                    this.skip();\n                }\n            },\n            leave(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result ? Object.assign({ parent: resultParent }, result) : null;\n    },\n\n    /**\n     * Determines if two tokens have at least one whitespace character\n     * between them. This completely disregards comments in making the\n     * determination, so comments count as zero-length substrings.\n     * @param {Token} first The token to check after.\n     * @param {Token} second The token to check before.\n     * @returns {boolean} True if there is only space between tokens, false\n     *  if there is anything other than whitespace between tokens.\n     */\n    isSpaceBetweenTokens(first, second) {\n        const text = this.text.slice(first.range[1], second.range[0]);\n\n        return /\\s/.test(text.replace(/\\/\\*.*?\\*\\//g, \"\"));\n    },\n\n    /**\n    * Converts a source text index into a (line, column) pair.\n    * @param {number} index The index of a character in a file\n    * @returns {Object} A {line, column} location object with a 0-indexed column\n    */\n    getLocFromIndex(index) {\n        if (typeof index !== \"number\") {\n            throw new TypeError(\"Expected `index` to be a number.\");\n        }\n\n        if (index < 0 || index > this.text.length) {\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n        }\n\n        /*\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\n         * line; otherwise, the location will be in the next column on the same line.\n         *\n         * See getIndexFromLoc for the motivation for this special case.\n         */\n        if (index === this.text.length) {\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\n        }\n\n        /*\n         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could\n         * be inserted into lineIndices to keep the list sorted.\n         */\n        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);\n\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\n\n    },\n\n    /**\n    * Converts a (line, column) pair into a range index.\n    * @param {Object} loc A line/column location\n    * @param {number} loc.line The line number of the location (1-indexed)\n    * @param {number} loc.column The column number of the location (0-indexed)\n    * @returns {number} The range index of the location in the file.\n    */\n    getIndexFromLoc(loc) {\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n        }\n\n        if (loc.line <= 0) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n        }\n\n        if (loc.line > this.lineStartIndices.length) {\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n        }\n\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n        const positionIndex = lineStartIndex + loc.column;\n\n        /*\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\n         * the given line, provided that the line number is valid element of this.lines. Since the\n         * last element of this.lines is an empty string for files with trailing newlines, add a\n         * special case where getting the index for the first location after the end of the file\n         * will return the length of the file, rather than throwing an error. This allows rules to\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\n         */\n        if (\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\n        ) {\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n        }\n\n        return positionIndex;\n    }\n};\n\n\nmodule.exports = SourceCode;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/index.js":"/**\n * @fileoverview Object to handle access and retrieval of tokens.\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst cursors = require(\"./cursors\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PUBLIC_METHODS = Object.freeze([\n    \"getTokenByRangeStart\",\n\n    \"getFirstToken\",\n    \"getLastToken\",\n    \"getTokenBefore\",\n    \"getTokenAfter\",\n    \"getFirstTokenBetween\",\n    \"getLastTokenBetween\",\n\n    \"getFirstTokens\",\n    \"getLastTokens\",\n    \"getTokensBefore\",\n    \"getTokensAfter\",\n    \"getFirstTokensBetween\",\n    \"getLastTokensBetween\",\n\n    \"getTokens\",\n    \"getTokensBetween\",\n\n    \"getTokenOrCommentBefore\",\n    \"getTokenOrCommentAfter\"\n]);\n\n/**\n * Creates the map from locations to indices in `tokens`.\n *\n * The first/last location of tokens is mapped to the index of the token.\n * The first/last location of comments is mapped to the index of the next token of each comment.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @returns {Object} The map from locations to indices in `tokens`.\n * @private\n */\nfunction createIndexMap(tokens, comments) {\n    const map = Object.create(null);\n    let tokenIndex = 0;\n    let commentIndex = 0;\n    let nextStart = 0;\n    let range = null;\n\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            tokenIndex += 1;\n        }\n\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n            map[range[0]] = tokenIndex;\n            map[range[1] - 1] = tokenIndex;\n            commentIndex += 1;\n        }\n    }\n\n    return map;\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {CursorFactory} factory - The cursor factory to initialize cursor.\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments=false] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.skip=0] - The count of tokens the cursor skips.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let skip = 0;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        skip = opts | 0;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        skip = opts.skip | 0;\n        filter = opts.filter || null;\n    }\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {CursorFactory} factory - The cursor factory to initialize cursor.\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n    let includeComments = false;\n    let count = 0;\n    let countExists = false;\n    let filter = null;\n\n    if (typeof opts === \"number\") {\n        count = opts | 0;\n        countExists = true;\n    } else if (typeof opts === \"function\") {\n        filter = opts;\n    } else if (opts) {\n        includeComments = !!opts.includeComments;\n        count = opts.count | 0;\n        countExists = typeof opts.count === \"number\";\n        filter = opts.filter || null;\n    }\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n\n/**\n * Creates the cursor iterates tokens with options.\n * This is overload function of the below.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {Function|Object} opts - The option object. If this is a function then it's `opts.filter`.\n * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.\n * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.\n * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n * @returns {Cursor} The created cursor.\n * @private\n */\n/**\n * Creates the cursor iterates tokens with options.\n *\n * @param {Token[]} tokens - The array of tokens.\n * @param {Comment[]} comments - The array of comments.\n * @param {Object} indexMap - The map from locations to indices in `tokens`.\n * @param {number} startLoc - The start location of the iteration range.\n * @param {number} endLoc - The end location of the iteration range.\n * @param {number} [beforeCount=0] - The number of tokens before the node to retrieve.\n * @param {boolean} [afterCount=0] - The number of tokens after the node to retrieve.\n * @returns {Cursor} The created cursor.\n * @private\n */\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n    }\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The token store.\n *\n * This class provides methods to get tokens by locations as fast as possible.\n * The methods are a part of public API, so we should be careful if it changes this class.\n *\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\n * This uses binary-searching instead for comments.\n */\nmodule.exports = class TokenStore {\n\n    /**\n     * Initializes this token store.\n     *\n     *  `comments` needs to be cloned for backward compatibility.\n     * After this initialization, ESLint removes a shebang's comment from `comments`.\n     * However, so far we had been concatenating 'tokens' and 'comments' before,\n     * so the shebang's comment had remained in the concatenated array.\n     * As a result, both the result of `getTokenOrCommentAfter` and `getTokenOrCommentBefore`\n     * methods had included the shebang's comment.\n     * And some rules depends on this behavior.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     */\n    constructor(tokens, comments) {\n        this.tokens = tokens;\n        this.comments = comments.slice(0);\n        this.indexMap = createIndexMap(tokens, comments);\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets single token.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the token starting at the specified index.\n     * @param {number} offset - Index of the start of the token's range.\n     * @param {Object} [options=0] - The option object.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @returns {Token|null} The token starting at index, or null if no such token.\n     */\n    getTokenByRangeStart(offset, options) {\n        const includeComments = options && options.includeComments;\n        const token = cursors.forward.createBaseCursor(\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            offset,\n            -1,\n            includeComments\n        ).getOneToken();\n\n        if (token && token.range[0] === offset) {\n            return token;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the first token of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstToken(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getLastToken(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenBefore(node, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            -1,\n            node.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getTokenAfter(node, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[1],\n            -1,\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the first token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left - Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right - Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} An object representing the token.\n     */\n    getFirstTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the last token between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.skip=0] - The count of tokens the cursor skips.\n     * @returns {Token|null} Tokens between left and right.\n     */\n    getLastTokenBetween(left, right, options) {\n        return createCursorWithSkip(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getOneToken();\n    }\n\n    /**\n     * Gets the token that precedes a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentBefore(node, skip) {\n        return this.getTokenBefore(node, { includeComments: true, skip });\n    }\n\n    /**\n     * Gets the token that follows a given node or token in the token stream.\n     * This is defined for backward compatibility. Use `includeComments` option instead.\n     * TODO: We have a plan to remove this in a future major version.\n     * @param {ASTNode|Token|Comment} node The AST node or token.\n     * @param {number} [skip=0] A number of tokens to skip.\n     * @returns {Token|null} An object representing the token.\n     * @deprecated\n     */\n    getTokenOrCommentAfter(node, skip) {\n        return this.getTokenAfter(node, { includeComments: true, skip });\n    }\n\n    //--------------------------------------------------------------------------\n    // Gets multiple tokens.\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets the first `count` tokens of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getFirstTokens(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens of the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getLastTokens(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that precedes a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getTokensBefore(node, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            -1,\n            node.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets the `count` tokens that follows a given node or token.\n     * @param {ASTNode|Token|Comment} node - The AST node or token.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens.\n     */\n    getTokensAfter(node, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[1],\n            -1,\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the first `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left - Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right - Node after the desired token range.\n     * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getFirstTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.forward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets the last `count` tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getLastTokensBetween(left, right, options) {\n        return createCursorWithCount(\n            cursors.backward,\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            options\n        ).getAllTokens().reverse();\n    }\n\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    /**\n     * Gets all tokens that are related to the given node.\n     * @param {ASTNode} node - The AST node.\n     * @param {int} [beforeCount=0] - The number of tokens before the node to retrieve.\n     * @param {int} [afterCount=0] - The number of tokens after the node to retrieve.\n     * @returns {Token[]} Array of objects representing tokens.\n     */\n    getTokens(node, beforeCount, afterCount) {\n        return createCursorWithPadding(\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            node.range[0],\n            node.range[1],\n            beforeCount,\n            afterCount\n        ).getAllTokens();\n    }\n\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\n     * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.\n     * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.\n     * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    /**\n     * Gets all of the tokens between two non-overlapping nodes.\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\n     * @returns {Token[]} Tokens between left and right.\n     */\n    getTokensBetween(left, right, padding) {\n        return createCursorWithPadding(\n            this.tokens,\n            this.comments,\n            this.indexMap,\n            left.range[1],\n            right.range[0],\n            padding,\n            padding\n        ).getAllTokens();\n    }\n};\n\nmodule.exports.PUBLIC_METHODS = PUBLIC_METHODS;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/cursors.js":"/**\n * @fileoverview Define 2 token factories; forward and backward.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst BackwardTokenCommentCursor = require(\"./backward-token-comment-cursor\");\nconst BackwardTokenCursor = require(\"./backward-token-cursor\");\nconst FilterCursor = require(\"./filter-cursor\");\nconst ForwardTokenCommentCursor = require(\"./forward-token-comment-cursor\");\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\nconst LimitCursor = require(\"./limit-cursor\");\nconst SkipCursor = require(\"./skip-cursor\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The cursor factory.\n * @private\n */\nclass CursorFactory {\n\n    /**\n     * Initializes this cursor.\n     * @param {Function} TokenCursor - The class of the cursor which iterates tokens only.\n     * @param {Function} TokenCommentCursor - The class of the cursor which iterates the mix of tokens and comments.\n     */\n    constructor(TokenCursor, TokenCommentCursor) {\n        this.TokenCursor = TokenCursor;\n        this.TokenCommentCursor = TokenCommentCursor;\n    }\n\n    /**\n     * Creates a base cursor instance that can be decorated by createCursor.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {boolean} includeComments - The flag to iterate comments as well.\n     * @returns {Cursor} The created base cursor.\n     */\n    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {\n        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;\n\n        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);\n    }\n\n    /**\n     * Creates a cursor that iterates tokens with normalized options.\n     *\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {boolean} includeComments - The flag to iterate comments as well.\n     * @param {Function|null} filter - The predicate function to choose tokens.\n     * @param {number} skip - The count of tokens the cursor skips.\n     * @param {number} count - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\n     * @returns {Cursor} The created cursor.\n     */\n    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {\n        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);\n\n        if (filter) {\n            cursor = new FilterCursor(cursor, filter);\n        }\n        if (skip >= 1) {\n            cursor = new SkipCursor(cursor, skip);\n        }\n        if (count >= 0) {\n            cursor = new LimitCursor(cursor, count);\n        }\n\n        return cursor;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\nexports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);\nexports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/backward-token-comment-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens and comments in reverse.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments in reverse.\n */\nmodule.exports = class BackwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.commentIndex = utils.search(comments, endLoc) - 1;\n        this.border = startLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex >= 0) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex >= 0) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[1] > comment.range[1])) {\n            this.current = token;\n            this.tokenIndex -= 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex -= 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/cursor.js":"/**\n * @fileoverview Define the abstract class about cursors which iterate tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which iterate tokens.\n *\n * This class has 2 abstract methods.\n *\n * - `current: Token | Comment | null` ... The current token.\n * - `moveNext(): boolean` ... Moves this cursor to the next token. If the next token didn't exist, it returns `false`.\n *\n * This is similar to ES2015 Iterators.\n * However, Iterators were slow (at 2017-01), so I created this class as similar to C# IEnumerable.\n *\n * There are the following known sub classes.\n *\n * - ForwardTokenCursor .......... The cursor which iterates tokens only.\n * - BackwardTokenCursor ......... The cursor which iterates tokens only in reverse.\n * - ForwardTokenCommentCursor ... The cursor which iterates tokens and comments.\n * - BackwardTokenCommentCursor .. The cursor which iterates tokens and comments in reverse.\n * - DecorativeCursor\n *     - FilterCursor ............ The cursor which ignores the specified tokens.\n *     - SkipCursor .............. The cursor which ignores the first few tokens.\n *     - LimitCursor ............. The cursor which limits the count of tokens.\n *\n */\nmodule.exports = class Cursor {\n\n    /**\n     * Initializes this cursor.\n     */\n    constructor() {\n        this.current = null;\n    }\n\n    /**\n     * Gets the first token.\n     * This consumes this cursor.\n     * @returns {Token|Comment} The first token or null.\n     */\n    getOneToken() {\n        return this.moveNext() ? this.current : null;\n    }\n\n    /**\n     * Gets the first tokens.\n     * This consumes this cursor.\n     * @returns {(Token|Comment)[]} All tokens.\n     */\n    getAllTokens() {\n        const tokens = [];\n\n        while (this.moveNext()) {\n            tokens.push(this.current);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Moves this cursor to the next token.\n     * @returns {boolean} `true` if the next token exists.\n     * @abstract\n     */\n    /* istanbul ignore next */\n    moveNext() { // eslint-disable-line class-methods-use-this\n        throw new Error(\"Not implemented.\");\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/utils.js":"/**\n * @fileoverview Define utilify functions for token store.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets `token.range[0]` from the given token.\n *\n * @param {Node|Token|Comment} token - The token to get.\n * @returns {number} The start location.\n * @private\n */\nfunction getStartLocation(token) {\n    return token.range[0];\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * Binary-searches the index of the first token which is after the given location.\n * If it was not found, this returns `tokens.length`.\n *\n * @param {(Token|Comment)[]} tokens - It searches the token in this list.\n * @param {number} location - The location to search.\n * @returns {number} The found index or `tokens.length`.\n */\nexports.search = function search(tokens, location) {\n    return lodash.sortedIndexBy(\n        tokens,\n        { range: [location] },\n        getStartLocation\n    );\n};\n\n/**\n * Gets the index of the `startLoc` in `tokens`.\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\n *\n * @param {(Token|Comment)[]} tokens - The tokens to find an index.\n * @param {Object} indexMap - The map from locations to indices.\n * @param {number} startLoc - The location to get an index.\n * @returns {number} The index.\n */\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n    if (startLoc in indexMap) {\n        return indexMap[startLoc];\n    }\n    if ((startLoc - 1) in indexMap) {\n        const index = indexMap[startLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        // For the map of \"comment's location -> token's index\", it points the next token of a comment.\n        // In that case, +1 is unnecessary.\n        if (token && token.range[0] >= startLoc) {\n            return index;\n        }\n        return index + 1;\n    }\n    return 0;\n};\n\n/**\n * Gets the index of the `endLoc` in `tokens`.\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\n *\n * @param {(Token|Comment)[]} tokens - The tokens to find an index.\n * @param {Object} indexMap - The map from locations to indices.\n * @param {number} endLoc - The location to get an index.\n * @returns {number} The index.\n */\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n    if (endLoc in indexMap) {\n        return indexMap[endLoc] - 1;\n    }\n    if ((endLoc - 1) in indexMap) {\n        const index = indexMap[endLoc - 1];\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\n\n        // For the map of \"comment's location -> token's index\", it points the next token of a comment.\n        // In that case, -1 is necessary.\n        if (token && token.range[1] > endLoc) {\n            return index - 1;\n        }\n        return index;\n    }\n    return tokens.length - 1;\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/backward-token-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens only in reverse.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only in reverse.\n */\nmodule.exports = class BackwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getLastIndex(tokens, indexMap, endLoc);\n        this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index >= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index -= 1;\n            return true;\n        }\n        return false;\n    }\n\n    //\n    // Shorthand for performance.\n    //\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index >= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/filter-cursor.js":"/**\n * @fileoverview Define the cursor which ignores specified tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores specified tokens.\n */\nmodule.exports = class FilterCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {Function} predicate - The predicate function to decide tokens this cursor iterates.\n     */\n    constructor(cursor, predicate) {\n        super(cursor);\n        this.predicate = predicate;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const predicate = this.predicate;\n\n        while (super.moveNext()) {\n            if (predicate(this.current)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/decorative-cursor.js":"/**\n * @fileoverview Define the abstract class about cursors which manipulate another cursor.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The abstract class about cursors which manipulate another cursor.\n */\nmodule.exports = class DecorativeCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     */\n    constructor(cursor) {\n        super();\n        this.cursor = cursor;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const retv = this.cursor.moveNext();\n\n        this.current = this.cursor.current;\n\n        return retv;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/forward-token-comment-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens and comments.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens and comments.\n */\nmodule.exports = class ForwardTokenCommentCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.comments = comments;\n        this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.commentIndex = utils.search(comments, startLoc);\n        this.border = endLoc;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        const token = (this.tokenIndex < this.tokens.length) ? this.tokens[this.tokenIndex] : null;\n        const comment = (this.commentIndex < this.comments.length) ? this.comments[this.commentIndex] : null;\n\n        if (token && (!comment || token.range[0] < comment.range[0])) {\n            this.current = token;\n            this.tokenIndex += 1;\n        } else if (comment) {\n            this.current = comment;\n            this.commentIndex += 1;\n        } else {\n            this.current = null;\n        }\n\n        return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/forward-token-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens only.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Cursor = require(\"./cursor\");\nconst utils = require(\"./utils\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only.\n */\nmodule.exports = class ForwardTokenCursor extends Cursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc) {\n        super();\n        this.tokens = tokens;\n        this.index = utils.getFirstIndex(tokens, indexMap, startLoc);\n        this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.index <= this.indexEnd) {\n            this.current = this.tokens[this.index];\n            this.index += 1;\n            return true;\n        }\n        return false;\n    }\n\n    //\n    // Shorthand for performance.\n    //\n\n    /** @inheritdoc */\n    getOneToken() {\n        return (this.index <= this.indexEnd) ? this.tokens[this.index] : null;\n    }\n\n    /** @inheritdoc */\n    getAllTokens() {\n        return this.tokens.slice(this.index, this.indexEnd + 1);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/limit-cursor.js":"/**\n * @fileoverview Define the cursor which limits the number of tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which limits the number of tokens.\n */\nmodule.exports = class LimitCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {number} count - The count of tokens this cursor iterates.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        if (this.count > 0) {\n            this.count -= 1;\n            return super.moveNext();\n        }\n        return false;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/skip-cursor.js":"/**\n * @fileoverview Define the cursor which ignores the first few tokens.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst DecorativeCursor = require(\"./decorative-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The decorative cursor which ignores the first few tokens.\n */\nmodule.exports = class SkipCursor extends DecorativeCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Cursor} cursor - The cursor to be decorated.\n     * @param {number} count - The count of tokens this cursor skips.\n     */\n    constructor(cursor, count) {\n        super(cursor);\n        this.count = count;\n    }\n\n    /** @inheritdoc */\n    moveNext() {\n        while (this.count > 0) {\n            this.count -= 1;\n            if (!super.moveNext()) {\n                return false;\n            }\n        }\n        return super.moveNext();\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/token-store/padded-token-cursor.js":"/**\n * @fileoverview Define the cursor which iterates tokens only, with inflated range.\n * @author Toru Nagashima\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The cursor which iterates tokens only, with inflated range.\n * This is for the backward compatibility of padding options.\n */\nmodule.exports = class PaddedTokenCursor extends ForwardTokenCursor {\n\n    /**\n     * Initializes this cursor.\n     * @param {Token[]} tokens - The array of tokens.\n     * @param {Comment[]} comments - The array of comments.\n     * @param {Object} indexMap - The map from locations to indices in `tokens`.\n     * @param {number} startLoc - The start location of the iteration range.\n     * @param {number} endLoc - The end location of the iteration range.\n     * @param {number} beforeCount - The number of tokens this cursor iterates before start.\n     * @param {number} afterCount - The number of tokens this cursor iterates after end.\n     */\n    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n        super(tokens, comments, indexMap, startLoc, endLoc);\n        this.index = Math.max(0, this.index - beforeCount);\n        this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/traverser.js":"/**\n * @fileoverview Wrapper around estraverse\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst estraverse = require(\"estraverse\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst KEY_BLACKLIST = new Set([\n    \"parent\",\n    \"leadingComments\",\n    \"trailingComments\"\n]);\n\n/**\n * Wrapper around an estraverse controller that ensures the correct keys\n * are visited.\n * @constructor\n */\nclass Traverser extends estraverse.Controller {\n    traverse(node, visitor) {\n        visitor.fallback = Traverser.getKeys;\n        return super.traverse(node, visitor);\n    }\n\n    /**\n     * Calculates the keys to use for traversal.\n     * @param {ASTNode} node The node to read keys from.\n     * @returns {string[]} An array of keys to visit on the node.\n     * @private\n     */\n    static getKeys(node) {\n        return Object.keys(node).filter(key => !KEY_BLACKLIST.has(key));\n    }\n}\n\nmodule.exports = Traverser;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/rule-context.js":"/**\n * @fileoverview RuleContext utility for rules\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst ruleFixer = require(\"./util/rule-fixer\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PASSTHROUGHS = [\n    \"getAncestors\",\n    \"getDeclaredVariables\",\n    \"getFilename\",\n    \"getScope\",\n    \"markVariableAsUsed\",\n\n    // DEPRECATED\n    \"getAllComments\",\n    \"getComments\",\n    \"getFirstToken\",\n    \"getFirstTokens\",\n    \"getJSDocComment\",\n    \"getLastToken\",\n    \"getLastTokens\",\n    \"getNodeByRangeIndex\",\n    \"getSource\",\n    \"getSourceLines\",\n    \"getTokenAfter\",\n    \"getTokenBefore\",\n    \"getTokenByRangeStart\",\n    \"getTokens\",\n    \"getTokensAfter\",\n    \"getTokensBefore\",\n    \"getTokensBetween\"\n];\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {string} nodeType The type of node.\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} fix The function to call that creates a fix command.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Rule context class\n * Acts as an abstraction layer between rules and the main eslint object.\n */\nclass RuleContext {\n\n    /**\n     * @param {string} ruleId The ID of the rule using this object.\n     * @param {eslint} eslint The eslint object.\n     * @param {number} severity The configured severity level of the rule.\n     * @param {Array} options The configuration information to be added to the rule.\n     * @param {Object} settings The configuration settings passed from the config file.\n     * @param {Object} parserOptions The parserOptions settings passed from the config file.\n     * @param {Object} parserPath The parser setting passed from the config file.\n     * @param {Object} meta The metadata of the rule\n     * @param {Object} parserServices The parser services for the rule.\n     */\n    constructor(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices) {\n\n        // public.\n        this.id = ruleId;\n        this.options = options;\n        this.settings = settings;\n        this.parserOptions = parserOptions;\n        this.parserPath = parserPath;\n        this.meta = meta;\n\n        // create a separate copy and freeze it (it's not nice to freeze other people's objects)\n        this.parserServices = Object.freeze(Object.assign({}, parserServices));\n\n        // private.\n        this.eslint = eslint;\n        this.severity = severity;\n\n        Object.freeze(this);\n    }\n\n    /**\n     * Passthrough to eslint.getSourceCode().\n     * @returns {SourceCode} The SourceCode object for the code.\n     */\n    getSourceCode() {\n        return this.eslint.getSourceCode();\n    }\n\n    /**\n     * Passthrough to eslint.report() that automatically assigns the rule ID and severity.\n     * @param {ASTNode|MessageDescriptor} nodeOrDescriptor The AST node related to the message or a message\n     *      descriptor.\n     * @param {Object=} location The location of the error.\n     * @param {string} message The message to display to the user.\n     * @param {Object} opts Optional template data which produces a formatted message\n     *     with symbols being replaced by this object's values.\n     * @returns {void}\n     */\n    report(nodeOrDescriptor, location, message, opts) {\n\n        // check to see if it's a new style call\n        if (arguments.length === 1) {\n            const descriptor = nodeOrDescriptor;\n            let fix = null;\n\n            // if there's a fix specified, get it\n            if (typeof descriptor.fix === \"function\") {\n                fix = descriptor.fix(ruleFixer);\n            }\n\n            this.eslint.report(\n                this.id,\n                this.severity,\n                descriptor.node,\n                descriptor.loc || descriptor.node.loc.start,\n                descriptor.message,\n                descriptor.data,\n                fix,\n                this.meta\n            );\n\n            return;\n        }\n\n        // old style call\n        this.eslint.report(\n            this.id,\n            this.severity,\n            nodeOrDescriptor,\n            location,\n            message,\n            opts,\n            this.meta\n        );\n    }\n}\n\n// Copy over passthrough methods. All functions will have 5 or fewer parameters.\nPASSTHROUGHS.forEach(function(name) {\n    this[name] = function(a, b, c, d, e) {\n        return this.eslint[name](a, b, c, d, e);\n    };\n}, RuleContext.prototype);\n\nmodule.exports = RuleContext;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/rule-fixer.js":"/**\n * @fileoverview An object that creates fix commands for rules.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Creates a fix command that inserts text at the specified index in the source text.\n * @param {int} index The 0-based index at which to insert the new text.\n * @param {string} text The text to insert.\n * @returns {Object} The fix command.\n * @private\n */\nfunction insertTextAt(index, text) {\n    return {\n        range: [index, index],\n        text\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates code fixing commands for rules.\n */\n\nconst ruleFixer = Object.freeze({\n\n    /**\n     * Creates a fix command that inserts text after the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfter(nodeOrToken, text) {\n        return this.insertTextAfterRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text after the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextAfterRange(range, text) {\n        return insertTextAt(range[1], text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the given node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBefore(nodeOrToken, text) {\n        return this.insertTextBeforeRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that inserts text before the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    insertTextBeforeRange(range, text) {\n        return insertTextAt(range[0], text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the node or token.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceText(nodeOrToken, text) {\n        return this.replaceTextRange(nodeOrToken.range, text);\n    },\n\n    /**\n     * Creates a fix command that replaces text at the specified range in the source text.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to replace, first item is start of range, second\n     *      is end of range.\n     * @param {string} text The text to insert.\n     * @returns {Object} The fix command.\n     */\n    replaceTextRange(range, text) {\n        return {\n            range,\n            text\n        };\n    },\n\n    /**\n     * Creates a fix command that removes the node or token from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\n     * @returns {Object} The fix command.\n     */\n    remove(nodeOrToken) {\n        return this.removeRange(nodeOrToken.range);\n    },\n\n    /**\n     * Creates a fix command that removes the specified range of text from the source.\n     * The fix is not applied until applyFixes() is called.\n     * @param {int[]} range The range to remove, first item is start of range, second\n     *      is end of range.\n     * @returns {Object} The fix command.\n     */\n    removeRange(range) {\n        return {\n            range,\n            text: \"\"\n        };\n    }\n\n});\n\n\nmodule.exports = ruleFixer;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/timing.js":"/**\n * @fileoverview Tracks performance of individual rules.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next */\n/**\n * Align the string to left\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignLeft(str, len, ch) {\n    return str + new Array(len - str.length + 1).join(ch || \" \");\n}\n\n/* istanbul ignore next */\n/**\n * Align the string to right\n * @param {string} str string to evaluate\n * @param {int} len length of the string\n * @param {string} ch delimiter character\n * @returns {string} modified string\n * @private\n */\nfunction alignRight(str, len, ch) {\n    return new Array(len - str.length + 1).join(ch || \" \") + str;\n}\n\n//------------------------------------------------------------------------------\n// Module definition\n//------------------------------------------------------------------------------\n\nconst enabled = !!process.env.TIMING;\n\nconst HEADERS = [\"Rule\", \"Time (ms)\", \"Relative\"];\nconst ALIGN = [alignLeft, alignRight, alignRight];\n\n/* istanbul ignore next */\n/**\n * display the data\n * @param {Object} data Data object to be displayed\n * @returns {string} modified string\n * @private\n */\nfunction display(data) {\n    let total = 0;\n    const rows = Object.keys(data)\n        .map(key => {\n            const time = data[key];\n\n            total += time;\n            return [key, time];\n        })\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 10);\n\n    rows.forEach(row => {\n        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);\n        row[1] = row[1].toFixed(3);\n    });\n\n    rows.unshift(HEADERS);\n\n    const widths = [];\n\n    rows.forEach(row => {\n        const len = row.length;\n\n        for (let i = 0; i < len; i++) {\n            const n = row[i].length;\n\n            if (!widths[i] || n > widths[i]) {\n                widths[i] = n;\n            }\n        }\n    });\n\n    const table = rows.map(row =>\n        row\n            .map((cell, index) => ALIGN[index](cell, widths[index]))\n            .join(\" | \")\n    );\n\n    table.splice(1, 0, widths.map((w, index) => {\n        if (index !== 0 && index !== widths.length - 1) {\n            w++;\n        }\n\n        return ALIGN[index](\":\", w + 1, \"-\");\n    }).join(\"|\"));\n\n    console.log(table.join(\"\\n\"));      // eslint-disable-line no-console\n}\n\n/* istanbul ignore next */\nmodule.exports = (function() {\n\n    const data = Object.create(null);\n\n    /**\n     * Time the run\n     * @param {*} key key from the data object\n     * @param {Function} fn function to be called\n     * @returns {Function} function to be executed\n     * @private\n     */\n    function time(key, fn) {\n        if (typeof data[key] === \"undefined\") {\n            data[key] = 0;\n        }\n\n        return function() {\n            let t = process.hrtime();\n\n            fn.apply(null, Array.prototype.slice.call(arguments));\n            t = process.hrtime(t);\n            data[key] += t[0] * 1e3 + t[1] / 1e6;\n        };\n    }\n\n    if (enabled) {\n        process.on(\"exit\", () => {\n            display(data);\n        });\n    }\n\n    return {\n        time,\n        enabled\n    };\n\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/cli-engine.js":"/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    rules = require(\"./rules\"),\n    eslint = require(\"./eslint\"),\n    defaultOptions = require(\"../conf/cli-options\"),\n    IgnoredPaths = require(\"./ignored-paths\"),\n    Config = require(\"./config\"),\n    Plugins = require(\"./config/plugins\"),\n    fileEntryCache = require(\"file-entry-cache\"),\n    globUtil = require(\"./util/glob-util\"),\n    SourceCodeFixer = require(\"./util/source-code-fixer\"),\n    validator = require(\"./config/config-validator\"),\n    stringify = require(\"json-stable-stringify\"),\n    hash = require(\"./util/hash\"),\n\n    pkg = require(\"../package.json\");\n\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} allowInlineConfig Enable or disable inline configuration comments.\n * @property {boolean|Object} baseConfig Base config object. True enables recommend rules and environments.\n * @property {boolean} cache Enable result caching.\n * @property {string} cacheLocation The cache file to use instead of .eslintcache.\n * @property {string} configFile The configuration file to use.\n * @property {string} cwd The value to use for the current working directory.\n * @property {string[]} envs An array of environments to load.\n * @property {string[]} extensions An array of file extensions to check.\n * @property {boolean} fix Execute in autofix mode.\n * @property {string[]} globals An array of global variables to declare.\n * @property {boolean} ignore False disables use of .eslintignore.\n * @property {string} ignorePath The ignore file to use instead of .eslintignore.\n * @property {string} ignorePattern A glob pattern of files to ignore.\n * @property {boolean} useEslintrc False disables looking for .eslintrc\n * @property {string} parser The name of the parser to use.\n * @property {Object} parserOptions An object of parserOption settings to use.\n * @property {string[]} plugins An array of plugins to load.\n * @property {Object<string,*>} rules An object of rules to use.\n * @property {string[]} rulePaths An array of directories to load custom rules from.\n */\n\n/**\n * A linting warning or error.\n * @typedef {Object} LintMessage\n * @property {string} message The message to display to the user.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number or errors for the result.\n * @property {number} warningCount Number or warnings for the result.\n * @property {string=} [source] The source code of the file that was linted.\n * @property {string=} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {Object[]} messages - Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    return messages.reduce((stat, message) => {\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n        } else {\n            stat.warningCount++;\n        }\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0\n    });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {Object[]} results - Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    return results.reduce((stat, result) => {\n        stat.errorCount += result.errorCount;\n        stat.warningCount += result.warningCount;\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0\n    });\n}\n\n/**\n * Performs multiple autofix passes over the text until as many fixes as possible\n * have been applied.\n * @param {string} text The source text to apply fixes to.\n * @param {Object} config The ESLint config object to use.\n * @param {Object} options The ESLint options object to use.\n * @param {string} options.filename The filename from which the text was read.\n * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n *      should be allowed.\n * @returns {Object} The result of the fix operation as returned from the\n *      SourceCodeFixer.\n * @private\n */\nfunction multipassFix(text, config, options) {\n    const MAX_PASSES = 10;\n    let messages = [],\n        fixedResult,\n        fixed = false,\n        passNumber = 0;\n\n    /**\n     * This loop continues until one of the following is true:\n     *\n     * 1. No more fixes have been applied.\n     * 2. Ten passes have been made.\n     *\n     * That means anytime a fix is successfully applied, there will be another pass.\n     * Essentially, guaranteeing a minimum of two passes.\n     */\n    do {\n        passNumber++;\n\n        debug(`Linting code for ${options.filename} (pass ${passNumber})`);\n        messages = eslint.verify(text, config, options);\n\n        debug(`Generating fixed text for ${options.filename} (pass ${passNumber})`);\n        fixedResult = SourceCodeFixer.applyFixes(eslint.getSourceCode(), messages);\n\n        // stop if there are any syntax errors.\n        // 'fixedResult.output' is a empty string.\n        if (messages.length === 1 && messages[0].fatal) {\n            break;\n        }\n\n        // keep track if any fixes were ever applied - important for return value\n        fixed = fixed || fixedResult.fixed;\n\n        // update to use the fixed output instead of the original text\n        text = fixedResult.output;\n\n    } while (\n        fixedResult.fixed &&\n        passNumber < MAX_PASSES\n    );\n\n\n    /*\n     * If the last result had fixes, we need to lint again to be sure we have\n     * the most up-to-date information.\n     */\n    if (fixedResult.fixed) {\n        fixedResult.messages = eslint.verify(text, config, options);\n    }\n\n\n    // ensure the last result properly reflects if fixes were done\n    fixedResult.fixed = fixed;\n    fixedResult.output = text;\n\n    return fixedResult;\n\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {string} text The source code to check.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {string} filename An optional string representing the texts filename.\n * @param {boolean} fix Indicates if fixes should be processed.\n * @param {boolean} allowInlineConfig Allow/ignore comments that change config.\n * @returns {LintResult} The results for linting on this text.\n * @private\n */\nfunction processText(text, configHelper, filename, fix, allowInlineConfig) {\n\n    // clear all existing settings for a new file\n    eslint.reset();\n\n    let filePath,\n        messages,\n        fileExtension,\n        processor,\n        fixedResult;\n\n    if (filename) {\n        filePath = path.resolve(filename);\n        fileExtension = path.extname(filename);\n    }\n\n    filename = filename || \"<text>\";\n    debug(`Linting ${filename}`);\n    const config = configHelper.getConfig(filePath);\n\n    if (config.plugins) {\n        Plugins.loadAll(config.plugins);\n    }\n\n    const loadedPlugins = Plugins.getAll();\n\n    for (const plugin in loadedPlugins) {\n        if (loadedPlugins[plugin].processors && Object.keys(loadedPlugins[plugin].processors).indexOf(fileExtension) >= 0) {\n            processor = loadedPlugins[plugin].processors[fileExtension];\n            break;\n        }\n    }\n\n    if (processor) {\n        debug(\"Using processor\");\n        const parsedBlocks = processor.preprocess(text, filename);\n        const unprocessedMessages = [];\n\n        parsedBlocks.forEach(block => {\n            unprocessedMessages.push(eslint.verify(block, config, {\n                filename,\n                allowInlineConfig\n            }));\n        });\n\n        // TODO(nzakas): Figure out how fixes might work for processors\n\n        messages = processor.postprocess(unprocessedMessages, filename);\n\n    } else {\n\n        if (fix) {\n            fixedResult = multipassFix(text, config, {\n                filename,\n                allowInlineConfig\n            });\n            messages = fixedResult.messages;\n        } else {\n            messages = eslint.verify(text, config, {\n                filename,\n                allowInlineConfig\n            });\n        }\n    }\n\n    const stats = calculateStatsPerFile(messages);\n\n    const result = {\n        filePath: filename,\n        messages,\n        errorCount: stats.errorCount,\n        warningCount: stats.warningCount\n    };\n\n    if (fixedResult && fixedResult.fixed) {\n        result.output = fixedResult.output;\n    }\n\n    if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n        result.source = text;\n    }\n\n    return result;\n}\n\n/**\n * Processes an individual file using ESLint. Files used here are known to\n * exist, so no need to check that here.\n * @param {string} filename The filename of the file being checked.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {Object} options The CLIEngine options object.\n * @returns {LintResult} The results for linting on this file.\n * @private\n */\nfunction processFile(filename, configHelper, options) {\n\n    const text = fs.readFileSync(path.resolve(filename), \"utf8\"),\n        result = processText(text, configHelper, filename, options.fix, options.allowInlineConfig);\n\n    return result;\n\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath - File path of checked code\n * @param {string} baseDir  - Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    let message;\n    const isHidden = /^\\./.test(path.basename(filePath));\n    const isInNodeModules = baseDir && /^node_modules/.test(path.relative(baseDir, filePath));\n    const isInBowerComponents = baseDir && /^bower_components/.test(path.relative(baseDir, filePath));\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n    } else if (isInBowerComponents) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!bower_components/*'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                fatal: false,\n                severity: 1,\n                message\n            }\n        ],\n        errorCount: 0,\n        warningCount: 1\n    };\n}\n\n\n/**\n * Checks if the given message is an error message.\n * @param {Object} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n *\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    cacheFile = path.normalize(cacheFile);\n\n    const resolvedCacheFile = path.resolve(cwd, cacheFile);\n    const looksLikeADirectory = cacheFile[cacheFile.length - 1 ] === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n    }\n\n    let fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch (ex) {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates a new instance of the core CLI engine.\n * @param {CLIEngineOptions} options The options for this instance.\n * @constructor\n */\nfunction CLIEngine(options) {\n\n    options = Object.assign(\n        Object.create(null),\n        defaultOptions,\n        { cwd: process.cwd() },\n        options\n    );\n\n    /**\n     * Stored options for this instance\n     * @type {Object}\n     */\n    this.options = options;\n\n    const cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);\n\n    /**\n     * Cache used to avoid operating on files that haven't changed since the\n     * last successful execution (e.g., file passed linting with no errors and\n     * no warnings).\n     * @type {Object}\n     */\n    this._fileCache = fileEntryCache.create(cacheFile);\n\n    // load in additional rules\n    if (this.options.rulePaths) {\n        const cwd = this.options.cwd;\n\n        this.options.rulePaths.forEach(rulesdir => {\n            debug(`Loading rules from ${rulesdir}`);\n            rules.load(rulesdir, cwd);\n        });\n    }\n\n    Object.keys(this.options.rules || {}).forEach(name => {\n        validator.validateRuleOptions(name, this.options.rules[name], \"CLI\");\n    });\n}\n\n/**\n * Returns the formatter representing the given format or null if no formatter\n * with the given name can be found.\n * @param {string} [format] The name of the format to load or the path to a\n *      custom formatter.\n * @returns {Function} The formatter function or null if not found.\n */\nCLIEngine.getFormatter = function(format) {\n\n    let formatterPath;\n\n    // default is stylish\n    format = format || \"stylish\";\n\n    // only strings are valid formatters\n    if (typeof format === \"string\") {\n\n        // replace \\ with / for Windows compatibility\n        format = format.replace(/\\\\/g, \"/\");\n\n        // if there's a slash, then it's a file\n        if (format.indexOf(\"/\") > -1) {\n            const cwd = this.options ? this.options.cwd : process.cwd();\n\n            formatterPath = path.resolve(cwd, format);\n        } else {\n            formatterPath = `./formatters/${format}`;\n        }\n\n        try {\n            return require(formatterPath);\n        } catch (ex) {\n            ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n            throw ex;\n        }\n\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns results that only contains errors.\n * @param {LintResult[]} results The results to filter.\n * @returns {LintResult[]} The filtered results.\n */\nCLIEngine.getErrorResults = function(results) {\n    const filtered = [];\n\n    results.forEach(result => {\n        const filteredMessages = result.messages.filter(isErrorMessage);\n\n        if (filteredMessages.length > 0) {\n            filtered.push(\n                Object.assign(result, {\n                    messages: filteredMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0\n                })\n            );\n        }\n    });\n\n    return filtered;\n};\n\n/**\n * Outputs fixes from the given results to files.\n * @param {Object} report The report object created by CLIEngine.\n * @returns {void}\n */\nCLIEngine.outputFixes = function(report) {\n    report.results.filter(result => result.hasOwnProperty(\"output\")).forEach(result => {\n        fs.writeFileSync(result.filePath, result.output);\n    });\n};\n\nCLIEngine.prototype = {\n\n    constructor: CLIEngine,\n\n    /**\n     * Add a plugin by passing it's configuration\n     * @param {string} name Name of the plugin.\n     * @param {Object} pluginobject Plugin configuration object.\n     * @returns {void}\n     */\n    addPlugin(name, pluginobject) {\n        Plugins.define(name, pluginobject);\n    },\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n    resolveFileGlobPatterns(patterns) {\n        return globUtil.resolveFileGlobPatterns(patterns, this.options);\n    },\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Object} The results for all files that were linted.\n     */\n    executeOnFiles(patterns) {\n        const results = [],\n            options = this.options,\n            fileCache = this._fileCache,\n            configHelper = new Config(options);\n        let prevConfig; // the previous configuration used\n\n        /**\n         * Calculates the hash of the config file used to validate a given file\n         * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash\n         * @returns {string}         the hash of the config\n         */\n        function hashOfConfigFor(filename) {\n            const config = configHelper.getConfig(filename);\n\n            if (!prevConfig) {\n                prevConfig = {};\n            }\n\n            // reuse the previously hashed config if the config hasn't changed\n            if (prevConfig.config !== config) {\n\n                /*\n                 * config changed so we need to calculate the hash of the config\n                 * and the hash of the plugins being used\n                 */\n                prevConfig.config = config;\n\n                const eslintVersion = pkg.version;\n\n                prevConfig.hash = hash(`${eslintVersion}_${stringify(config)}`);\n            }\n\n            return prevConfig.hash;\n        }\n\n        /**\n         * Executes the linter on a file defined by the `filename`. Skips\n         * unsupported file extensions and any files that are already linted.\n         * @param {string} filename The resolved filename of the file to be linted\n         * @param {boolean} warnIgnored always warn when a file is ignored\n         * @returns {void}\n         */\n        function executeOnFile(filename, warnIgnored) {\n            let hashOfConfig,\n                descriptor;\n\n            if (warnIgnored) {\n                results.push(createIgnoreResult(filename, options.cwd));\n                return;\n            }\n\n            if (options.cache) {\n\n                /*\n                 * get the descriptor for this file\n                 * with the metadata and the flag that determines if\n                 * the file has changed\n                 */\n                descriptor = fileCache.getFileDescriptor(filename);\n                const meta = descriptor.meta || {};\n\n                hashOfConfig = hashOfConfigFor(filename);\n\n                const changed = descriptor.changed || meta.hashOfConfig !== hashOfConfig;\n\n                if (!changed) {\n                    debug(`Skipping file since hasn't changed: ${filename}`);\n\n                    /*\n                     * Add the the cached results (always will be 0 error and\n                     * 0 warnings). We should not cache results for files that\n                     * failed, in order to guarantee that next execution will\n                     * process those files as well.\n                     */\n                    results.push(descriptor.meta.results);\n\n                    // move to the next file\n                    return;\n                }\n            } else {\n                fileCache.destroy();\n            }\n\n            debug(`Processing ${filename}`);\n\n            const res = processFile(filename, configHelper, options);\n\n            if (options.cache) {\n\n                /*\n                 * if a file contains errors or warnings we don't want to\n                 * store the file in the cache so we can guarantee that\n                 * next execution will also operate on this file\n                 */\n                if (res.errorCount > 0 || res.warningCount > 0) {\n                    debug(`File has problems, skipping it: ${filename}`);\n\n                    // remove the entry from the cache\n                    fileCache.removeEntry(filename);\n                } else {\n\n                    /*\n                     * since the file passed we store the result here\n                     * TODO: check this as we might not need to store the\n                     * successful runs as it will always should be 0 errors and\n                     * 0 warnings.\n                     */\n                    descriptor.meta.hashOfConfig = hashOfConfig;\n                    descriptor.meta.results = res;\n                }\n            }\n\n            results.push(res);\n        }\n\n        const startTime = Date.now();\n\n\n\n        patterns = this.resolveFileGlobPatterns(patterns);\n        const fileList = globUtil.listFilesToProcess(patterns, options);\n\n        fileList.forEach(fileInfo => {\n            executeOnFile(fileInfo.filename, fileInfo.ignored);\n        });\n\n        const stats = calculateStatsPerRun(results);\n\n        if (options.cache) {\n\n            // persist the cache to disk\n            fileCache.reconcile();\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n\n        return {\n            results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount\n        };\n    },\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} filename An optional string representing the texts filename.\n     * @param {boolean} warnIgnored Always warn when a file is ignored\n     * @returns {Object} The results for the linting.\n     */\n    executeOnText(text, filename, warnIgnored) {\n\n        const results = [],\n            options = this.options,\n            configHelper = new Config(options),\n            ignoredPaths = new IgnoredPaths(options);\n\n        // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)\n        if (filename && !path.isAbsolute(filename)) {\n            filename = path.resolve(options.cwd, filename);\n        }\n\n        if (filename && ignoredPaths.contains(filename)) {\n            if (warnIgnored) {\n                results.push(createIgnoreResult(filename, options.cwd));\n            }\n        } else {\n            results.push(processText(text, configHelper, filename, options.fix, options.allowInlineConfig));\n        }\n\n        const stats = calculateStatsPerRun(results);\n\n        return {\n            results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount\n        };\n    },\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Object} A configuration object for the file.\n     */\n    getConfigForFile(filePath) {\n        const configHelper = new Config(this.options);\n\n        return configHelper.getConfig(filePath);\n    },\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n    isPathIgnored(filePath) {\n        const resolvedPath = path.resolve(this.options.cwd, filePath);\n        const ignoredPaths = new IgnoredPaths(this.options);\n\n        return ignoredPaths.contains(resolvedPath);\n    },\n\n    getFormatter: CLIEngine.getFormatter\n\n};\n\nCLIEngine.version = pkg.version;\n\nmodule.exports = CLIEngine;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/conf/cli-options.js":"/**\n * @fileoverview Default CLIEngineOptions.\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\nmodule.exports = {\n    configFile: null,\n    baseConfig: false,\n    rulePaths: [],\n    useEslintrc: true,\n    envs: [],\n    globals: [],\n    rules: {},\n    extensions: [\".js\"],\n    ignore: true,\n    ignorePath: null,\n    parser: \"\",     // must be empty\n    cache: false,\n\n    // in order to honor the cacheFile option if specified\n    // this option should not have a default value otherwise\n    // it will always be used\n    cacheLocation: \"\",\n    cacheFile: \".eslintcache\",\n    fix: false,\n    allowInlineConfig: true\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/ignored-paths.js":"/**\n * @fileoverview Responsible for loading ignore config files and managing ignore patterns\n * @author Jonathan Rajavuori\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    ignore = require(\"ignore\"),\n    shell = require(\"shelljs\"),\n    pathUtil = require(\"./util/path-util\");\n\nconst debug = require(\"debug\")(\"eslint:ignored-paths\");\n\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst ESLINT_IGNORE_FILENAME = \".eslintignore\";\n\n/**\n * Adds `\"*\"` at the end of `\"node_modules/\"`,\n * so that subtle directories could be re-included by .gitignore patterns\n * such as `\"!node_modules/should_not_ignored\"`\n */\nconst DEFAULT_IGNORE_DIRS = [\n    \"/node_modules/*\",\n    \"/bower_components/*\"\n];\nconst DEFAULT_OPTIONS = {\n    dotfiles: false,\n    cwd: process.cwd()\n};\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\n/**\n * Find an ignore file in the current directory.\n * @param {string} cwd Current working directory\n * @returns {string} Path of ignore file or an empty string.\n */\nfunction findIgnoreFile(cwd) {\n    cwd = cwd || DEFAULT_OPTIONS.cwd;\n\n    const ignoreFilePath = path.resolve(cwd, ESLINT_IGNORE_FILENAME);\n\n    return shell.test(\"-f\", ignoreFilePath) ? ignoreFilePath : \"\";\n}\n\n/**\n * Merge options with defaults\n * @param {Object} options Options to merge with DEFAULT_OPTIONS constant\n * @returns {Object} Merged options\n */\nfunction mergeDefaultOptions(options) {\n    options = (options || {});\n    return Object.assign({}, DEFAULT_OPTIONS, options);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * IgnoredPaths class\n */\nclass IgnoredPaths {\n\n    /**\n     * @param {Object} options object containing 'ignore', 'ignorePath' and 'patterns' properties\n     */\n    constructor(options) {\n        options = mergeDefaultOptions(options);\n\n        /**\n         * add pattern to node-ignore instance\n         * @param {Object} ig, instance of node-ignore\n         * @param {string} pattern, pattern do add to ig\n         * @returns {array} raw ignore rules\n         */\n        function addPattern(ig, pattern) {\n            return ig.addPattern(pattern);\n        }\n\n        /**\n         * add ignore file to node-ignore instance\n         * @param {Object} ig, instance of node-ignore\n         * @param {string} filepath, file to add to ig\n         * @returns {array} raw ignore rules\n         */\n        function addIgnoreFile(ig, filepath) {\n            ig.ignoreFiles.push(filepath);\n            return ig.add(fs.readFileSync(filepath, \"utf8\"));\n        }\n\n        this.defaultPatterns = [].concat(DEFAULT_IGNORE_DIRS, options.patterns || []);\n        this.baseDir = options.cwd;\n\n        this.ig = {\n            custom: ignore(),\n            default: ignore()\n        };\n\n        // Add a way to keep track of ignored files.  This was present in node-ignore\n        // 2.x, but dropped for now as of 3.0.10.\n        this.ig.custom.ignoreFiles = [];\n        this.ig.default.ignoreFiles = [];\n\n        if (options.dotfiles !== true) {\n\n            /*\n             * ignore files beginning with a dot, but not files in a parent or\n             * ancestor directory (which in relative format will begin with `../`).\n             */\n            addPattern(this.ig.default, [\".*\", \"!../\"]);\n        }\n\n        addPattern(this.ig.default, this.defaultPatterns);\n\n        if (options.ignore !== false) {\n            let ignorePath;\n\n            if (options.ignorePath) {\n                debug(\"Using specific ignore file\");\n\n                try {\n                    fs.statSync(options.ignorePath);\n                    ignorePath = options.ignorePath;\n                } catch (e) {\n                    e.message = `Cannot read ignore file: ${options.ignorePath}\\nError: ${e.message}`;\n                    throw e;\n                }\n            } else {\n                debug(`Looking for ignore file in ${options.cwd}`);\n                ignorePath = findIgnoreFile(options.cwd);\n\n                try {\n                    fs.statSync(ignorePath);\n                    debug(`Loaded ignore file ${ignorePath}`);\n                } catch (e) {\n                    debug(\"Could not find ignore file in cwd\");\n                    this.options = options;\n                }\n            }\n\n            if (ignorePath) {\n                debug(`Adding ${ignorePath}`);\n                this.baseDir = path.dirname(path.resolve(options.cwd, ignorePath));\n                addIgnoreFile(this.ig.custom, ignorePath);\n                addIgnoreFile(this.ig.default, ignorePath);\n            }\n\n            if (options.ignorePattern) {\n                addPattern(this.ig.custom, options.ignorePattern);\n                addPattern(this.ig.default, options.ignorePattern);\n            }\n        }\n\n        this.options = options;\n    }\n\n    /**\n     * Determine whether a file path is included in the default or custom ignore patterns\n     * @param {string} filepath Path to check\n     * @param {string} [category=null] check 'default', 'custom' or both (null)\n     * @returns {boolean} true if the file path matches one or more patterns, false otherwise\n     */\n    contains(filepath, category) {\n\n        let result = false;\n        const absolutePath = path.resolve(this.options.cwd, filepath);\n        const relativePath = pathUtil.getRelativePath(absolutePath, this.options.cwd);\n\n        if ((typeof category === \"undefined\") || (category === \"default\")) {\n            result = result || (this.ig.default.filter([relativePath]).length === 0);\n        }\n\n        if ((typeof category === \"undefined\") || (category === \"custom\")) {\n            result = result || (this.ig.custom.filter([relativePath]).length === 0);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Returns a list of dir patterns for glob to ignore\n     * @returns {function()} method to check whether a folder should be ignored by glob.\n     */\n    getIgnoredFoldersGlobChecker() {\n\n        const ig = ignore().add(DEFAULT_IGNORE_DIRS);\n\n        if (this.options.dotfiles !== true) {\n\n            // Ignore hidden folders.  (This cannot be \".*\", or else it's not possible to unignore hidden files)\n            ig.add([\".*/*\", \"!../\"]);\n        }\n\n        if (this.options.ignore) {\n            ig.add(this.ig.custom);\n        }\n\n        const filter = ig.createFilter();\n\n        /**\n         * TODO\n         * 1.\n         * Actually, it should be `this.options.baseDir`, which is the base dir of `ignore-path`,\n         * as well as Line 177.\n         * But doing this leads to a breaking change and fails tests.\n         * Related to #6759\n         */\n        const base = this.options.cwd;\n\n        return function(absolutePath) {\n            const relative = pathUtil.getRelativePath(absolutePath, base);\n\n            if (!relative) {\n                return false;\n            }\n\n            return !filter(relative);\n        };\n    }\n}\n\nmodule.exports = IgnoredPaths;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/path-util.js":"/**\n * @fileoverview Common helpers for operations on filenames and paths\n * @author Ian VanSchooten\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Replace Windows with posix style paths\n *\n * @param {string} filepath   Path to convert\n * @returns {string}          Converted filepath\n */\nfunction convertPathToPosix(filepath) {\n    const normalizedFilepath = path.normalize(filepath);\n    const posixFilepath = normalizedFilepath.replace(/\\\\/g, \"/\");\n\n    return posixFilepath;\n}\n\n/**\n * Converts an absolute filepath to a relative path from a given base path\n *\n * For example, if the filepath is `/my/awesome/project/foo.bar`,\n * and the base directory is `/my/awesome/project/`,\n * then this function should return `foo.bar`.\n *\n * path.relative() does something similar, but it requires a baseDir (`from` argument).\n * This function makes it optional and just removes a leading slash if the baseDir is not given.\n *\n * It does not take into account symlinks (for now).\n *\n * @param {string} filepath  Path to convert to relative path.  If already relative,\n *                           it will be assumed to be relative to process.cwd(),\n *                           converted to absolute, and then processed.\n * @param {string} [baseDir] Absolute base directory to resolve the filepath from.\n *                           If not provided, all this function will do is remove\n *                           a leading slash.\n * @returns {string} Relative filepath\n */\nfunction getRelativePath(filepath, baseDir) {\n    let relativePath;\n\n    if (!path.isAbsolute(filepath)) {\n        filepath = path.resolve(filepath);\n    }\n    if (baseDir) {\n        if (!path.isAbsolute(baseDir)) {\n            throw new Error(\"baseDir should be an absolute path\");\n        }\n        relativePath = path.relative(baseDir, filepath);\n    } else {\n        relativePath = filepath.replace(/^\\//, \"\");\n    }\n    return relativePath;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    convertPathToPosix,\n    getRelativePath\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/config.js":"/**\n * @fileoverview Responsible for loading config files\n * @author Seth McLaughlin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    ConfigFile = require(\"./config/config-file\"),\n    Plugins = require(\"./config/plugins\"),\n    FileFinder = require(\"./file-finder\"),\n    userHome = require(\"user-home\"),\n    isResolvable = require(\"is-resolvable\"),\n    pathIsInside = require(\"path-is-inside\");\n\nconst debug = require(\"debug\")(\"eslint:config\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst PERSONAL_CONFIG_DIR = userHome || null;\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Check if item is an javascript object\n * @param {*} item object to check for\n * @returns {boolean} True if its an object\n * @private\n */\nfunction isObject(item) {\n    return typeof item === \"object\" && !Array.isArray(item) && item !== null;\n}\n\n/**\n * Load and parse a JSON config object from a file.\n * @param {string|Object} configToLoad the path to the JSON config file or the config object itself.\n * @returns {Object} the parsed config object (empty object if there was a parse error)\n * @private\n */\nfunction loadConfig(configToLoad) {\n    let config = {},\n        filePath = \"\";\n\n    if (configToLoad) {\n\n        if (isObject(configToLoad)) {\n            config = configToLoad;\n\n            if (config.extends) {\n                config = ConfigFile.applyExtends(config, filePath);\n            }\n        } else {\n            filePath = configToLoad;\n            config = ConfigFile.load(filePath);\n        }\n\n    }\n\n    return config;\n}\n\n/**\n * Get personal config object from ~/.eslintrc.\n * @returns {Object} the personal config object (null if there is no personal config)\n * @private\n */\nfunction getPersonalConfig() {\n    let config;\n\n    if (PERSONAL_CONFIG_DIR) {\n        const filename = ConfigFile.getFilenameForDirectory(PERSONAL_CONFIG_DIR);\n\n        if (filename) {\n            debug(\"Using personal config\");\n            config = loadConfig(filename);\n        }\n    }\n\n    return config || null;\n}\n\n/**\n * Determine if rules were explicitly passed in as options.\n * @param {Object} options The options used to create our configuration.\n * @returns {boolean} True if rules were passed in as options, false otherwise.\n */\nfunction hasRules(options) {\n    return options.rules && Object.keys(options.rules).length > 0;\n}\n\n/**\n * Get a local config object.\n * @param {Object} thisConfig A Config object.\n * @param {string} directory The directory to start looking in for a local config file.\n * @returns {Object} The local config object, or an empty object if there is no local config.\n */\nfunction getLocalConfig(thisConfig, directory) {\n    const localConfigFiles = thisConfig.findLocalConfigFiles(directory),\n        numFiles = localConfigFiles.length,\n        projectConfigPath = ConfigFile.getFilenameForDirectory(thisConfig.options.cwd);\n    let found,\n        config = {},\n        rootPath;\n\n    for (let i = 0; i < numFiles; i++) {\n\n        const localConfigFile = localConfigFiles[i];\n\n        // Don't consider the personal config file in the home directory,\n        // except if the home directory is the same as the current working directory\n        if (path.dirname(localConfigFile) === PERSONAL_CONFIG_DIR && localConfigFile !== projectConfigPath) {\n            continue;\n        }\n\n        // If root flag is set, don't consider file if it is above root\n        if (rootPath && !pathIsInside(path.dirname(localConfigFile), rootPath)) {\n            continue;\n        }\n\n        debug(`Loading ${localConfigFile}`);\n        const localConfig = loadConfig(localConfigFile);\n\n        // Don't consider a local config file found if the config is null\n        if (!localConfig) {\n            continue;\n        }\n\n        // Check for root flag\n        if (localConfig.root === true) {\n            rootPath = path.dirname(localConfigFile);\n        }\n\n        found = true;\n        debug(`Using ${localConfigFile}`);\n        config = ConfigOps.merge(localConfig, config);\n    }\n\n    if (!found && !thisConfig.useSpecificConfig) {\n\n        /*\n         * - Is there a personal config in the user's home directory? If so,\n         *   merge that with the passed-in config.\n         * - Otherwise, if no rules were manually passed in, throw and error.\n         * - Note: This function is not called if useEslintrc is false.\n         */\n        const personalConfig = getPersonalConfig();\n\n        if (personalConfig) {\n            config = ConfigOps.merge(config, personalConfig);\n        } else if (!hasRules(thisConfig.options) && !thisConfig.options.baseConfig) {\n\n            // No config file, no manual configuration, and no rules, so error.\n            const noConfigError = new Error(\"No ESLint configuration found.\");\n\n            noConfigError.messageTemplate = \"no-config-found\";\n            noConfigError.messageData = {\n                directory,\n                filesExamined: localConfigFiles\n            };\n\n            throw noConfigError;\n        }\n    }\n\n    return config;\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * Configuration class\n */\nclass Config {\n\n    /**\n     * Config options\n     * @param {Object} options Options to be passed in\n     */\n    constructor(options) {\n        options = options || {};\n\n        this.ignore = options.ignore;\n        this.ignorePath = options.ignorePath;\n        this.cache = {};\n        this.parser = options.parser;\n        this.parserOptions = options.parserOptions || {};\n\n        this.baseConfig = options.baseConfig ? loadConfig(options.baseConfig) : { rules: {} };\n\n        this.useEslintrc = (options.useEslintrc !== false);\n\n        this.env = (options.envs || []).reduce((envs, name) => {\n            envs[ name ] = true;\n            return envs;\n        }, {});\n\n        /*\n         * Handle declared globals.\n         * For global variable foo, handle \"foo:false\" and \"foo:true\" to set\n         * whether global is writable.\n         * If user declares \"foo\", convert to \"foo:false\".\n         */\n        this.globals = (options.globals || []).reduce((globals, def) => {\n            const parts = def.split(\":\");\n\n            globals[parts[0]] = (parts.length > 1 && parts[1] === \"true\");\n\n            return globals;\n        }, {});\n\n        const useConfig = options.configFile;\n\n        this.options = options;\n\n        if (useConfig) {\n            debug(`Using command line config ${useConfig}`);\n            if (isResolvable(useConfig) || isResolvable(`eslint-config-${useConfig}`) || useConfig.charAt(0) === \"@\") {\n                this.useSpecificConfig = loadConfig(useConfig);\n            } else {\n                this.useSpecificConfig = loadConfig(path.resolve(this.options.cwd, useConfig));\n            }\n        }\n    }\n\n    /**\n     * Build a config object merging the base config (conf/eslint-recommended),\n     * the environments config (conf/environments.js) and eventually the user\n     * config.\n     * @param {string} filePath a file in whose directory we start looking for a local config\n     * @returns {Object} config object\n     */\n    getConfig(filePath) {\n        const directory = filePath ? path.dirname(filePath) : this.options.cwd;\n        let config,\n            userConfig;\n\n        debug(`Constructing config for ${filePath ? filePath : \"text\"}`);\n\n        config = this.cache[directory];\n\n        if (config) {\n            debug(\"Using config from cache\");\n            return config;\n        }\n\n        // Step 1: Determine user-specified config from .eslintrc.* and package.json files\n        if (this.useEslintrc) {\n            debug(\"Using .eslintrc and package.json files\");\n            userConfig = getLocalConfig(this, directory);\n        } else {\n            debug(\"Not using .eslintrc or package.json files\");\n            userConfig = {};\n        }\n\n        // Step 2: Create a copy of the baseConfig\n        config = ConfigOps.merge({}, this.baseConfig);\n\n        // Step 3: Merge in the user-specified configuration from .eslintrc and package.json\n        config = ConfigOps.merge(config, userConfig);\n\n        // Step 4: Merge in command line config file\n        if (this.useSpecificConfig) {\n            debug(\"Merging command line config file\");\n\n            config = ConfigOps.merge(config, this.useSpecificConfig);\n        }\n\n        // Step 5: Merge in command line environments\n        debug(\"Merging command line environment settings\");\n        config = ConfigOps.merge(config, { env: this.env });\n\n        // Step 6: Merge in command line rules\n        if (this.options.rules) {\n            debug(\"Merging command line rules\");\n            config = ConfigOps.merge(config, { rules: this.options.rules });\n        }\n\n        // Step 7: Merge in command line globals\n        config = ConfigOps.merge(config, { globals: this.globals });\n\n        // Only override parser if it is passed explicitly through the command line or if it's not\n        // defined yet (because the final object will at least have the parser key)\n        if (this.parser || !config.parser) {\n            config = ConfigOps.merge(config, {\n                parser: this.parser\n            });\n        }\n\n        if (this.parserOptions) {\n            config = ConfigOps.merge(config, {\n                parserOptions: this.parserOptions\n            });\n        }\n\n        // Step 8: Merge in command line plugins\n        if (this.options.plugins) {\n            debug(\"Merging command line plugins\");\n            Plugins.loadAll(this.options.plugins);\n            config = ConfigOps.merge(config, { plugins: this.options.plugins });\n        }\n\n        // Step 9: Apply environments to the config if present\n        if (config.env) {\n            config = ConfigOps.applyEnvironments(config);\n        }\n\n        this.cache[directory] = config;\n\n        return config;\n    }\n\n    /**\n     * Find local config files from directory and parent directories.\n     * @param {string} directory The directory to start searching from.\n     * @returns {string[]} The paths of local config files found.\n     */\n    findLocalConfigFiles(directory) {\n\n        if (!this.localConfigFinder) {\n            this.localConfigFinder = new FileFinder(ConfigFile.CONFIG_FILES, this.options.cwd);\n        }\n\n        return this.localConfigFinder.findAllInDirectoryAndParents(directory);\n    }\n}\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/config/config-file.js":"/**\n * @fileoverview Helper to locate and load configuration files.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-use-before-define: 0 */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    shell = require(\"shelljs\"),\n    ConfigOps = require(\"./config-ops\"),\n    validator = require(\"./config-validator\"),\n    Plugins = require(\"./plugins\"),\n    pathUtil = require(\"../util/path-util\"),\n    ModuleResolver = require(\"../util/module-resolver\"),\n    pathIsInside = require(\"path-is-inside\"),\n    stripBom = require(\"strip-bom\"),\n    stripComments = require(\"strip-json-comments\"),\n    stringify = require(\"json-stable-stringify\"),\n    defaultOptions = require(\"../../conf/eslint-recommended\"),\n    requireUncached = require(\"require-uncached\");\n\nconst debug = require(\"debug\")(\"eslint:config-file\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines sort order for object keys for json-stable-stringify\n *\n * see: https://github.com/substack/json-stable-stringify#cmp\n *\n * @param   {Object} a The first comparison object ({key: akey, value: avalue})\n * @param   {Object} b The second comparison object ({key: bkey, value: bvalue})\n * @returns {number}   1 or -1, used in stringify cmp method\n */\nfunction sortByKey(a, b) {\n    return a.key > b.key ? 1 : -1;\n}\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst CONFIG_FILES = [\n    \".eslintrc.js\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\nconst resolver = new ModuleResolver();\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents.\n * @private\n */\nfunction readFile(filePath) {\n    return stripBom(fs.readFileSync(filePath, \"utf8\"));\n}\n\n/**\n * Determines if a given string represents a filepath or not using the same\n * conventions as require(), meaning that the first character must be nonalphanumeric\n * and not the @ sign which is used for scoped packages to be considered a file path.\n * @param {string} filePath The string to check.\n * @returns {boolean} True if it's a filepath, false if not.\n * @private\n */\nfunction isFilePath(filePath) {\n    return path.isAbsolute(filePath) || !/\\w|@/.test(filePath.charAt(0));\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.safeLoad(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return requireUncached(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {Object} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        return loadJSONConfigFile(filePath).eslintConfig || null;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configMissingError(configName) {\n    const error = new Error(`Failed to load config \"${configName}\" to extend from.`);\n\n    error.messageTemplate = \"extend-config-missing\";\n    error.messageData = {\n        configName\n    };\n    return error;\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {Object} file The path to the configuration.\n * @returns {Object} The configuration information.\n * @private\n */\nfunction loadConfigFile(file) {\n    const filePath = file.filePath;\n    let config;\n\n    switch (path.extname(filePath)) {\n        case \".js\":\n            config = loadJSConfigFile(filePath);\n            if (file.configName) {\n                config = config.configs[file.configName];\n                if (!config) {\n                    throw configMissingError(file.configFullName);\n                }\n            }\n            break;\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                config = loadPackageJSONConfigFile(filePath);\n                if (config === null) {\n                    return null;\n                }\n            } else {\n                config = loadJSONConfigFile(filePath);\n            }\n            break;\n\n        case \".yaml\":\n        case \".yml\":\n            config = loadYAMLConfigFile(filePath);\n            break;\n\n        default:\n            config = loadLegacyConfigFile(filePath);\n    }\n\n    return ConfigOps.merge(ConfigOps.createEmptyConfig(), config);\n}\n\n/**\n * Writes a configuration file in JSON format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeJSONConfigFile(config, filePath) {\n    debug(`Writing JSON config file: ${filePath}`);\n\n    const content = stringify(config, { cmp: sortByKey, space: 4 });\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file in YAML format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeYAMLConfigFile(config, filePath) {\n    debug(`Writing YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    const content = yaml.safeDump(config, { sortKeys: true });\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file in JavaScript format.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @private\n */\nfunction writeJSConfigFile(config, filePath) {\n    debug(`Writing JS config file: ${filePath}`);\n\n    const content = `module.exports = ${stringify(config, { cmp: sortByKey, space: 4 })};`;\n\n    fs.writeFileSync(filePath, content, \"utf8\");\n}\n\n/**\n * Writes a configuration file.\n * @param {Object} config The configuration object to write.\n * @param {string} filePath The filename to write to.\n * @returns {void}\n * @throws {Error} When an unknown file type is specified.\n * @private\n */\nfunction write(config, filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n            writeJSConfigFile(config, filePath);\n            break;\n\n        case \".json\":\n            writeJSONConfigFile(config, filePath);\n            break;\n\n        case \".yaml\":\n        case \".yml\":\n            writeYAMLConfigFile(config, filePath);\n            break;\n\n        default:\n            throw new Error(\"Can't write to unknown file type.\");\n    }\n}\n\n/**\n * Determines the base directory for node packages referenced in a config file.\n * This does not include node_modules in the path so it can be used for all\n * references relative to a config file.\n * @param {string} configFilePath The config file referencing the file.\n * @returns {string} The base directory for the file path.\n * @private\n */\nfunction getBaseDir(configFilePath) {\n\n    // calculates the path of the project including ESLint as dependency\n    const projectPath = path.resolve(__dirname, \"../../../\");\n\n    if (configFilePath && pathIsInside(configFilePath, projectPath)) {\n\n        // be careful of https://github.com/substack/node-resolve/issues/78\n        return path.join(path.resolve(configFilePath));\n    }\n\n    /*\n     * default to ESLint project path since it's unlikely that plugins will be\n     * in this directory\n     */\n    return path.join(projectPath);\n}\n\n/**\n * Determines the lookup path, including node_modules, for package\n * references relative to a config file.\n * @param {string} configFilePath The config file referencing the file.\n * @returns {string} The lookup path for the file path.\n * @private\n */\nfunction getLookupPath(configFilePath) {\n    const basedir = getBaseDir(configFilePath);\n\n    return path.join(basedir, \"node_modules\");\n}\n\n/**\n * Resolves a eslint core config path\n * @param {string} name The eslint config name.\n * @returns {string} The resolved path of the config.\n * @private\n */\nfunction getEslintCoreConfigPath(name) {\n    if (name === \"eslint:recommended\") {\n\n       /*\n        * Add an explicit substitution for eslint:recommended to\n        * conf/eslint-recommended.js.\n        */\n        return path.resolve(__dirname, \"../../conf/eslint-recommended.js\");\n    }\n\n    if (name === \"eslint:all\") {\n\n       /*\n        * Add an explicit substitution for eslint:all to conf/eslint-all.js\n        */\n        return path.resolve(__dirname, \"../../conf/eslint-all.js\");\n    }\n\n    throw configMissingError(name);\n}\n\n/**\n * Applies values from the \"extends\" field in a configuration file.\n * @param {Object} config The configuration information.\n * @param {string} filePath The file path from which the configuration information\n *      was loaded.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} A new configuration object with all of the \"extends\" fields\n *      loaded and merged.\n * @private\n */\nfunction applyExtends(config, filePath, relativeTo) {\n    let configExtends = config.extends;\n\n    // normalize into an array for easier handling\n    if (!Array.isArray(config.extends)) {\n        configExtends = [config.extends];\n    }\n\n    // Make the last element in an array take the highest precedence\n    config = configExtends.reduceRight((previousValue, parentPath) => {\n        try {\n            if (parentPath.startsWith(\"eslint:\")) {\n                parentPath = getEslintCoreConfigPath(parentPath);\n            } else if (isFilePath(parentPath)) {\n\n                /*\n                 * If the `extends` path is relative, use the directory of the current configuration\n                 * file as the reference point. Otherwise, use as-is.\n                 */\n                parentPath = (path.isAbsolute(parentPath)\n                    ? parentPath\n                    : path.join(relativeTo || path.dirname(filePath), parentPath)\n                );\n            }\n            debug(`Loading ${parentPath}`);\n            return ConfigOps.merge(load(parentPath, false, relativeTo), previousValue);\n        } catch (e) {\n\n            /*\n             * If the file referenced by `extends` failed to load, add the path\n             * to the configuration file that referenced it to the error\n             * message so the user is able to see where it was referenced from,\n             * then re-throw.\n             */\n            e.message += `\\nReferenced from: ${filePath}`;\n            throw e;\n        }\n\n    }, config);\n\n    return config;\n}\n\n/**\n * Brings package name to correct format based on prefix\n * @param {string} name The name of the package.\n * @param {string} prefix Can be either \"eslint-plugin\" or \"eslint-config\n * @returns {string} Normalized name of the package\n * @private\n */\nfunction normalizePackageName(name, prefix) {\n\n    /*\n     * On Windows, name can come in with Windows slashes instead of Unix slashes.\n     * Normalize to Unix first to avoid errors later on.\n     * https://github.com/eslint/eslint/issues/5644\n     */\n    if (name.indexOf(\"\\\\\") > -1) {\n        name = pathUtil.convertPathToPosix(name);\n    }\n\n    if (name.charAt(0) === \"@\") {\n\n        /*\n         * it's a scoped package\n         * package name is \"eslint-config\", or just a username\n         */\n        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`),\n            scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`);\n\n        if (scopedPackageShortcutRegex.test(name)) {\n            name = name.replace(scopedPackageShortcutRegex, `$1/${prefix}`);\n        } else if (!scopedPackageNameRegex.test(name.split(\"/\")[1])) {\n\n            /*\n             * for scoped packages, insert the eslint-config after the first / unless\n             * the path is already @scope/eslint or @scope/eslint-config-xxx\n             */\n            name = name.replace(/^@([^/]+)\\/(.*)$/, `@$1/${prefix}-$2`);\n        }\n    } else if (name.indexOf(`${prefix}-`) !== 0) {\n        name = `${prefix}-${name}`;\n    }\n\n    return name;\n}\n\n/**\n * Resolves a configuration file path into the fully-formed path, whether filename\n * or package name.\n * @param {string} filePath The filepath to resolve.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} An object containing 3 properties:\n * - 'filePath' (required) the resolved path that can be used directly to load the configuration.\n * - 'configName' the name of the configuration inside the plugin.\n * - 'configFullName' the name of the configuration as used in the eslint config (e.g. 'plugin:node/recommended').\n * @private\n */\nfunction resolve(filePath, relativeTo) {\n    if (isFilePath(filePath)) {\n        return { filePath: path.resolve(relativeTo || \"\", filePath) };\n    }\n    let normalizedPackageName;\n\n    if (filePath.startsWith(\"plugin:\")) {\n        const configFullName = filePath;\n        const pluginName = filePath.substr(7, filePath.lastIndexOf(\"/\") - 7);\n        const configName = filePath.substr(filePath.lastIndexOf(\"/\") + 1, filePath.length - filePath.lastIndexOf(\"/\") - 1);\n\n        normalizedPackageName = normalizePackageName(pluginName, \"eslint-plugin\");\n        debug(`Attempting to resolve ${normalizedPackageName}`);\n        filePath = resolver.resolve(normalizedPackageName, getLookupPath(relativeTo));\n        return { filePath, configName, configFullName };\n    }\n    normalizedPackageName = normalizePackageName(filePath, \"eslint-config\");\n    debug(`Attempting to resolve ${normalizedPackageName}`);\n    filePath = resolver.resolve(normalizedPackageName, getLookupPath(relativeTo));\n    return { filePath };\n\n\n\n}\n\n/**\n * Loads a configuration file from the given file path.\n * @param {string} filePath The filename or package name to load the configuration\n *      information from.\n * @param {boolean} [applyEnvironments=false] Set to true to merge in environment settings.\n * @param {string} [relativeTo] The path to resolve relative to.\n * @returns {Object} The configuration information.\n * @private\n */\nfunction load(filePath, applyEnvironments, relativeTo) {\n    const resolvedPath = resolve(filePath, relativeTo),\n        dirname = path.dirname(resolvedPath.filePath),\n        lookupPath = getLookupPath(dirname);\n    let config = loadConfigFile(resolvedPath);\n\n    if (config) {\n\n        // ensure plugins are properly loaded first\n        if (config.plugins) {\n            Plugins.loadAll(config.plugins);\n        }\n\n        // remove parser from config if it is the default parser\n        if (config.parser === defaultOptions.parser) {\n            config.parser = null;\n        }\n\n        // include full path of parser if present\n        if (config.parser) {\n            if (isFilePath(config.parser)) {\n                config.parser = path.resolve(dirname || \"\", config.parser);\n            } else {\n                config.parser = resolver.resolve(config.parser, lookupPath);\n            }\n        }\n\n        // validate the configuration before continuing\n        validator.validate(config, filePath);\n\n        /*\n         * If an `extends` property is defined, it represents a configuration file to use as\n         * a \"parent\". Load the referenced file and merge the configuration recursively.\n         */\n        if (config.extends) {\n            config = applyExtends(config, filePath, dirname);\n        }\n\n        if (config.env && applyEnvironments) {\n\n            // Merge in environment-specific globals and parserOptions.\n            config = ConfigOps.applyEnvironments(config);\n        }\n\n    }\n\n    return config;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    getBaseDir,\n    getLookupPath,\n    load,\n    resolve,\n    write,\n    applyExtends,\n    normalizePackageName,\n    CONFIG_FILES,\n\n    /**\n     * Retrieves the configuration filename for a given directory. It loops over all\n     * of the valid configuration filenames in order to find the first one that exists.\n     * @param {string} directory The directory to check for a config file.\n     * @returns {?string} The filename of the configuration file for the directory\n     *      or null if there is no configuration file in the directory.\n     */\n    getFilenameForDirectory(directory) {\n        for (let i = 0, len = CONFIG_FILES.length; i < len; i++) {\n            const filename = path.join(directory, CONFIG_FILES[i]);\n\n            if (shell.test(\"-f\", filename)) {\n                return filename;\n            }\n        }\n\n        return null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/config/plugins.js":"/**\n * @fileoverview Plugins manager\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Environments = require(\"./environments\"),\n    Rules = require(\"../rules\");\n\nconst debug = require(\"debug\")(\"eslint:plugins\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nlet plugins = Object.create(null);\n\nconst PLUGIN_NAME_PREFIX = \"eslint-plugin-\",\n    NAMESPACE_REGEX = /^@.*\\//i;\n\n/**\n * Removes the prefix `eslint-plugin-` from a plugin name.\n * @param {string} pluginName The name of the plugin which may have the prefix.\n * @returns {string} The name of the plugin without prefix.\n */\nfunction removePrefix(pluginName) {\n    return pluginName.indexOf(PLUGIN_NAME_PREFIX) === 0 ? pluginName.substring(PLUGIN_NAME_PREFIX.length) : pluginName;\n}\n\n/**\n * Gets the scope (namespace) of a plugin.\n * @param {string} pluginName The name of the plugin which may have the prefix.\n * @returns {string} The name of the plugins namepace if it has one.\n */\nfunction getNamespace(pluginName) {\n    return pluginName.match(NAMESPACE_REGEX) ? pluginName.match(NAMESPACE_REGEX)[0] : \"\";\n}\n\n/**\n * Removes the namespace from a plugin name.\n * @param {string} pluginName The name of the plugin which may have the prefix.\n * @returns {string} The name of the plugin without the namespace.\n */\nfunction removeNamespace(pluginName) {\n    return pluginName.replace(NAMESPACE_REGEX, \"\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    removePrefix,\n    getNamespace,\n    removeNamespace,\n\n    /**\n     * Defines a plugin with a given name rather than loading from disk.\n     * @param {string} pluginName The name of the plugin to load.\n     * @param {Object} plugin The plugin object.\n     * @returns {void}\n     */\n    define(pluginName, plugin) {\n        const pluginNamespace = getNamespace(pluginName),\n            pluginNameWithoutNamespace = removeNamespace(pluginName),\n            pluginNameWithoutPrefix = removePrefix(pluginNameWithoutNamespace),\n            shortName = pluginNamespace + pluginNameWithoutPrefix;\n\n        // load up environments and rules\n        plugins[shortName] = plugin;\n        Environments.importPlugin(plugin, shortName);\n        Rules.importPlugin(plugin, shortName);\n\n        // load up environments and rules for the name that '@scope/' was omitted\n        // 3 lines below will be removed by 4.0.0\n        plugins[pluginNameWithoutPrefix] = plugin;\n        Environments.importPlugin(plugin, pluginNameWithoutPrefix);\n        Rules.importPlugin(plugin, pluginNameWithoutPrefix);\n    },\n\n    /**\n     * Gets a plugin with the given name.\n     * @param {string} pluginName The name of the plugin to retrieve.\n     * @returns {Object} The plugin or null if not loaded.\n     */\n    get(pluginName) {\n        return plugins[pluginName] || null;\n    },\n\n    /**\n     * Returns all plugins that are loaded.\n     * @returns {Object} The plugins cache.\n     */\n    getAll() {\n        return plugins;\n    },\n\n    /**\n     * Loads a plugin with the given name.\n     * @param {string} pluginName The name of the plugin to load.\n     * @returns {void}\n     * @throws {Error} If the plugin cannot be loaded.\n     */\n    load(pluginName) {\n        const pluginNamespace = getNamespace(pluginName),\n            pluginNameWithoutNamespace = removeNamespace(pluginName),\n            pluginNameWithoutPrefix = removePrefix(pluginNameWithoutNamespace),\n            shortName = pluginNamespace + pluginNameWithoutPrefix,\n            longName = pluginNamespace + PLUGIN_NAME_PREFIX + pluginNameWithoutPrefix;\n        let plugin = null;\n\n        if (pluginName.match(/\\s+/)) {\n            const whitespaceError = new Error(`Whitespace found in plugin name '${pluginName}'`);\n\n            whitespaceError.messageTemplate = \"whitespace-found\";\n            whitespaceError.messageData = {\n                pluginName: longName\n            };\n            throw whitespaceError;\n        }\n\n        if (!plugins[shortName]) {\n            try {\n                plugin = require(longName);\n            } catch (pluginLoadErr) {\n                try {\n\n                    // Check whether the plugin exists\n                    require.resolve(longName);\n                } catch (missingPluginErr) {\n\n                    // If the plugin can't be resolved, display the missing plugin error (usually a config or install error)\n                    debug(`Failed to load plugin ${longName}.`);\n                    missingPluginErr.message = `Failed to load plugin ${pluginName}: ${missingPluginErr.message}`;\n                    missingPluginErr.messageTemplate = \"plugin-missing\";\n                    missingPluginErr.messageData = {\n                        pluginName: longName\n                    };\n                    throw missingPluginErr;\n                }\n\n                // Otherwise, the plugin exists and is throwing on module load for some reason, so print the stack trace.\n                throw pluginLoadErr;\n            }\n\n            this.define(pluginName, plugin);\n        }\n    },\n\n    /**\n     * Loads all plugins from an array.\n     * @param {string[]} pluginNames An array of plugins names.\n     * @returns {void}\n     * @throws {Error} If a plugin cannot be loaded.\n     */\n    loadAll(pluginNames) {\n        pluginNames.forEach(this.load, this);\n    },\n\n    /**\n     * Resets plugin information. Use for tests only.\n     * @returns {void}\n     */\n    testReset() {\n        plugins = Object.create(null);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/module-resolver.js":"/**\n * @fileoverview Implements the Node.js require.resolve algorithm\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Module = require(\"module\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS = {\n\n    /*\n     * module.paths is an array of paths to search for resolving things relative\n     * to this file. Module.globalPaths contains all of the special Node.js\n     * directories that can also be searched for modules.\n     *\n     * Need to check for existence of module.paths because Jest seems not to\n     * include it. See https://github.com/eslint/eslint/issues/5791.\n     */\n    lookupPaths: module.paths ? module.paths.concat(Module.globalPaths) : Module.globalPaths.concat()\n};\n\n/**\n * Resolves modules based on a set of options.\n */\nclass ModuleResolver {\n\n    /**\n     * Resolves modules based on a set of options.\n     * @param {Object} options The options for resolving modules.\n     * @param {string[]} options.lookupPaths An array of paths to include in the\n     *      lookup with the highest priority paths coming first.\n     */\n    constructor(options) {\n        this.options = Object.assign({}, DEFAULT_OPTIONS, options || {});\n    }\n\n    /**\n     * Resolves the file location of a given module relative to the configured\n     * lookup paths.\n     * @param {string} name The module name to resolve.\n     * @param {string} extraLookupPath An extra path to look into for the module.\n     *      This path is used with the highest priority.\n     * @returns {string} The resolved file path for the module.\n     * @throws {Error} If the module cannot be resolved.\n     */\n    resolve(name, extraLookupPath) {\n\n        /*\n         * First, clone the lookup paths so we're not messing things up for\n         * subsequent calls to this function. Then, move the extraLookupPath to the\n         * top of the lookup paths list so it will be searched first.\n         */\n        const lookupPaths = this.options.lookupPaths.concat();\n\n        lookupPaths.unshift(extraLookupPath);\n\n        /**\n         * Module._findPath is an internal method to Node.js, then one they use to\n         * lookup file paths when require() is called. So, we are hooking into the\n         * exact same logic that Node.js uses.\n         */\n        const result = Module._findPath(name, lookupPaths);   // eslint-disable-line no-underscore-dangle\n\n        if (!result) {\n            throw new Error(`Cannot find module '${name}'`);\n        }\n\n        return result;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nmodule.exports = ModuleResolver;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/file-finder.js":"/**\n * @fileoverview Util class to find config files.\n * @author Aliaksei Shytkin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Get the entries for a directory. Including a try-catch may be detrimental to\n * function performance, so move it out here a separate function.\n * @param {string} directory The directory to search in.\n * @returns {string[]} The entries in the directory or an empty array on error.\n * @private\n */\nfunction getDirectoryEntries(directory) {\n    try {\n        return fs.readdirSync(directory);\n    } catch (ex) {\n        return [];\n    }\n}\n\n/**\n * Create a hash of filenames from a directory listing\n * @param {string[]} entries Array of directory entries.\n * @param {string} directory Path to a current directory.\n * @param {string[]} supportedConfigs List of support filenames.\n * @returns {Object} Hashmap of filenames\n */\nfunction normalizeDirectoryEntries(entries, directory, supportedConfigs) {\n    const fileHash = {};\n\n    entries.forEach(entry => {\n        if (supportedConfigs.indexOf(entry) >= 0) {\n            const resolvedEntry = path.resolve(directory, entry);\n\n            if (fs.statSync(resolvedEntry).isFile()) {\n                fileHash[entry] = resolvedEntry;\n            }\n        }\n    });\n    return fileHash;\n}\n\n//------------------------------------------------------------------------------\n// API\n//------------------------------------------------------------------------------\n\n/**\n * FileFinder class\n */\nclass FileFinder {\n\n    /**\n     * @param {string[]} files The basename(s) of the file(s) to find.\n     * @param {stirng} cwd Current working directory\n     */\n    constructor(files, cwd) {\n        this.fileNames = Array.isArray(files) ? files : [files];\n        this.cwd = cwd || process.cwd();\n        this.cache = {};\n    }\n\n    /**\n     * Find all instances of files with the specified file names, in directory and\n     * parent directories. Cache the results.\n     * Does not check if a matching directory entry is a file.\n     * Searches for all the file names in this.fileNames.\n     * Is currently used by lib/config.js to find .eslintrc and package.json files.\n     * @param  {string} directory The directory to start the search from.\n     * @returns {string[]} The file paths found.\n     */\n    findAllInDirectoryAndParents(directory) {\n        const cache = this.cache;\n\n        if (directory) {\n            directory = path.resolve(this.cwd, directory);\n        } else {\n            directory = this.cwd;\n        }\n\n        if (cache.hasOwnProperty(directory)) {\n            return cache[directory];\n        }\n\n        const dirs = [];\n        const fileNames = this.fileNames;\n        let searched = 0;\n\n        do {\n            dirs[searched++] = directory;\n            cache[directory] = [];\n\n            const filesMap = normalizeDirectoryEntries(getDirectoryEntries(directory), directory, fileNames);\n\n            if (Object.keys(filesMap).length) {\n                for (let k = 0; k < fileNames.length; k++) {\n\n                    if (filesMap[fileNames[k]]) {\n                        const filePath = filesMap[fileNames[k]];\n\n                        // Add the file path to the cache of each directory searched.\n                        for (let j = 0; j < searched; j++) {\n                            cache[dirs[j]].push(filePath);\n                        }\n\n                        break;\n                    }\n                }\n            }\n            const child = directory;\n\n            // Assign parent directory to directory.\n            directory = path.dirname(directory);\n\n            if (directory === child) {\n                return cache[dirs[0]];\n            }\n        } while (!cache.hasOwnProperty(directory));\n\n        // Add what has been cached previously to the cache of each directory searched.\n        for (let i = 0; i < searched; i++) {\n            dirs.push.apply(cache[dirs[i]], cache[directory]);\n        }\n\n        return cache[dirs[0]];\n    }\n}\n\nmodule.exports = FileFinder;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/glob-util.js":"/**\n * @fileoverview Utilities for working with globs and the filesystem.\n * @author Ian VanSchooten\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    GlobSync = require(\"./glob\"),\n    shell = require(\"shelljs\"),\n\n    pathUtil = require(\"./path-util\"),\n    IgnoredPaths = require(\"../ignored-paths\");\n\nconst debug = require(\"debug\")(\"eslint:glob-util\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks if a provided path is a directory and returns a glob string matching\n * all files under that directory if so, the path itself otherwise.\n *\n * Reason for this is that `glob` needs `/**` to collect all the files under a\n * directory where as our previous implementation without `glob` simply walked\n * a directory that is passed. So this is to maintain backwards compatibility.\n *\n * Also makes sure all path separators are POSIX style for `glob` compatibility.\n *\n * @param {Object}   [options]                    An options object\n * @param {string[]} [options.extensions=[\".js\"]] An array of accepted extensions\n * @param {string}   [options.cwd=process.cwd()]  The cwd to use to resolve relative pathnames\n * @returns {Function} A function that takes a pathname and returns a glob that\n *                     matches all files with the provided extensions if\n *                     pathname is a directory.\n */\nfunction processPath(options) {\n    const cwd = (options && options.cwd) || process.cwd();\n    let extensions = (options && options.extensions) || [\".js\"];\n\n    extensions = extensions.map(ext => ext.replace(/^\\./, \"\"));\n\n    let suffix = \"/**\";\n\n    if (extensions.length === 1) {\n        suffix += `/*.${extensions[0]}`;\n    } else {\n        suffix += `/*.{${extensions.join(\",\")}}`;\n    }\n\n    /**\n     * A function that converts a directory name to a glob pattern\n     *\n     * @param {string} pathname The directory path to be modified\n     * @returns {string} The glob path or the file path itself\n     * @private\n     */\n    return function(pathname) {\n        let newPath = pathname;\n        const resolvedPath = path.resolve(cwd, pathname);\n\n        if (shell.test(\"-d\", resolvedPath)) {\n            newPath = pathname.replace(/[/\\\\]$/, \"\") + suffix;\n        }\n\n        return pathUtil.convertPathToPosix(newPath);\n    };\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Resolves any directory patterns into glob-based patterns for easier handling.\n * @param   {string[]} patterns    File patterns (such as passed on the command line).\n * @param   {Object} options       An options object.\n * @returns {string[]} The equivalent glob patterns and filepath strings.\n */\nfunction resolveFileGlobPatterns(patterns, options) {\n\n    const processPathExtensions = processPath(options);\n\n    return patterns.filter(p => p.length).map(processPathExtensions);\n}\n\n/**\n * Build a list of absolute filesnames on which ESLint will act.\n * Ignored files are excluded from the results, as are duplicates.\n *\n * @param   {string[]} globPatterns            Glob patterns.\n * @param   {Object}   [options]               An options object.\n * @param   {string}   [options.cwd]           CWD (considered for relative filenames)\n * @param   {boolean}  [options.ignore]        False disables use of .eslintignore.\n * @param   {string}   [options.ignorePath]    The ignore file to use instead of .eslintignore.\n * @param   {string}   [options.ignorePattern] A pattern of files to ignore.\n * @returns {string[]} Resolved absolute filenames.\n */\nfunction listFilesToProcess(globPatterns, options) {\n    options = options || { ignore: true };\n    const files = [],\n        added = {};\n\n    const cwd = (options && options.cwd) || process.cwd();\n\n    /**\n     * Executes the linter on a file defined by the `filename`. Skips\n     * unsupported file extensions and any files that are already linted.\n     * @param {string} filename The file to be processed\n     * @param {boolean} shouldWarnIgnored Whether or not a report should be made if\n     *                                    the file is ignored\n     * @param {IgnoredPaths} ignoredPaths An instance of IgnoredPaths\n     * @returns {void}\n     */\n    function addFile(filename, shouldWarnIgnored, ignoredPaths) {\n        let ignored = false;\n        let isSilentlyIgnored;\n\n        if (ignoredPaths.contains(filename, \"default\")) {\n            ignored = (options.ignore !== false) && shouldWarnIgnored;\n            isSilentlyIgnored = !shouldWarnIgnored;\n        }\n\n        if (options.ignore !== false) {\n            if (ignoredPaths.contains(filename, \"custom\")) {\n                if (shouldWarnIgnored) {\n                    ignored = true;\n                } else {\n                    isSilentlyIgnored = true;\n                }\n            }\n        }\n\n        if (isSilentlyIgnored && !ignored) {\n            return;\n        }\n\n        if (added[filename]) {\n            return;\n        }\n        files.push({ filename, ignored });\n        added[filename] = true;\n    }\n\n    debug(\"Creating list of files to process.\");\n    globPatterns.forEach(pattern => {\n        const file = path.resolve(cwd, pattern);\n\n        if (shell.test(\"-f\", file)) {\n            const ignoredPaths = new IgnoredPaths(options);\n\n            addFile(fs.realpathSync(file), !shell.test(\"-d\", file), ignoredPaths);\n        } else {\n\n            // regex to find .hidden or /.hidden patterns, but not ./relative or ../relative\n            const globIncludesDotfiles = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/.test(pattern);\n\n            const ignoredPaths = new IgnoredPaths(Object.assign({}, options, { dotfiles: options.dotfiles || globIncludesDotfiles }));\n            const shouldIgnore = ignoredPaths.getIgnoredFoldersGlobChecker();\n            const globOptions = {\n                nodir: true,\n                dot: true,\n                cwd\n            };\n\n            new GlobSync(pattern, globOptions, shouldIgnore).found.forEach(globMatch => {\n                addFile(path.resolve(cwd, globMatch), false, ignoredPaths);\n            });\n        }\n    });\n\n    return files;\n}\n\nmodule.exports = {\n    resolveFileGlobPatterns,\n    listFilesToProcess\n};\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/glob.js":"/**\n * @fileoverview An inherited `glob.GlobSync` to support .gitignore patterns.\n * @author Kael Zhang\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Sync = require(\"glob\").GlobSync,\n    util = require(\"util\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nconst IGNORE = Symbol(\"ignore\");\n\n/**\n * Subclass of `glob.GlobSync`\n * @param {string}     pattern      Pattern to be matched.\n * @param {Object}     options      `options` for `glob`\n * @param {function()} shouldIgnore Method to check whether a directory should be ignored.\n * @constructor\n */\nfunction GlobSync(pattern, options, shouldIgnore) {\n\n    /**\n     * We don't put this thing to argument `options` to avoid\n     * further problems, such as `options` validation.\n     *\n     * Use `Symbol` as much as possible to avoid confliction.\n     */\n    this[IGNORE] = shouldIgnore;\n\n    Sync.call(this, pattern, options);\n}\n\nutil.inherits(GlobSync, Sync);\n\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_readdir\", \"_mark\"] }] */\n\nGlobSync.prototype._readdir = function(abs, inGlobStar) {\n\n    /**\n     * `options.nodir` makes `options.mark` as `true`.\n     * Mark `abs` first\n     * to make sure `\"node_modules\"` will be ignored immediately with ignore pattern `\"node_modules/\"`.\n\n     * There is a built-in cache about marked `File.Stat` in `glob`, so that we could not worry about the extra invocation of `this._mark()`\n     */\n    const marked = this._mark(abs);\n\n    if (this[IGNORE](marked)) {\n        return null;\n    }\n\n    return Sync.prototype._readdir.call(this, abs, inGlobStar);\n};\n\n\nmodule.exports = GlobSync;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/source-code-fixer.js":"/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:text-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {SourceCode} sourceCode The source code to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceCode, messages) {\n\n    debug(\"Applying fixes\");\n\n    if (!sourceCode) {\n        debug(\"No source code to fix\");\n        return {\n            fixed: false,\n            messages,\n            output: \"\"\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = (sourceCode.hasBOM ? BOM : \"\"),\n        text = sourceCode.text;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    messages.forEach(problem => {\n        if (problem.hasOwnProperty(\"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            const fix = problem.fix;\n            const start = fix.range[0];\n            const end = fix.range[1];\n\n            // Remain it as a problem if it's overlapped or it's a negative range\n            if (lastPos >= start || start > end) {\n                remainingMessages.push(problem);\n                continue;\n            }\n\n            // Remove BOM.\n            if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n                output = \"\";\n            }\n\n            // Make output to this fix.\n            output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n            output += fix.text;\n            lastPos = end;\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: true,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/util/hash.js":"/**\n * @fileoverview Defining the hashing function in one place.\n * @author Michael Ficarra\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst murmur = require(\"imurmurhash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * hash the given string\n * @param  {string} str the string to hash\n * @returns {string}    the hash\n */\nfunction hash(str) {\n    return murmur(str).result().toString(36);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = hash;\n","/home/travis/build/npmtest/node-npmtest-eslint/eslint/lib/testers/rule-tester.js":"/**\n * @fileoverview Mocha test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* global describe, it */\n\n/*\n * This is a wrapper around mocha to allow for DRY unittests for eslint\n * Format:\n * RuleTester.add(\"{ruleName}\", {\n *      valid: [\n *          \"{code}\",\n *          { code: \"{code}\", options: {options}, global: {globals}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\n *      ],\n *      invalid: [\n *          { code: \"{code}\", errors: {numErrors} },\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\n *          { code: \"{code}\", options: {options}, global: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\n *      ]\n *  });\n *\n * Variables:\n * {code} - String that represents the code to be tested\n * {options} - Arguments that are passed to the configurable rules.\n * {globals} - An object representing a list of variables that are\n *             registered as globals\n * {parser} - String representing the parser to use\n * {settings} - An object representing global settings for all rules\n * {numErrors} - If failing case doesn't need to check error message,\n *               this integer will specify how many errors should be\n *               received\n * {errorMessage} - Message that is returned by the rule on failure\n * {errorNodeType} - AST node type that is returned by they rule as\n *                   a cause of the failure.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst lodash = require(\"lodash\"),\n    assert = require(\"assert\"),\n    util = require(\"util\"),\n    validator = require(\"../config/config-validator\"),\n    validate = require(\"is-my-json-valid\"),\n    eslint = require(\"../eslint\"),\n    rules = require(\"../rules\"),\n    metaSchema = require(\"../../conf/json-schema-schema.json\"),\n    SourceCodeFixer = require(\"../util/source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\nlet defaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"args\",\n    \"errors\"\n];\n\nconst validateSchema = validate(metaSchema, { verbose: true });\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n *\n * @param {any} x - A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n *\n * @param {any} x - A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates a new instance of RuleTester.\n * @param {Object} [testerConfig] Optional, extra configuration for the tester\n * @constructor\n */\nfunction RuleTester(testerConfig) {\n\n    /**\n     * The configuration to use for this tester. Combination of the tester\n     * configuration and the default configuration.\n     * @type {Object}\n     */\n    this.testerConfig = lodash.merge(\n\n        // we have to clone because merge uses the first argument for recipient\n        lodash.cloneDeep(defaultConfig),\n        testerConfig\n    );\n\n    /**\n     * Rule definitions to define before tests.\n     * @type {Object}\n     */\n    this.rules = {};\n}\n\n/**\n * Set the configuration to use for all future tests\n * @param {Object} config the configuration to use.\n * @returns {void}\n */\nRuleTester.setDefaultConfig = function(config) {\n    if (typeof config !== \"object\") {\n        throw new Error(\"RuleTester.setDefaultConfig: config must be an object\");\n    }\n    defaultConfig = config;\n\n    // Make sure the rules object exists since it is assumed to exist later\n    defaultConfig.rules = defaultConfig.rules || {};\n};\n\n/**\n * Get the current configuration used for all tests\n * @returns {Object} the current configuration\n */\nRuleTester.getDefaultConfig = function() {\n    return defaultConfig;\n};\n\n/**\n * Reset the configuration to the initial configuration of the tester removing\n * any changes made until now.\n * @returns {void}\n */\nRuleTester.resetDefaultConfig = function() {\n    defaultConfig = lodash.cloneDeep(testerDefaultConfig);\n};\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\n\nRuleTester[DESCRIBE] = RuleTester[IT] = null;\n\n/**\n * This is `it` or `describe` if those don't exist.\n * @this {Mocha}\n * @param {string} text - The description of the test case.\n * @param {Function} method - The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction defaultHandler(text, method) {\n    return method.apply(this);\n}\n\n// If people use `mocha test.js --watch` command, `describe` and `it` function\n// instances are different for each execution. So this should get fresh instance\n// always.\nObject.defineProperties(RuleTester, {\n    describe: {\n        get() {\n            return (\n                RuleTester[DESCRIBE] ||\n                (typeof describe === \"function\" ? describe : defaultHandler)\n            );\n        },\n        set(value) {\n            RuleTester[DESCRIBE] = value;\n        },\n        configurable: true,\n        enumerable: true\n    },\n    it: {\n        get() {\n            return (\n                RuleTester[IT] ||\n                (typeof it === \"function\" ? it : defaultHandler)\n            );\n        },\n        set(value) {\n            RuleTester[IT] = value;\n        },\n        configurable: true,\n        enumerable: true\n    }\n});\n\nRuleTester.prototype = {\n\n    /**\n     * Define a rule for one particular run of tests.\n     * @param {string} name The name of the rule to define.\n     * @param {Function} rule The rule definition.\n     * @returns {void}\n     */\n    defineRule(name, rule) {\n        this.rules[name] = rule;\n    },\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Function} rule The rule to test.\n     * @param {Object} test The collection of tests to run.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            result = {};\n\n        if (lodash.isNil(test) || typeof test !== \"object\") {\n            throw new Error(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (lodash.isNil(test[scenarioType])) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n        /* eslint-disable no-shadow */\n\n        /**\n         * Run the rule for the given item\n         * @param {string} ruleName name of the rule\n         * @param {string|Object} item Item to run the rule against\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(ruleName, item) {\n            let config = lodash.cloneDeep(testerConfig),\n                code, filename, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                // Assumes everything on the item is a config except for the\n                // parameters used by this tester\n                const itemConfig = lodash.omit(item, RuleTesterParameters);\n\n                // Create the config object from the tester config and this item\n                // specific configurations.\n                config = lodash.merge(\n                    config,\n                    itemConfig\n                );\n            }\n\n            if (item.filename) {\n                filename = item.filename;\n            }\n\n            if (item.options) {\n                const options = item.options.concat();\n\n                options.unshift(1);\n                config.rules[ruleName] = options;\n            } else {\n                config.rules[ruleName] = 1;\n            }\n\n            eslint.defineRule(ruleName, rule);\n\n            const schema = validator.getRuleOptionsSchema(ruleName);\n\n            if (schema) {\n                validateSchema(schema);\n\n                if (validateSchema.errors) {\n                    throw new Error([\n                        `Schema for rule ${ruleName} is invalid:`\n                    ].concat(validateSchema.errors.map(error => `\\t${error.field}: ${error.message}`)).join(\"\\n\"));\n                }\n            }\n\n            validator.validate(config, \"rule-tester\");\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            eslint.reset();\n\n            eslint.on(\"Program\", node => {\n                beforeAST = cloneDeeplyExcludesParent(node);\n            });\n\n            eslint.on(\"Program:exit\", node => {\n                afterAST = node;\n            });\n\n            // Freezes rule-context properties.\n            const originalGet = rules.get;\n\n            try {\n                rules.get = function(ruleId) {\n                    const rule = originalGet(ruleId);\n\n                    if (typeof rule === \"function\") {\n                        return function(context) {\n                            Object.freeze(context);\n                            freezeDeeply(context.options);\n                            freezeDeeply(context.settings);\n                            freezeDeeply(context.parserOptions);\n\n                            return rule(context);\n                        };\n                    }\n                    return {\n                        meta: rule.meta,\n                        create(context) {\n                            Object.freeze(context);\n                            freezeDeeply(context.options);\n                            freezeDeeply(context.settings);\n                            freezeDeeply(context.parserOptions);\n\n                            return rule.create(context);\n                        }\n                    };\n\n                };\n\n                return {\n                    messages: eslint.verify(code, config, filename, true),\n                    beforeAST,\n                    afterAST: cloneDeeplyExcludesParent(afterAST)\n                };\n            } finally {\n                rules.get = originalGet;\n            }\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!lodash.isEqual(beforeAST, afterAST)) {\n\n                // Not using directly to avoid performance problem in node 6.1.0. See #6111\n                assert.deepEqual(beforeAST, afterAST, \"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string} ruleName name of the rule\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(ruleName, item) {\n            const result = runRuleForItem(ruleName, item);\n            const messages = result.messages;\n\n            assert.equal(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                        messages.length, util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.equal(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string} ruleName name of the rule\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(ruleName, item) {\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            const result = runRuleForItem(ruleName, item);\n            const messages = result.messages;\n\n\n\n            if (typeof item.errors === \"number\") {\n                assert.equal(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n            } else {\n                assert.equal(messages.length, item.errors.length,\n                    util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    assert.ok(!(\"fatal\" in messages[i]), `A fatal parsing error occurred: ${messages[i].message}`);\n                    assert.equal(messages[i].ruleId, ruleName, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof item.errors[i] === \"string\" || item.errors[i] instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(messages[i].message, item.errors[i]);\n                    } else if (typeof item.errors[i] === \"object\") {\n\n                        /*\n                         * Error object.\n                         * This may have a message, node type, line, and/or\n                         * column.\n                         */\n                        if (item.errors[i].message) {\n                            assertMessageMatches(messages[i].message, item.errors[i].message);\n                        }\n\n                        if (item.errors[i].type) {\n                            assert.equal(messages[i].nodeType, item.errors[i].type, `Error type should be ${item.errors[i].type}, found ${messages[i].nodeType}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"line\")) {\n                            assert.equal(messages[i].line, item.errors[i].line, `Error line should be ${item.errors[i].line}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"column\")) {\n                            assert.equal(messages[i].column, item.errors[i].column, `Error column should be ${item.errors[i].column}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"endLine\")) {\n                            assert.equal(messages[i].endLine, item.errors[i].endLine, `Error endLine should be ${item.errors[i].endLine}`);\n                        }\n\n                        if (item.errors[i].hasOwnProperty(\"endColumn\")) {\n                            assert.equal(messages[i].endColumn, item.errors[i].endColumn, `Error endColumn should be ${item.errors[i].endColumn}`);\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(messages[i], null, \"Error should be a string, object, or RegExp.\");\n                    }\n                }\n            }\n\n            if (item.hasOwnProperty(\"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        messages.filter(message => message.fix).length,\n                        0,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    const fixResult = SourceCodeFixer.applyFixes(eslint.getSourceCode(), messages);\n\n                    assert.equal(fixResult.output, item.output, \"Output is incorrect.\");\n                }\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         */\n        RuleTester.describe(ruleName, () => {\n            RuleTester.describe(\"valid\", () => {\n                test.valid.forEach(valid => {\n                    RuleTester.it(typeof valid === \"object\" ? valid.code : valid, () => {\n                        eslint.defineRules(this.rules);\n                        testValidTemplate(ruleName, valid);\n                    });\n                });\n            });\n\n            RuleTester.describe(\"invalid\", () => {\n                test.invalid.forEach(invalid => {\n                    RuleTester.it(invalid.code, () => {\n                        eslint.defineRules(this.rules);\n                        testInvalidTemplate(ruleName, invalid);\n                    });\n                });\n            });\n        });\n\n        return result.suite;\n    }\n};\n\n\nmodule.exports = RuleTester;\n"}